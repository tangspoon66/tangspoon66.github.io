<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About POM</title>
    <url>/2020/12/04/About-POM/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201204165031981.png" alt="image-20201204165031981" style="zoom:50%;" />
<a id="more"></a>
<h2 id="一-什么是pom"><a class="markdownIt-Anchor" href="#一-什么是pom"></a> 一、什么是POM</h2>
<p>POM：Page Object Model——页面对象模型。是一种思想，是一种设计模式，相对应的还有关键字设计模式。</p>
<h2 id="二-为什么要用pom"><a class="markdownIt-Anchor" href="#二-为什么要用pom"></a> 二、为什么要用POM</h2>
<p>在自动化测试的代码编写中，采用普通模式，会产生很多代码冗余。例如元素定位模块，每一个元素都得写<code>find_element_by_xxx</code>，在大型项目中这么写效率显然非常低下。</p>
<p>另外，在UI测试中，前端元素会经常发生改变。普通模式把元素定位、元素操作逻辑、测试脚本等模块揉杂在一个文件内，其一，这种操作看起来非常混乱；其二，如果前端页面发生变化，首先要修改页面元素定位，还要修改测试代码。</p>
<p>而POM模型，把元素定位、业务逻辑分开编写，每个模块独立。每一个页面对应一个页面类，页面的元素写到这个页面类中。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201204162211182.png" alt="image-20201204162211182" style="zoom:50%;" />
<h2 id="三-在哪一阶段要用到pom"><a class="markdownIt-Anchor" href="#三-在哪一阶段要用到pom"></a> 三、在哪一阶段要用到POM</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201205163712845.png" alt="image-20201205163712845" style="zoom:50%;" />
<h2 id="四-怎么用"><a class="markdownIt-Anchor" href="#四-怎么用"></a> 四、怎么用</h2>
<h3 id="1-bagepy如下"><a class="markdownIt-Anchor" href="#1-bagepy如下"></a> 1. bage.py如下：</h3>
<p>base.py主要写复用率高的函数，比如打开页面、元素定位、退出等等。该页面中不应该含有固定参数，应该全用变量，所有变量都应该在测试用例中定义的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, driver, url</span>):</span></span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># open</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># locator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">locator</span>(<span class="params">self, loc</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.driver.find_element(*loc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># quit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.driver.quit()</span><br></pre></td></tr></table></figure>
<h3 id="2-login_pagepy如下"><a class="markdownIt-Anchor" href="#2-login_pagepy如下"></a> 2. login_page.py如下：</h3>
<p>对象页面其实也就只需写两个内容，获取元素，然后封装元素的每一个操作：先定位，然后再用selenium的元素操作send_keys、click等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> base_page.base <span class="keyword">import</span> BasePage</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在这里主要写登陆页面，思路如下：</span></span><br><span class="line"><span class="string">    1、找到元素</span></span><br><span class="line"><span class="string">    2、然后元素操作封装</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span>(<span class="params">BasePage</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;http://39.98.138.157/shopxo/index.php?s=/index/user/logininfo.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    username = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[1]/input&#x27;</span>)</span><br><span class="line">    password = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[2]/input&#x27;</span>)</span><br><span class="line">    login_btn = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[3]/button&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_username</span>(<span class="params">self, un</span>):</span></span><br><span class="line">        self.locator(self.username).send_keys(un)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_password</span>(<span class="params">self, pwd</span>):</span></span><br><span class="line">        self.locator(self.password).send_keys(pwd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.locator(self.login_btn).click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-testunitpy如下"><a class="markdownIt-Anchor" href="#3-testunitpy如下"></a> 3. TestUnit.py如下：</h3>
<p>在测试模块中，可以用unittest进行测试。并生成相应的测试报告。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> page_object.login_page <span class="keyword">import</span> LoginPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestUnit</span>(<span class="params">LoginPage</span>):</span></span><br><span class="line">    <span class="comment"># 写测试流程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.open()</span><br><span class="line">        self.input_username(un)</span><br><span class="line">        self.input_password(pwd)</span><br><span class="line">        self.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    un = <span class="string">&#x27;carslan&#x27;</span></span><br><span class="line">    pwd = <span class="string">&#x27;666666&#x27;</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    lp = TestUnit(driver, LoginPage.url)</span><br><span class="line">    lp.login()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-todo-list"><a class="markdownIt-Anchor" href="#四-todo-list"></a> 四、Todo List</h2>
<ol>
<li>
<p>使用unittest重新整合TestUnit部分</p>
</li>
<li>
<p>加入流程异常捕捉断言测试。</p>
<p>在测试当中，正常流程的实现当然重要，但在编写脚本时，应该注意异常情况的捕捉反馈。</p>
</li>
<li>
<p>对自己的宠物论坛的注册、登陆、发帖编写自动化测试脚本，并生成相应的测试报告。</p>
</li>
</ol>
<h2 id="五-项目源代码下载"><a class="markdownIt-Anchor" href="#五-项目源代码下载"></a> 五、项目源代码下载</h2>
<p>进入<a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/AutoTest">AutoTest</a>文件夹下载POM_Get.zip文件。完成上面的todo后，整个项目将上传到<br />
Github中。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>About unittest</title>
    <url>/2020/12/04/About-unittest/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201204184242525.png" alt="image-20201204184242525" style="zoom:50%;" />
<a id="more"></a>
<h2 id="一-testfixture"><a class="markdownIt-Anchor" href="#一-testfixture"></a> 一、TestFixture</h2>
<p>该部分内容极为简单，不再赘述。</p>
<h2 id="二-testsuite"><a class="markdownIt-Anchor" href="#二-testsuite"></a> 二、TestSuite</h2>
<ul>
<li>作用：把测试用例组合到一起</li>
<li>TestSuite()是一个类，需要实例化使用。</li>
</ul>
<h3 id="1-addtest-逐个加载用例"><a class="markdownIt-Anchor" href="#1-addtest-逐个加载用例"></a> 1. addTest() 「逐个」加载用例</h3>
<p>格式：addTest(测试类名(‘测试用例’))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTest</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 测试用例1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试用例2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="comment"># 实例化TestSuite()</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTest(AllTest(<span class="string">&#x27;test_1&#x27;</span>))</span><br><span class="line">    suite.addTest(AllTest(<span class="string">&#x27;test_2&#x27;</span>))</span><br><span class="line">    unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(suite)</span><br></pre></td></tr></table></figure>
<h3 id="2-loadtestsformtestcase测试类名-loadtestsfrommodule模块名py"><a class="markdownIt-Anchor" href="#2-loadtestsformtestcase测试类名-loadtestsfrommodule模块名py"></a> 2. loadTestsFormTestCase(测试类名)、loadTestsFromModule(‘<a href="http://xn--eqr79ejvx.py">模块名.py</a>’)</h3>
<p>两个都是是继承<code>Testloader()</code>，只是前面是加载一个测试类，后者是加载模块名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suite=unittest.TestLoader().loadTestsFromTestCase(BaiduTest)</span><br><span class="line">suite=unittest.TestLoader().loadTestsFromModule(<span class="string">&#x27;unittest1.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-discover-批量加载用例"><a class="markdownIt-Anchor" href="#3-discover-批量加载用例"></a> 3. discover() 「批量」加载用例</h3>
<p>使用discover()，其实和使用addTest()是类似的，都是要实例化才能使用。</p>
<p>我们来看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suite = unittest.TestSuite().addTest(xxxx)</span><br><span class="line">discover = unittest.defaultTestLoader.discover(test_dir,pattern=<span class="string">&#x27;xxx&#x27;</span>,top_level_dir=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其实<code>addTest</code>()是<code>unittest</code> 的<code>TestSuite()</code>类下面的一个子类而已，同样的，<code>discover()</code>是<code>unitest</code>的<code>defaultTestLoder()</code>类下的字类，所以都是需要实例化的。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201204231834582.png" alt="image-20201204231834582" /></p>
<ul>
<li>start_dir ：要测试的模块名或测试用例目录。</li>
<li>pattern=‘test*.py’ ：表示用例文件名的匹配原则。星号“*”表示任意多个字符。</li>
<li>top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录中），默认为 None。</li>
</ul>
<h2 id="三-测试断言"><a class="markdownIt-Anchor" href="#三-测试断言"></a> 三、测试断言</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201204233159773.png" alt="image-20201204233159773" style="zoom:50%;" />
<p>一个测试用例只有两种结果，要么 Pass，要么 Fail（代码错误也显示 Fail）。因此，在自动化测试的测试用例中，切记不要使用 if else 这类判 断代码来代替断言。</p>
<p>另外，在自动化测试中尽量不要应用打印结果来判断测试 用例的情况，用例如，果在代码错误或者功能有 Bug 的情况下就让用例报错或 者失败，而不是结果显示 Pass，只有功能正常的测试用例结果才是 Pass 的。</p>
<h2 id="四-生成测试报告"><a class="markdownIt-Anchor" href="#四-生成测试报告"></a> 四、生成测试报告</h2>
<p>此处建议使用unittestreport，项目介绍：<a href="http://testingpai.com/article/1595507317340">http://testingpai.com/article/1595507317340</a></p>
<p>需要注意的是，使用pip install的方式安装后，要在PyCharm的Interpreter中添加。使用使用更佳方便，效果也更加美观。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207161245421.png" alt="image-20201207161245421" style="zoom:50%;" />
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino学习日志-电子元器件</title>
    <url>/2022/03/03/Arduino%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220301131415957.png" alt="image-20220301131415957" style="zoom: 40%;" />
<p>终于开始接触很感兴趣的Arduino！！！</p>
<p>目前要用到的是nano，拓展版厂家未知，所以先了解每个nano串口的作用，才能够彻底弄懂这个拓展板。</p>
<a id="more"></a>
<h2 id="一-nano和拓展版和连接"><a class="markdownIt-Anchor" href="#一-nano和拓展版和连接"></a> 一、nano和拓展版和连接</h2>
<blockquote>
<p>方向接错很容易烧坏</p>
</blockquote>
<p>nano的<code>D13</code>对拓展版的<code>D13</code>（拓展版的右上角）</p>
<h2 id="二-nano的针脚说明"><a class="markdownIt-Anchor" href="#二-nano的针脚说明"></a> 二、nano的针脚说明</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301133112794.png" alt="image-20220301133112794" style="zoom:50%;" />
<h3 id="系统功能针脚"><a class="markdownIt-Anchor" href="#系统功能针脚"></a> 系统功能针脚</h3>
<h4 id="1-tx-rx-12"><a class="markdownIt-Anchor" href="#1-tx-rx-12"></a> 1. TX、RX ｜(1)(2)</h4>
<p><code>TX、RX</code>是<strong>串口</strong>输入输出引脚。板上通过CH340芯片转为了USB信号，方便主机下载程序、通信用。 这两个脚尽量不做其它用途。–&gt; 作用：为了解决电脑没有串口的问题。</p>
<blockquote>
<p>说人话：因为目前多数是通过usb和电脑通信，但usb走的是<code>通用串行总线的协议</code>，而<code>TX、RX</code>是串口通信。也就是Arduino和电脑的通信协议方式不一样，所以Arduino为<strong>了解决电脑没有串口的问题</strong>，使用了usb转串口的适配器把usb数据转成串口，然后再接到arduino的tx和rx口。usb和rx、tx上的数据是一样的，只是使用的协议不一样而已。</p>
</blockquote>
<h4 id="2-reset-228"><a class="markdownIt-Anchor" href="#2-reset-228"></a> 2. RESET | (2)(28)</h4>
<p>RESET是复位键，在nano中间还有一个复位按钮，所以其实在nano上是有三个复位的口。</p>
<p>什么叫复位？作用是什么？简单说就是重启。当我们需要在重写刷写内容时，可以按下该键。这个一般会自动完成。但有时候会出现<strong>上传失败的错误</strong>，这个时候我们可以按下nano中心的reset键解决该问题。</p>
<h4 id="3-gnd429"><a class="markdownIt-Anchor" href="#3-gnd429"></a> 3. GND｜(4)(29)</h4>
<p>接地。信号、电源共用接地。</p>
<h4 id="4-vin30"><a class="markdownIt-Anchor" href="#4-vin30"></a> 4. VIN｜(30)</h4>
<p>外部电源。可以看到（13）是3.3v、（27）是5V的usb板载电源，当我们需要带动一些功率较大的电子器件时，需要外部电源。<strong>输入范围7～12v</strong></p>
<h3 id="复用接口针脚"><a class="markdownIt-Anchor" href="#复用接口针脚"></a> 复用接口针脚</h3>
<h4 id="1-d2-d13"><a class="markdownIt-Anchor" href="#1-d2-d13"></a> 1. D2-D13</h4>
<p>D代表Digital，数字信号。</p>
<p>数字信号<strong>输出时</strong>反馈给我们1/0的状态，对应高电平(5v)和低电平(0v)。</p>
<p>输入时电压由外部设备提供。该电压可以在0-5V之间变化，并转换成数字表示（0或1）。为了确定这一点，有2个阈值：低于0.8视为0，高于2视为1。如果电压在0.8～2之间，返回不确定。</p>
<p>**D3、D5、D6、D9、D10、D11 可以做PWM输出用。**PWM信号用于直流电机的速度控制，调光LED等。</p>
<h4 id="2-a0-a7"><a class="markdownIt-Anchor" href="#2-a0-a7"></a> 2. A0-A7</h4>
<p>A代表Analog，模拟信号。</p>
<p>生活中，接触到的大多数信号都是模拟信号，如声音、温度的变化等。模拟信号是用连续变化的物理量表示的信息，信号随时间作连续变化。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301142618580.png" alt="image-20220301142618580" style="zoom:50%;" />
<hr />
<p>最后，有arduino一些学习网站，不过基本都是基于uno的</p>
<blockquote>
<p>Arduino中文社区：<a href="https://www.arduino.cn/thread-75655-1-1.html">https://www.arduino.cn/thread-75655-1-1.html</a></p>
<p>菜鸟Arduino教程：<a href="http://www.log4cpp.com/Tutorials/">http://www.log4cpp.com/Tutorials/</a></p>
<p>丢石头：<a href="https://wiki.diustou.com/cn/ARDUINO_NANO">https://wiki.diustou.com/cn/ARDUINO_NANO</a></p>
</blockquote>
<h2 id="三-附件"><a class="markdownIt-Anchor" href="#三-附件"></a> 三、附件</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301150156408.png" alt="image-20220301150156408" style="zoom:50%;" />
<h3 id="1-按钮led"><a class="markdownIt-Anchor" href="#1-按钮led"></a> 1. 按钮+led</h3>
<p>我们先看⑤LED灯和⑦按钮的联合</p>
<p>⑤接在拓展板的D2，⑦在D3。</p>
<p>先在Mind+中使用实时模式，调试好代码后再使用上传模式，把程序传送到芯片中。但注意：两个模式是分开的。也就是每个区写好的代码都复制不了到另一个区。即使我们在实时模式下把程序保存下来，在上传模式中打开保存好的程序，仍然会自动跳回到实时模式。</p>
<p>程序：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301151656546.png" alt="image-20220301151656546" style="zoom: 33%;" />
<p>解释：</p>
<p>首先我们看到nano的引脚操作是有分<code>数字引脚</code> 和 <code>模拟引脚</code>，我们的开关和LED是通过1、0来控制的。所以程序中我们用尖头的数字引脚。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301151759338.png" alt="image-20220301151759338" style="zoom:50%;" />
<h3 id="2-光敏电阻声音模块led"><a class="markdownIt-Anchor" href="#2-光敏电阻声音模块led"></a> 2. 光敏电阻/声音模块+led</h3>
<p>光敏电阻：光线越强，电阻越低，电压越低。</p>
<p>接在A口：模拟口1-1023值对应的是0-5v。我们接在A口时，会有个值能够触发led灯亮，用图形化编程无法确定这个值多少。我们取中法测试一下，当模拟口的值&lt;500时，设置为低电平。如果使用代码编写是可以打印出当前的模拟值是多少的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220301160915532.png" alt="image-20220301160915532" style="zoom:50%;" />
<img src="../../../../Library/Application Support/typora-user-images/image-20220301221938159.png" alt="image-20220301221938159" style="zoom:60%;" />
<p>通过代码编写可以实现获得当前引脚的数值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Serial.begin(<span class="number">9600</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Serial.print(<span class="string">&quot;The ADC value is: &quot;</span>);</span><br><span class="line">  	Serial.println(analogRead(<span class="number">1</span>));</span><br><span class="line">  	delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以接在D口也可以实现led的亮灭。只是要非常黑，也就是阻值要非常大的时候才回触发led。</p>
<blockquote>
<p>DFRobot：<a href="https://mc.dfrobot.com.cn/thread-2505-1-1.html">https://mc.dfrobot.com.cn/thread-2505-1-1.html</a></p>
<p>其他博客：<a href="https://www.jianshu.com/p/a60b1673fea8">https://www.jianshu.com/p/a60b1673fea8</a></p>
</blockquote>
<h3 id="3-超声波"><a class="markdownIt-Anchor" href="#3-超声波"></a> 3. 超声波</h3>
<p>超声波模块上有4个引脚。只需特别注意两个：<code>Trig</code>和<code>Echo</code>。单片机给<code>trig</code>引脚发送10微秒的高电平，才能触发模块发射声波。<code>echo</code>用于接受返回的声波，如有返回，<code>echo</code>会输出高电平，高电平持续时间就是从发射到返回的时间。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220302084912055.png" alt="image-20220302084912055" style="zoom:50%;" />
<p>在该款拓展版中，<code>Trig</code>是对应<code>13引脚</code>，<code>Echo</code>对应<code>12引脚</code>。</p>
<p><code>Mind+</code>图形化编程：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220302114153653.png" alt="image-20220302114153653" style="zoom:50%;" />
<p>在开发平台「Arduino」中，设计一个探测距离的程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Trig = <span class="number">13</span>;                                           <span class="comment">// 设定SR04连接的Arduino引脚</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Echo = <span class="number">12</span>; </span><br><span class="line"><span class="keyword">double</span> distance,time ; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">        Serial.begin(<span class="number">9600</span>);                                    <span class="comment">// 初始化串口通信及连接SR04的引脚</span></span><br><span class="line">        pinMode(Trig, OUTPUT); </span><br><span class="line">  </span><br><span class="line">        pinMode(Echo, INPUT);                                  <span class="comment">//要检测引脚上输入的脉冲宽度，需要先设置为输入状态</span></span><br><span class="line">    Serial.println(<span class="string">&quot;The distance is :&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    </span><br><span class="line">        digitalWrite(Trig, LOW);                                 </span><br><span class="line">        delayMicroseconds(<span class="number">2</span>);                                   </span><br><span class="line">        digitalWrite(Trig, HIGH);                               </span><br><span class="line">        delayMicroseconds(<span class="number">10</span>);                                  <span class="comment">//产生一个10us的高脉冲去触发SR04</span></span><br><span class="line">        digitalWrite(Trig, LOW);                                </span><br><span class="line">        </span><br><span class="line">        time = pulseIn(Echo, HIGH);                              <span class="comment">// 检测脉冲宽度，注意返回值是微秒us</span></span><br><span class="line">        distance = time /<span class="number">58</span> ;                                  <span class="comment">//计算出距离,输出的距离的单位是厘米cm</span></span><br><span class="line"> </span><br><span class="line">        Serial.print(distance);                                <span class="comment">//把得到的距离值通过串口通信返回给电脑，通过串口监视器显示出来</span></span><br><span class="line">        Serial.println(<span class="string">&quot;cm&quot;</span>); </span><br><span class="line">        delay(<span class="number">1000</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-180度舵机"><a class="markdownIt-Anchor" href="#4-180度舵机"></a> 4. 180度舵机</h3>
<p>注意：橙色为信号线。接的是数字D口。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220302120742118.png" alt="image-20220302120742118" style="zoom:50%;" />
<h3 id="5-电机驱动版"><a class="markdownIt-Anchor" href="#5-电机驱动版"></a> 5. 电机驱动版</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20220302121932497.png" alt="image-20220302121932497" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20220302122138122.png" alt="image-20220302122138122" style="zoom:50%;" />
<p>只有输出端两个口，<strong>一个高电平一个低电平组合</strong>，才会让机器转动。这个绿板注意第三点就行。一般用于mcirobit、掌控板、esp32。</p>
<h3 id="6-红外避障传感器"><a class="markdownIt-Anchor" href="#6-红外避障传感器"></a> 6. 红外避障传感器</h3>
<p>也就是上图中的6。当遇到障碍物时，低电平触发。</p>
<blockquote>
<p>相关详细说明、例子：<a href="https://www.arduino.cn/thread-89473-2-1.html">https://www.arduino.cn/thread-89473-2-1.html</a></p>
</blockquote>
<h3 id="7-倾斜开关"><a class="markdownIt-Anchor" href="#7-倾斜开关"></a> 7. 倾斜开关</h3>
<p>关闭：高电平；打开：低电平</p>
<h2 id="四-串口监控"><a class="markdownIt-Anchor" href="#四-串口监控"></a> 四、串口监控</h2>
<p>Mind+的串口监控</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220302114415281.png" alt="image-20220302114415281" /></p>
<hr />
<p>学习文档：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1kl5SkgCXUjOVF9U4ORW-Yg">https://pan.baidu.com/s/1kl5SkgCXUjOVF9U4ORW-Yg</a></p>
</blockquote>
<hr />
<p>最后，下面的例子写得非常清晰：</p>
<p>一块扩展板完成Arduino的10类37项实验（代码+图形+仿真）<br />
<a href="https://www.arduino.cn/thread-88696-1-1.html">https://www.arduino.cn/thread-88696-1-1.html</a><br />
连杆形式的腿机构十一种：盘点机器人行走背后的机械原理<br />
<a href="https://www.arduino.cn/thread-102573-1-1.html">https://www.arduino.cn/thread-102573-1-1.html</a><br />
【花雕动手做】超低成本，尝试五十元的麦克纳姆轮小车！<br />
<a href="https://www.arduino.cn/thread-102274-1-1.html">https://www.arduino.cn/thread-102274-1-1.html</a><br />
【花雕动手做】超迷你哦，用徽商香烟盒做个智能小车！<br />
<a href="https://www.arduino.cn/thread-102351-1-1.html">https://www.arduino.cn/thread-102351-1-1.html</a><br />
【花雕动手做】太搞笑啦，一支胶管制成二只蠕动机器人<br />
<a href="https://www.arduino.cn/thread-102506-1-1.html">https://www.arduino.cn/thread-102506-1-1.html</a><br />
【花雕动手做】快餐盒盖，极低成本搭建机器人实验平台<br />
<a href="https://www.arduino.cn/thread-102535-1-1.html">https://www.arduino.cn/thread-102535-1-1.html</a><br />
【花雕动手做】OTTO 机器人—体验DIY的乐趣<br />
<a href="https://www.arduino.cn/thread-101976-1-1.html">https://www.arduino.cn/thread-101976-1-1.html</a></p>
<p>实验一：干簧管传感器模块<br />
<a href="https://www.arduino.cn/thread-86350-1-1.html">https://www.arduino.cn/thread-86350-1-1.html</a><br />
实验二：光敏电阻传感器模块<br />
<a href="https://www.arduino.cn/thread-86393-1-1.html">https://www.arduino.cn/thread-86393-1-1.html</a><br />
实验三：微波雷达感应开关模块<br />
<a href="https://www.arduino.cn/thread-86397-1-1.html">https://www.arduino.cn/thread-86397-1-1.html</a><br />
实验四：振动传感器模块<br />
<a href="https://www.arduino.cn/thread-86512-1-1.html">https://www.arduino.cn/thread-86512-1-1.html</a><br />
实验五：热敏电阻温度传感器模块<br />
<a href="https://www.arduino.cn/thread-86520-1-1.html">https://www.arduino.cn/thread-86520-1-1.html</a><br />
实验六：KY-038高感度声音传感器模块<br />
<a href="https://www.arduino.cn/thread-86576-1-1.html">https://www.arduino.cn/thread-86576-1-1.html</a><br />
实验七：旋转电位器模块<br />
<a href="https://www.arduino.cn/thread-86866-1-1.html">https://www.arduino.cn/thread-86866-1-1.html</a><br />
实验八：湿度传感器模块<br />
<a href="https://www.arduino.cn/thread-87993-1-1.html">https://www.arduino.cn/thread-87993-1-1.html</a><br />
实验九：火焰（红外线）传感器模块<br />
<a href="https://www.arduino.cn/thread-88283-1-1.html">https://www.arduino.cn/thread-88283-1-1.html</a><br />
实验十：敲击传感器模块KY-031<br />
<a href="https://www.arduino.cn/thread-88401-1-1.html">https://www.arduino.cn/thread-88401-1-1.html</a><br />
实验十一：金属触摸传感器模块KY-36<br />
<a href="https://www.arduino.cn/thread-88422-1-1.html">https://www.arduino.cn/thread-88422-1-1.html</a><br />
实验十二：开关霍尔磁力传感器模块<br />
<a href="https://www.arduino.cn/thread-88461-1-1.html">https://www.arduino.cn/thread-88461-1-1.html</a><br />
实验十三：触摸传感器模块<br />
<a href="https://www.arduino.cn/thread-88523-1-1.html">https://www.arduino.cn/thread-88523-1-1.html</a><br />
实验十四：倾斜传感器模块（角度开关）<br />
<a href="https://www.arduino.cn/thread-88530-1-1.html">https://www.arduino.cn/thread-88530-1-1.html</a><br />
实验十五：手指侦测心跳传感器模块KY-039<br />
<a href="https://www.arduino.cn/thread-88557-1-1.html">https://www.arduino.cn/thread-88557-1-1.html</a><br />
实验十六：电容式数字触摸传感器模块（TTP223 ）<br />
<a href="https://www.arduino.cn/thread-88567-1-1.html">https://www.arduino.cn/thread-88567-1-1.html</a><br />
实验十七：HC-SR312微型热释电传感器模块<br />
<a href="https://www.arduino.cn/thread-88578-1-1.html">https://www.arduino.cn/thread-88578-1-1.html</a><br />
实验十八：0.25W太阳能滴胶板传感器模块（45X45毫米）<br />
<a href="https://www.arduino.cn/thread-88669-1-1.html">https://www.arduino.cn/thread-88669-1-1.html</a><br />
实验十九：常闭型SW-420震动开关传感器模块<br />
<a href="https://www.arduino.cn/thread-88672-1-1.html">https://www.arduino.cn/thread-88672-1-1.html</a><br />
实验二十：水银开关传感器模块（KY-017）<br />
<a href="https://www.arduino.cn/thread-88787-1-1.html">https://www.arduino.cn/thread-88787-1-1.html</a><br />
实验二十一：激光头传感器模块（KY-008）<br />
<a href="https://www.arduino.cn/thread-88842-1-1.html">https://www.arduino.cn/thread-88842-1-1.html</a><br />
实验二十二：MAX7219点阵显示模块（8X8 LED共阴）<br />
<a href="https://www.arduino.cn/thread-88851-1-1.html">https://www.arduino.cn/thread-88851-1-1.html</a><br />
实验二十三：NE555频率可调脉冲发生器模块（方波简版）<br />
<a href="https://www.arduino.cn/thread-88867-1-1.html">https://www.arduino.cn/thread-88867-1-1.html</a><br />
实验二十四：水位水滴传感器模块（Water Sensor）<br />
<a href="https://www.arduino.cn/thread-88886-1-1.html">https://www.arduino.cn/thread-88886-1-1.html</a><br />
实验二十五：MQ-2气敏式烟雾传感器模块（甲烷等）<br />
<a href="https://www.arduino.cn/thread-88906-1-1.html">https://www.arduino.cn/thread-88906-1-1.html</a><br />
实验二十六：4X4矩阵键盘模块（轻触式按键）<br />
<a href="https://www.arduino.cn/thread-88966-1-1.html">https://www.arduino.cn/thread-88966-1-1.html</a><br />
实验二十七：GY-BMP280-3.3 高精度大气压强传感器模块<br />
<a href="https://www.arduino.cn/thread-89010-1-1.html">https://www.arduino.cn/thread-89010-1-1.html</a><br />
实验二十八：三色5050 RGB全彩LED模块 KY-009<br />
<a href="https://www.arduino.cn/thread-89022-1-1.html">https://www.arduino.cn/thread-89022-1-1.html</a><br />
实验二十九：DS1302实时时钟模块（带电池 掉电走时）<br />
<a href="https://www.arduino.cn/thread-89070-1-1.html">https://www.arduino.cn/thread-89070-1-1.html</a><br />
实验三十：光敏二极管传感器模块（英语photodiode ）<br />
<a href="https://www.arduino.cn/thread-89129-1-1.html">https://www.arduino.cn/thread-89129-1-1.html</a><br />
实验三十一：ISD1820录音语音模块（8-20秒）<br />
<a href="https://www.arduino.cn/thread-89154-1-1.html">https://www.arduino.cn/thread-89154-1-1.html</a><br />
实验三十二：雨滴传感器模块（雨水/雨量/叶面湿度）<br />
<a href="https://www.arduino.cn/thread-89184-1-1.html">https://www.arduino.cn/thread-89184-1-1.html</a><br />
实验三十三：ESP8266串口WIFI收发无线模块 （ESP-01S）<br />
<a href="https://www.arduino.cn/thread-89245-1-1.html">https://www.arduino.cn/thread-89245-1-1.html</a><br />
实验三十四：三色LED交通灯模块（红绿黄灯）<br />
<a href="https://www.arduino.cn/thread-89273-1-1.html">https://www.arduino.cn/thread-89273-1-1.html</a><br />
实验三十五：模拟量声音传感器模块（4线制）<br />
<a href="https://www.arduino.cn/thread-89289-1-1.html">https://www.arduino.cn/thread-89289-1-1.html</a><br />
实验三十六：WS2812B智能外控集成LED四位彩灯模块<br />
<a href="https://www.arduino.cn/thread-89297-1-1.html">https://www.arduino.cn/thread-89297-1-1.html</a><br />
实验三十七：MQ-3酒精乙醇传感器模块<br />
<a href="https://www.arduino.cn/thread-89300-1-1.html">https://www.arduino.cn/thread-89300-1-1.html</a><br />
实验三十八：joystick双轴XY按键摇杆模块（游戏控制杆)<br />
<a href="https://www.arduino.cn/thread-89365-1-1.html">https://www.arduino.cn/thread-89365-1-1.html</a><br />
实验三十九：DS18B20单总线数字温度传感器模块<br />
<a href="https://www.arduino.cn/thread-89368-1-1.html">https://www.arduino.cn/thread-89368-1-1.html</a><br />
实验四十：360度旋转增量编码器模块（KY-040）<br />
<a href="https://www.arduino.cn/thread-89427-1-1.html">https://www.arduino.cn/thread-89427-1-1.html</a><br />
实验四十一：IS0203激光接收管传感器模块<br />
<a href="https://www.arduino.cn/thread-89428-1-1.html">https://www.arduino.cn/thread-89428-1-1.html</a><br />
实验四十二：DSM501A韩国PM2.5灰尘粉尘传感器模块<br />
<a href="https://www.arduino.cn/thread-89441-1-1.html">https://www.arduino.cn/thread-89441-1-1.html</a><br />
实验四十三：5V低电平触发单路继电器模块<br />
<a href="https://www.arduino.cn/thread-89445-1-1.html">https://www.arduino.cn/thread-89445-1-1.html</a><br />
实验四十四：类比霍尔磁性传感器 KY-035（模拟量）<br />
<a href="https://www.arduino.cn/thread-89464-1-1.html">https://www.arduino.cn/thread-89464-1-1.html</a><br />
实验四十五：红外避障传感器模块（光电接近开关）<br />
<a href="https://www.arduino.cn/thread-89473-1-1.html">https://www.arduino.cn/thread-89473-1-1.html</a><br />
实验四十六：350Ω高精度电阻式应变片传感器 (BF350)<br />
<a href="https://www.arduino.cn/thread-89474-1-1.html">https://www.arduino.cn/thread-89474-1-1.html</a><br />
实验四十七：七段LED数码管模块（共阴/共阳）<br />
<a href="https://www.arduino.cn/thread-89475-1-1.html">https://www.arduino.cn/thread-89475-1-1.html</a><br />
实验四十八：GY-291三轴重力加速度模块 （IIC/SPI传输）<br />
<a href="https://www.arduino.cn/thread-89567-1-2.html">https://www.arduino.cn/thread-89567-1-2.html</a><br />
实验四十九：有源蜂鸣器报警器发声模块（低电平触发）<br />
<a href="https://www.arduino.cn/thread-89568-1-2.html">https://www.arduino.cn/thread-89568-1-2.html</a><br />
实验五十：W25Q64 FLASH外扩存储模块 （SPI接口 ）<br />
<a href="https://www.arduino.cn/thread-89570-1-2.html">https://www.arduino.cn/thread-89570-1-2.html</a><br />
实验五十一：自锁点动触摸按键传感器模块（TTP223芯片）<br />
<a href="https://www.arduino.cn/thread-89721-1-1.html">https://www.arduino.cn/thread-89721-1-1.html</a><br />
实验五十二：SPI接口Micro SD卡模块（带电平转换芯片)<br />
<a href="https://www.arduino.cn/thread-89729-1-1.html">https://www.arduino.cn/thread-89729-1-1.html</a><br />
实验五十三： 土壤湿度水分传感器模块（电阻式）<br />
<a href="https://www.arduino.cn/thread-89734-1-1.html">https://www.arduino.cn/thread-89734-1-1.html</a><br />
实验五十四： 大按键点动轻触开关模块（高电平输出）<br />
<a href="https://www.arduino.cn/thread-89785-1-1.html">https://www.arduino.cn/thread-89785-1-1.html</a><br />
实验五十五：DHT11 温湿度传感器（数字型单总线通信）<br />
<a href="https://www.arduino.cn/thread-89786-1-1.html">https://www.arduino.cn/thread-89786-1-1.html</a><br />
实验五十六： 8路LED流水的灯跑马灯模块SUNLEPHANT<br />
<a href="https://www.arduino.cn/thread-89832-1-1.html">https://www.arduino.cn/thread-89832-1-1.html</a><br />
实验五十七： 四档频率占空比可调矩形波信号发生器（NE555）<br />
<a href="https://www.arduino.cn/thread-89868-1-1.html">https://www.arduino.cn/thread-89868-1-1.html</a><br />
实验五十八： HC-SR04超声波测距传感器模块（通用款）<br />
<a href="https://www.arduino.cn/thread-89869-1-1.html">https://www.arduino.cn/thread-89869-1-1.html</a><br />
实验五十九： RS232转TTL2代串口模块刷机板（MAX3232）<br />
<a href="https://www.arduino.cn/thread-89895-1-1.html">https://www.arduino.cn/thread-89895-1-1.html</a><br />
实验六十：ATTINY85 Digispark kickstarter 微型usb开发板<br />
<a href="https://www.arduino.cn/thread-89898-1-1.html">https://www.arduino.cn/thread-89898-1-1.html</a><br />
实验六十一： 直条8位 WS2812B 5050 RGB LED全彩模块<br />
<a href="https://www.arduino.cn/thread-90147-1-1.html">https://www.arduino.cn/thread-90147-1-1.html</a><br />
实验六十二：电压检测模块 Voltage Sensor 电压传感器<br />
<a href="https://www.arduino.cn/thread-90149-1-1.html">https://www.arduino.cn/thread-90149-1-1.html</a><br />
实验六十三： 1排4键薄膜开关 Arduino扩展键盘模块控制面板<br />
<a href="https://www.arduino.cn/thread-90150-1-1.html">https://www.arduino.cn/thread-90150-1-1.html</a><br />
实验六十四： TCS3200D颜色识别传感器（可编程彩色光频模块）<br />
<a href="https://www.arduino.cn/thread-90168-1-1.html">https://www.arduino.cn/thread-90168-1-1.html</a><br />
实验六十五： 5MM三色RGB全彩LED模块颜色传感器KY-016<br />
<a href="https://www.arduino.cn/thread-90400-1-1.html">https://www.arduino.cn/thread-90400-1-1.html</a><br />
实验六十六： TCRT5000红外反射光电开关寻迹传感器模块<br />
<a href="https://www.arduino.cn/thread-90402-1-1.html">https://www.arduino.cn/thread-90402-1-1.html</a><br />
实验六十七：HC-SR501 热释电人体红外感应传感器模块<br />
<a href="https://www.arduino.cn/thread-90404-1-1.html">https://www.arduino.cn/thread-90404-1-1.html</a><br />
实验六十八： GY-68 BMP180 新款 BOSCH温度模块气压传感器<br />
<a href="https://www.arduino.cn/thread-90411-1-1.html">https://www.arduino.cn/thread-90411-1-1.html</a><br />
实验六十九： AT24C256 I2C接口 EEPROM 存储模块 IIC<br />
<a href="https://www.arduino.cn/thread-90412-1-1.html">https://www.arduino.cn/thread-90412-1-1.html</a><br />
实验七十： GY-30 数字光强度传感器模块（BH1750FVI芯片）<br />
<a href="https://www.arduino.cn/thread-90413-1-1.html">https://www.arduino.cn/thread-90413-1-1.html</a><br />
实验七十一：电容式土壤湿度传感器模块（TL555I）<br />
<a href="https://www.arduino.cn/thread-90471-1-1.html">https://www.arduino.cn/thread-90471-1-1.html</a><br />
实验七十二：HX1838红外无线遥控套件红外扩展模块(遥控器+接收板)<br />
<a href="https://www.arduino.cn/thread-90473-1-1.html">https://www.arduino.cn/thread-90473-1-1.html</a><br />
实验七十三：人体秤50kg称重传感器模块（电阻应变半桥式）<br />
<a href="https://www.arduino.cn/thread-90545-1-1.html">https://www.arduino.cn/thread-90545-1-1.html</a><br />
实验七十四：4位LED数码管显示模块0.36英寸亮度可调带时钟点（ TM1637）<br />
<a href="https://www.arduino.cn/thread-90546-1-1.html">https://www.arduino.cn/thread-90546-1-1.html</a><br />
实验七十五： GY-NEO-6MV2新款飞控GPS模块 （带大天线）<br />
<a href="https://www.arduino.cn/thread-90547-1-1.html">https://www.arduino.cn/thread-90547-1-1.html</a><br />
实验七十六：TTL转RS-485模块 MAX485 RS485模块<br />
<a href="https://www.arduino.cn/thread-90549-1-1.html">https://www.arduino.cn/thread-90549-1-1.html</a><br />
实验七十七： 2路继电器模块 带光耦保护Arduino扩展板<br />
<a href="https://www.arduino.cn/thread-90557-1-1.html">https://www.arduino.cn/thread-90557-1-1.html</a><br />
实验七十八： LGT8F328P LQFP32 MiniEVB开发板（替代NANO V3.0 ）<br />
<a href="https://www.arduino.cn/thread-90724-1-1.html">https://www.arduino.cn/thread-90724-1-1.html</a><br />
实验七十九： 模拟灰度传感器 （反射式光电模块）<br />
<a href="https://www.arduino.cn/thread-90725-1-1.html">https://www.arduino.cn/thread-90725-1-1.html</a><br />
实验八十： ov7670摄像头模块30W采集拍照模组（替OV7725）<br />
<a href="https://www.arduino.cn/thread-90726-1-1.html">https://www.arduino.cn/thread-90726-1-1.html</a><br />
实验八十一：槽型光耦对射光电开关模块（红外计数测速传感器）<br />
<a href="https://www.arduino.cn/thread-90833-1-1.html">https://www.arduino.cn/thread-90833-1-1.html</a><br />
实验八十二： MQ135空气质量检测传感器模块（有害物体 氨气 硫化物检测)<br />
<a href="https://www.arduino.cn/thread-90834-1-1.html">https://www.arduino.cn/thread-90834-1-1.html</a><br />
实验八十三： 4路TTP224电容式触摸模块 人体数字触摸传感器<br />
<a href="https://www.arduino.cn/thread-90835-1-1.html">https://www.arduino.cn/thread-90835-1-1.html</a><br />
实验八十四： 8位LED数码管MAX7219模块（支持级联八位串行3个IO口控制）<br />
<a href="https://www.arduino.cn/thread-90864-1-1.html">https://www.arduino.cn/thread-90864-1-1.html</a><br />
实验八十五：开源 Mini MP3 Player SD卡播放器模块（YX5200-24SS）<br />
<a href="https://www.arduino.cn/thread-90865-1-1.html">https://www.arduino.cn/thread-90865-1-1.html</a><br />
实验八十六： 180度SG90舵机模块（模拟9G）<br />
<a href="https://www.arduino.cn/thread-91033-1-1.html">https://www.arduino.cn/thread-91033-1-1.html</a><br />
实验八十七： DS1307时钟模块 Tiny RTC I2C模块 24C32存储器 时钟(带电池）<br />
<a href="https://www.arduino.cn/thread-91034-1-1.html">https://www.arduino.cn/thread-91034-1-1.html</a><br />
实验八十八： LCD1602液晶屏5V显示模块<br />
<a href="https://www.arduino.cn/thread-91047-1-1.html">https://www.arduino.cn/thread-91047-1-1.html</a><br />
实验八十九： WS2812B-4<em>4位 RGB LED 全彩驱动16位彩灯开发板模块<br />
<a href="https://www.arduino.cn/thread-91048-1-1.html">https://www.arduino.cn/thread-91048-1-1.html</a><br />
实验九十：步进电机+ULN2003驱动板 4相 5线 5V步进电机模组<br />
<a href="https://www.arduino.cn/thread-91049-1-1.html">https://www.arduino.cn/thread-91049-1-1.html</a><br />
实验九十一： 1号霍尔水流量传感器咖啡机直饮机流量监控模块<br />
<a href="https://www.arduino.cn/thread-91241-1-1.html">https://www.arduino.cn/thread-91241-1-1.html</a><br />
实验九十二：8位 5V-3V IIC UART SPI TTL双向电平转换模块<br />
<a href="https://www.arduino.cn/thread-91242-1-1.html">https://www.arduino.cn/thread-91242-1-1.html</a><br />
实验九十三： CSR8350 蓝牙V4.1立体声音乐模块（带功放）<br />
<a href="https://www.arduino.cn/thread-91243-1-1.html">https://www.arduino.cn/thread-91243-1-1.html</a><br />
实验九十四： 4X4矩阵形薄膜键盘模块轻触开关模组<br />
<a href="https://www.arduino.cn/thread-91244-1-1.html">https://www.arduino.cn/thread-91244-1-1.html</a><br />
实验九十五：XD-58C pulsesensor光学心率脉搏生物模拟传感器<br />
<a href="https://www.arduino.cn/thread-91245-1-1.html">https://www.arduino.cn/thread-91245-1-1.html</a><br />
实验九十六： 433M无线发射接收模块 超再生防盗报警无线模组<br />
<a href="https://www.arduino.cn/thread-91247-1-1.html">https://www.arduino.cn/thread-91247-1-1.html</a><br />
实验九十七： 0.96寸I2C IIC通信128</em>64显示器 OLED液晶屏模块<br />
<a href="https://www.arduino.cn/thread-91514-1-1.html">https://www.arduino.cn/thread-91514-1-1.html</a><br />
实验九十八： L298N电机驱动板模块直流步进电机智能机器人小车模组<br />
<a href="https://www.arduino.cn/thread-91515-1-1.html">https://www.arduino.cn/thread-91515-1-1.html</a><br />
实验九十九： APDS-9960 GY-9960-3.3 RGB红外手势传感器 方向识别模块<br />
<a href="https://www.arduino.cn/thread-91516-1-1.html">https://www.arduino.cn/thread-91516-1-1.html</a><br />
实验一百： AT-09蓝牙4.0BLE 模块 串口引出 CC2541兼容HM-10模块<br />
<a href="https://www.arduino.cn/thread-91517-1-1.html">https://www.arduino.cn/thread-91517-1-1.html</a><br />
实验一百零一： 10段LED发光条MT102510AG数码显示光柱模块<br />
<a href="https://www.arduino.cn/thread-91518-1-1.html">https://www.arduino.cn/thread-91518-1-1.html</a><br />
实验一百零二：MFRC-522 RC522 RFID射频 IC卡感应模块读卡器S50复旦卡模组<br />
<a href="https://www.arduino.cn/thread-91519-1-1.html">https://www.arduino.cn/thread-91519-1-1.html</a><br />
实验一百零三： 8X32 LED点阵显示模块 MAX7219 输出 共阴 5V 模组<br />
<a href="https://www.arduino.cn/thread-91520-1-1.html">https://www.arduino.cn/thread-91520-1-1.html</a><br />
实验一百零四： MAX30102血氧仪手腕心率脉搏检测心跳传感器模块<br />
<a href="https://www.arduino.cn/thread-91521-1-1.html">https://www.arduino.cn/thread-91521-1-1.html</a><br />
实验一百零五：12位 WS2812 5050 RGB LED 智能全彩RGB环开发板大环<br />
<a href="https://www.arduino.cn/thread-91522-1-1.html">https://www.arduino.cn/thread-91522-1-1.html</a><br />
实验一百零六： TM1638按键数码管LED显示模组8位数码管\LED\按键智控模块<br />
<a href="https://www.arduino.cn/thread-91523-1-1.html">https://www.arduino.cn/thread-91523-1-1.html</a><br />
实验一百零七： 315MHz 四路无线遥控M4非锁接收板 配四键无线遥控器模组<br />
<a href="https://www.arduino.cn/thread-91524-1-1.html">https://www.arduino.cn/thread-91524-1-1.html</a><br />
实验一百零八： 16X16点阵LED汉字显示屏模块UART接口<br />
<a href="https://www.arduino.cn/thread-91526-1-1.html">https://www.arduino.cn/thread-91526-1-1.html</a><br />
实验一百零九：模拟量 压电陶瓷振动发电传感器 压电单片机模块 3PIN<br />
<a href="https://www.arduino.cn/thread-91827-1-3.html">https://www.arduino.cn/thread-91827-1-3.html</a><br />
实验一百一十：US-026超声波测距传感器模块 代替HC-SR04 工业级 3V~5.5V<br />
<a href="https://www.arduino.cn/thread-91829-1-1.html">https://www.arduino.cn/thread-91829-1-1.html</a><br />
实验一百一十一： IIC/I2C/接口 PCF8574 扩展板 LCD1602/LCD2004转接板模块<br />
<a href="https://www.arduino.cn/thread-91830-1-1.html">https://www.arduino.cn/thread-91830-1-1.html</a><br />
实验一百一十二： MPU-6050模块 三轴加速度 电子陀螺仪6DOF GY-521传感器<br />
<a href="https://www.arduino.cn/thread-91832-1-1.html">https://www.arduino.cn/thread-91832-1-1.html</a><br />
实验一百一十三： 电源模块3.3V 5V 12V多路输出 DC-DC电压转换模块<br />
<a href="https://www.arduino.cn/thread-91834-1-1.html">https://www.arduino.cn/thread-91834-1-1.html</a><br />
实验一百一十四： JDY-31蓝牙转串口适配器SPP模块组无线透传 替换HC-05/06从机<br />
<a href="https://www.arduino.cn/thread-91835-1-1.html">https://www.arduino.cn/thread-91835-1-1.html</a><br />
实验一百一十五： 震动马达模块 高低电平振动小电机 智能可穿戴式产品震动提醒模块<br />
<a href="https://www.arduino.cn/thread-91836-1-1.html">https://www.arduino.cn/thread-91836-1-1.html</a><br />
实验一百一十六：NRF24L01+ 无线模块 功率加强版 2.4G无线收发通信模块 黑金刚<br />
<a href="https://www.arduino.cn/thread-91837-1-1.html">https://www.arduino.cn/thread-91837-1-1.html</a><br />
实验一百一十七：蓝色诺基亚5110屏 LCD液晶屏模块 兼容3310 LCD<br />
<a href="https://www.arduino.cn/thread-91838-1-1.html">https://www.arduino.cn/thread-91838-1-1.html</a><br />
实验一百一十八：US-015 高分辨超声波测距模块 超声波传感器 US-020升级版<br />
<a href="https://www.arduino.cn/thread-91839-1-1.html">https://www.arduino.cn/thread-91839-1-1.html</a><br />
实验一百一十九：HB100微波雷达感应模块 10.525GHz多普勒探测器探头传感器<br />
<a href="https://www.arduino.cn/thread-91840-1-1.html">https://www.arduino.cn/thread-91840-1-1.html</a><br />
实验一百二十： SIM800L GPRS 转接板GSM模块 microSIM卡带天线4频通讯模块<br />
<a href="https://www.arduino.cn/thread-91841-1-1.html">https://www.arduino.cn/thread-91841-1-1.html</a><br />
实验一百二十一：五向导航按键模块 5D摇杆 单片机 独立键盘开关 按钮 Your Cee<br />
<a href="https://www.arduino.cn/thread-91842-1-1.html">https://www.arduino.cn/thread-91842-1-1.html</a><br />
实验一百二十二： BBC microbit micro:bit，bit go,bit club python图形编程开发板<br />
<a href="https://www.arduino.cn/thread-91888-1-1.html">https://www.arduino.cn/thread-91888-1-1.html</a><br />
实验一百二十三： P10单红V706模组 32<em>16单元板LED显示屏<br />
<a href="https://www.arduino.cn/thread-91889-1-1.html">https://www.arduino.cn/thread-91889-1-1.html</a><br />
实验一百二十四： PS2鼠标 键盘插座接口 PS2模块<br />
<a href="https://www.arduino.cn/thread-91893-1-1.html">https://www.arduino.cn/thread-91893-1-1.html</a><br />
实验一百二十五： 升级版 WeMos D1 R2 WiFi UNO 开发板 基于ESP8266<br />
<a href="https://www.arduino.cn/thread-92178-1-1.html">https://www.arduino.cn/thread-92178-1-1.html</a><br />
实验一百二十六：JQ6500语音模块 MP3模块 MCU串口控制播报一对一5路控制<br />
<a href="https://www.arduino.cn/thread-92179-1-1.html">https://www.arduino.cn/thread-92179-1-1.html</a><br />
实验一百二十七：JoyStick Shield PS2游戏摇杆扩展板 模拟键盘鼠标功能 大摇杆<br />
<a href="https://www.arduino.cn/thread-92180-1-1.html">https://www.arduino.cn/thread-92180-1-1.html</a><br />
实验一百二十八：日本夏普SHARP PM2.5 灰尘/粉尘传感器 GP2Y1014AU0F 带线<br />
<a href="https://www.arduino.cn/thread-92181-1-1.html">https://www.arduino.cn/thread-92181-1-1.html</a><br />
实验一百二十九：GY-302 数字量光强度检测 光照传感器 BH1750FVI 光线检测模块<br />
<a href="https://www.arduino.cn/thread-92182-1-1.html">https://www.arduino.cn/thread-92182-1-1.html</a><br />
实验一百三十：Multi-function Shield多功能扩展板（12合1版）<br />
<a href="https://www.arduino.cn/thread-92184-1-1.html">https://www.arduino.cn/thread-92184-1-1.html</a><br />
实验一百三十一：24位 WS2812 5050 RGB LED 内置全彩驱动彩灯 圆形开发板<br />
<a href="https://www.arduino.cn/thread-92185-1-1.html">https://www.arduino.cn/thread-92185-1-1.html</a><br />
实验一百三十二：WT588D语音模块 可反复擦写语音下载16P-16M 蓝板HW-708<br />
<a href="https://www.arduino.cn/thread-92186-1-1.html">https://www.arduino.cn/thread-92186-1-1.html</a><br />
实验一百三十三：夏普GP2Y0A02YK0F 红外测距传感器模块 20-150cm 距离传感器<br />
<a href="https://www.arduino.cn/thread-92187-1-1.html">https://www.arduino.cn/thread-92187-1-1.html</a><br />
实验一百三十四：2004A液晶屏 字符显示模块LCD/LCM 蓝屏5V（带背光 IIC/I2C）<br />
<a href="https://www.arduino.cn/thread-92188-1-1.html">https://www.arduino.cn/thread-92188-1-1.html</a><br />
实验一百三十五：ESP8266机智云开发板 ESP12F wifi模块（云端智能硬件套件）<br />
<a href="https://www.arduino.cn/thread-92189-1-1.html">https://www.arduino.cn/thread-92189-1-1.html</a><br />
实验一百三十六：IIC I2C电平转换模块 5-3v系统兼容 2路 传感器模块SUNLEPHANT<br />
<a href="https://www.arduino.cn/thread-92403-1-1.html">https://www.arduino.cn/thread-92403-1-1.html</a><br />
实验一百三十七：中文TTS文字转语音合成模块 替代SYN6288和XFS5152<br />
<a href="https://www.arduino.cn/thread-92404-1-1.html">https://www.arduino.cn/thread-92404-1-1.html</a><br />
实验一百三十八：电流互感器模块 5A量程 单相 交流电流传感器模块<br />
<a href="https://www.arduino.cn/thread-92405-1-1.html">https://www.arduino.cn/thread-92405-1-1.html</a><br />
实验一百三十九：YL-004老款20按键独立键盘 跑马灯矩阵键盘模块<br />
<a href="https://www.arduino.cn/thread-92406-1-1.html">https://www.arduino.cn/thread-92406-1-1.html</a><br />
实验一百四十：KY-027 魔术光杯 for UNO 魔术光环模块<br />
<a href="https://www.arduino.cn/thread-92407-1-1.html">https://www.arduino.cn/thread-92407-1-1.html</a><br />
实验一百四十一：LCD1602 字符液晶屏 输入输出扩展板 LCD Keypad Shield<br />
<a href="https://www.arduino.cn/thread-92408-1-1.html">https://www.arduino.cn/thread-92408-1-1.html</a><br />
实验一百四十二：I2C接口I/O扩展模块 支持级联PCF8574T模块<br />
<a href="https://www.arduino.cn/thread-92409-1-1.html">https://www.arduino.cn/thread-92409-1-1.html</a><br />
实验一百四十三：Ethernet W5100 网络扩展板 SD卡扩展模块 支持MEGA<br />
<a href="https://www.arduino.cn/thread-92410-1-1.html">https://www.arduino.cn/thread-92410-1-1.html</a><br />
实验一百四十四：0.91寸OLED液晶屏显示模块 IIC 12832液晶屏 兼容3.3v-5V<br />
<a href="https://www.arduino.cn/thread-92411-1-1.html">https://www.arduino.cn/thread-92411-1-1.html</a><br />
实验一百四十五：MT8870 DTMF语音解码板模块 电话拨号控制音频解码处理电路<br />
<a href="https://www.arduino.cn/thread-92412-1-1.html">https://www.arduino.cn/thread-92412-1-1.html</a><br />
实验一百四十六：64位 WS2812B8</em>8 xRGB 5050 LED模块 ws2812s像素点阵屏<br />
<a href="https://www.arduino.cn/thread-92413-1-1.html">https://www.arduino.cn/thread-92413-1-1.html</a><br />
实验一百四十七：E18-D80NK 红外避障传感器 接近开关 智能小车 3-80cm<br />
<a href="https://www.arduino.cn/thread-92414-1-1.html">https://www.arduino.cn/thread-92414-1-1.html</a><br />
实验一百四十八：MCU mini RS232 MAX3232电平转TTL电平转换板 串口转换板<br />
<a href="https://www.arduino.cn/thread-92415-1-1.html">https://www.arduino.cn/thread-92415-1-1.html</a><br />
实验一百四十九：AS608光学指纹识别模块 智能锁/考勤门禁开发/指纹采集模块<br />
<a href="https://www.arduino.cn/thread-92416-1-1.html">https://www.arduino.cn/thread-92416-1-1.html</a><br />
实验一百五十：RCWL-0531心律血氧模块绿版MAX30102脉搏传感器（适用于手腕）<br />
<a href="https://www.arduino.cn/thread-92417-1-1.html">https://www.arduino.cn/thread-92417-1-1.html</a><br />
实验一百五十一：基于STM32F103RCT6及多种传感器的UFUN2.0升级开发板<br />
<a href="https://www.arduino.cn/thread-93214-1-1.html">https://www.arduino.cn/thread-93214-1-1.html</a><br />
实验一百五十二：GY-25 串口倾斜度角度传感器模块 MPU-6050<br />
<a href="https://www.arduino.cn/thread-94392-1-1.html">https://www.arduino.cn/thread-94392-1-1.html</a><br />
实验一百五十三：Maixduino AI开发板 k210 RISC-V AI+lOT ESP32视觉听觉开发套装<br />
<a href="https://www.arduino.cn/thread-94393-1-1.html">https://www.arduino.cn/thread-94393-1-1.html</a><br />
实验一百五十四：ML8511紫外线传感器模块 模拟量输出UV Sensor Breakou<br />
<a href="https://www.arduino.cn/thread-94394-1-1.html">https://www.arduino.cn/thread-94394-1-1.html</a><br />
实验一百五十五：KA2284 电平指示模块 5点LED电量/音频音乐旋律显示器<br />
<a href="https://www.arduino.cn/thread-94395-1-1.html">https://www.arduino.cn/thread-94395-1-1.html</a><br />
实验一百五十六：恒压型LED无级触摸调光PWM控制板 电容式触摸开关器模块<br />
<a href="https://www.arduino.cn/thread-94397-1-1.html">https://www.arduino.cn/thread-94397-1-1.html</a><br />
实验一百五十七：SG3525 PWM控制器模块 频率可调 占空比可调 波形发生器<br />
<a href="https://www.arduino.cn/thread-94414-1-1.html">https://www.arduino.cn/thread-94414-1-1.html</a><br />
实验一百五十八：QMC5883L电子指南针罗盘模块 三轴磁场传感器GY-271<br />
<a href="https://www.arduino.cn/thread-94412-1-1.html">https://www.arduino.cn/thread-94412-1-1.html</a><br />
实验一百五十九：MAX9814麦克风放大器模块 MIC话筒声音放大/咪头传感器<br />
<a href="https://www.arduino.cn/thread-94398-1-1.html">https://www.arduino.cn/thread-94398-1-1.html</a><br />
实验一百六十：压力传感器MD-PS002-150KPaA 真空传感器 绝压传感器 高度<br />
<a href="https://www.arduino.cn/thread-94416-1-1.html">https://www.arduino.cn/thread-94416-1-1.html</a><br />
实验一百六十一：旋转角度传感器模块 SV01A103AEA01R00微调电位器模块<br />
<a href="https://www.arduino.cn/thread-94417-1-1.html">https://www.arduino.cn/thread-94417-1-1.html</a><br />
实验一百六十二：S12SD紫外线传感器模块太阳光强度检测传感器模块高灵敏<br />
<a href="https://www.arduino.cn/thread-94418-1-1.html">https://www.arduino.cn/thread-94418-1-1.html</a><br />
实验一百六十三：BMI160模块 6DOF 6轴 角速度 陀螺仪+重力加速度传感器<br />
<a href="https://www.arduino.cn/thread-94419-1-1.html">https://www.arduino.cn/thread-94419-1-1.html</a><br />
实验一百六十四：Seeeduino Lotus开发板 传感器9件套 主板+扩展板二合一<br />
<a href="https://www.arduino.cn/thread-94953-1-1.html">https://www.arduino.cn/thread-94953-1-1.html</a><br />
实验一百六十五：2.4寸TFT液晶触摸屏 彩屏模块 可直插UNO R3 Mega2560开发板<br />
<a href="https://www.arduino.cn/thread-94955-1-1.html">https://www.arduino.cn/thread-94955-1-1.html</a><br />
实验一百六十六：PS2无线遥控手柄 双振动摇杆 游戏2.4G手柄<br />
<a href="https://www.arduino.cn/thread-94957-1-1.html">https://www.arduino.cn/thread-94957-1-1.html</a><br />
实验一百六十七：霍尔电流检测模块 0-30A量程霍尔电流监测器 过流报警模块<br />
<a href="https://www.arduino.cn/thread-94958-1-1.html">https://www.arduino.cn/thread-94958-1-1.html</a><br />
实验一百六十八：小喵科技nanobit mini主控开发板迷你microbit图形化编程makecode<br />
<a href="https://www.arduino.cn/thread-94961-1-1.html">https://www.arduino.cn/thread-94961-1-1.html</a><br />
实验一百六十九：12864带中文字库LCD12864液晶12864模块12864液晶屏带字库12864屏<br />
<a href="https://www.arduino.cn/thread-94962-1-1.html">https://www.arduino.cn/thread-94962-1-1.html</a><br />
实验一百七十：L293D四路电机驱动模块 扩展板 motor control shield 马达板<br />
<a href="https://www.arduino.cn/thread-101774-1-1.html">https://www.arduino.cn/thread-101774-1-1.html</a><br />
实验一百七十一：HLK-V20 AI智能离线语音识别模块 150条本地指令离线识别<br />
<a href="https://www.arduino.cn/thread-101816-1-1.html">https://www.arduino.cn/thread-101816-1-1.html</a><br />
实验一百七十二：MX1508 四通道双路有刷直流马达驱动模块 2路直流电机驱动模块 双H桥步进电机 正反转PWM调速<br />
<a href="https://www.arduino.cn/thread-102203-1-1.html">https://www.arduino.cn/thread-102203-1-1.html</a><br />
实验一百七十三：2262/2272四路无线遥控套件 M4非锁接收板 四键无线遥控器发射模块<br />
<a href="https://www.arduino.cn/thread-102440-1-1.html">https://www.arduino.cn/thread-102440-1-1.html</a><br />
实验一百七十四：DRV8833 电机驱动板模块 小体积高性能 2路直流电机驱动板 自平衡小车 代替TB6612FNG<br />
<a href="https://www.arduino.cn/thread-102287-1-1.html">https://www.arduino.cn/thread-102287-1-1.html</a><br />
实验一百七十五：LD3320 语音识别模块 非特定人声 语音控制 智能家居开发板<br />
<a href="https://www.arduino.cn/thread-102453-1-1.html">https://www.arduino.cn/thread-102453-1-1.html</a></p>
]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian开启crontab日志</title>
    <url>/2021/12/18/Debian%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211218114909331.png" alt="image-20211218114909331" style="zoom: 43%;" />
<p>搭建网易云闹钟需要查看crontab的运行情况，在此记录下如何实时监控log</p>
<a id="more"></a>
<p>实时查看crontab的log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure>
<p>但debian是默认不开启的，我们需要手动开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rsyslog.conf </span><br></pre></td></tr></table></figure>
<p>找到👇，然后把<code>#</code>去掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cron.* &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure>
<p>重启日志服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;rsyslog restart</span><br></pre></td></tr></table></figure>
<p>重启crontab服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;crond restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 学习笔记 - Hello</title>
    <url>/2020/12/26/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-Hello/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201226170026026.png" alt="image-20201226170026026" style="zoom:50%;" />
<p>如何优雅地在<a href="https://github.com/tangspoon66/NeteaseCloud-Clock">智能闹钟</a>上设定闹钟呢？使用命令行谈和优雅。想着能不能做个内网简单网页，通过web界面控制（增加与删除）<code>crontab</code>呢？了解到python相关的前端框架<code>flask</code>似乎有点意思，先学习看看。</p>
<a id="more"></a>
<blockquote>
<p>书名：<a href="https://read.helloflask.com">Flask 入门教程</a></p>
<p>作者：<a href="http://greyli.com/">李辉</a></p>
</blockquote>
<h2 id="一-虚拟环境的使用"><a class="markdownIt-Anchor" href="#一-虚拟环境的使用"></a> 一、虚拟环境的使用</h2>
<h3 id="1-创建虚拟环境"><a class="markdownIt-Anchor" href="#1-创建虚拟环境"></a> 1. 创建虚拟环境</h3>
<ul>
<li>保持全局环境的干净</li>
<li>指定不同的依赖版本</li>
<li>方便记录和管理依赖</li>
</ul>
<p>macOS创建虚拟环境方法：到你想要的文件夹，然后打开<code>terminal</code>，输入以下代码。然后在该文件夹会新生成一个<code>env</code>的文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m venv env</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>venv</code>是python中内置的模块，使用该模块来创建虚拟环境；<code>env</code>是虚拟环境的名字</p>
</blockquote>
<h3 id="2-激活虚拟环境"><a class="markdownIt-Anchor" href="#2-激活虚拟环境"></a> 2. 激活虚拟环境</h3>
<p>网上大部分激活教程都是直接给出<code>. env/bin/activate</code>。但对新手来说似乎有点摸不着头脑：前面的<code>.</code>是啥？</p>
<p>我们不妨直接打开activate文件试试。原来里面有说明具体用法！我们必须通过<code>source bin/activate</code>的方式激活，不能直接运行<code>activate</code>文件。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201225174954727.png" alt="image-20201225174954727" /></p>
<p>而且，我们要激活<code>env</code>，当然先要进入到<code>env</code>环境当中，所以可得激活方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd env &amp;&amp; source bin&#x2F;activate</span><br></pre></td></tr></table></figure>
<p>激活成功后，会变成下面这样：</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201225175417095.png" alt="image-20201225175417095" /></p>
<h3 id="3-退出虚拟环境"><a class="markdownIt-Anchor" href="#3-退出虚拟环境"></a> 3. 退出虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<h2 id="二-安装flask"><a class="markdownIt-Anchor" href="#二-安装flask"></a> 二、安装flask</h2>
<p><strong>以下所有操作均在虚拟环境中进行</strong></p>
<p><strong>激活虚拟环境后</strong>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install falsk</span><br></pre></td></tr></table></figure>
<h2 id="三-搭建最简单的flask项目"><a class="markdownIt-Anchor" href="#三-搭建最简单的flask项目"></a> 三、搭建最简单的flask项目</h2>
<p>因为是最简单的项目，所以我们都在<code>terminal</code>内进行吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在env内新建一个app文件夹，同时新建app.py</span><br><span class="line">mkdir app &amp;&amp; touch app.py</span><br><span class="line"># 编辑app.py</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure>
<p>然后粘贴以下内容后，退出并保存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> flask </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;你好！&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8443</span>)</span><br></pre></td></tr></table></figure>
<h2 id="四-运行"><a class="markdownIt-Anchor" href="#四-运行"></a> 四、运行</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python app.py</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211227171644922.png" alt="image-20211227171644922" /></p>
<p>然后在浏览器访问：`http://localhost:8443</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-01</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</url>
    <content><![CDATA[<p>基础的语法不再赘述，只强调以前未接触过的。</p>
<h3 id="一-数据类型和变量"><a class="markdownIt-Anchor" href="#一-数据类型和变量"></a> 一、数据类型和变量</h3>
<h5 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h5>
<p>键值对组成</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="code">    name: &#x27;Bob&#x27;,</span></span><br><span class="line"><span class="code">    age: 20,</span></span><br><span class="line"><span class="code">    tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;],</span></span><br><span class="line"><span class="code">    city: &#x27;Beijing&#x27;,</span></span><br><span class="line"><span class="code">    hasCar: true,</span></span><br><span class="line"><span class="code">    zipcode: null</span></span><br><span class="line"><span class="code">&#125;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Person为<code>对象</code>，name、age为<code>键</code>，‘Bob’、20为<code>值</code></li>
<li>获取对象的属性（怎么用对象的数据）：<a href="http://person.name">person.name</a></li>
</ul>
<a id="more"></a>
<h5 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h5>
<p>只能用<code>var</code>申明一次。没用<code>var</code>申明的变量：全局变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>
<h5 id="strict模式"><a class="markdownIt-Anchor" href="#strict模式"></a> strict模式</h5>
<p><code>'use strict';</code>强制通过<code>var</code>申明</p>
<h3 id="二-字符串"><a class="markdownIt-Anchor" href="#二-字符串"></a> 二、字符串</h3>
<ol>
<li>
<h5 id="多行字符串"><a class="markdownIt-Anchor" href="#多行字符串"></a> 多行字符串</h5>
<p>由于多行字符串用<code>\n</code>写起来费事，最新的ES6标准新增了如下方式表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;这是一个</span><br><span class="line">多行</span><br><span class="line">字符串&#96;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="模板字符串"><a class="markdownIt-Anchor" href="#模板字符串"></a> 模板字符串</h5>
<p>很多变量连接时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;小明&#39;;</span><br><span class="line">var age &#x3D; 20;</span><br><span class="line">var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三-数组"><a class="markdownIt-Anchor" href="#三-数组"></a> 三、数组</h3>
<ol>
<li>
<h5 id="indexof"><a class="markdownIt-Anchor" href="#indexof"></a> indexOf()</h5>
<p>搜索指定元素的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];</span><br><span class="line">arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0</span><br><span class="line">arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1</span><br><span class="line">arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="slice"><a class="markdownIt-Anchor" href="#slice"></a> slice()</h5>
<p>截取Array的部分元素，返回一个新的Array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>slice()</code>的起止参数包括开始索引，不包括结束索引</li>
<li>如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">var aCopy &#x3D; arr.slice();</span><br><span class="line">aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br><span class="line">aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="push-和-pop"><a class="markdownIt-Anchor" href="#push-和-pop"></a> push() 和 pop()</h5>
<ul>
<li><code>push()</code>插入数组尾部</li>
<li><code>pop()</code>删除～</li>
</ul>
</li>
<li>
<h5 id="unshift-和-shift"><a class="markdownIt-Anchor" href="#unshift-和-shift"></a> unshift() 和 shift()</h5>
<ul>
<li><code>unshift()</code>插入 头部第一</li>
<li><code>shift()</code>删除头部第一</li>
</ul>
</li>
<li>
<h5 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse()</h5>
<p>数组的反转</p>
</li>
<li>
<h5 id="splice"><a class="markdownIt-Anchor" href="#splice"></a> splice()</h5>
<p><em><strong>修改数组的万能方法</strong></em>，格式为：从哪里开始，删除多少个，添加什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat()</h5>
<p>连接两个数组。没有修改原数组，只是生成新数组</p>
</li>
<li>
<h5 id="join"><a class="markdownIt-Anchor" href="#join"></a> join()</h5>
<p>把<code>array</code>里面的元素，用指定的字符连起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];</span><br><span class="line">arr.join(&#39;-&#39;);</span><br><span class="line">arr;返回的就是&#39;a-b&#39;</span><br></pre></td></tr></table></figure>
<p>ps：如果Array的元素不是字符串，则自动转化再拼接</p>
</li>
</ol>
<h3 id="三-对象"><a class="markdownIt-Anchor" href="#三-对象"></a> 三、对象</h3>
<ol>
<li>
<p>用[‘x’]访问（少用）</p>
<p>属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用<code>.</code>访问</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaohong &#x3D; &#123;</span><br><span class="line">    name: &#39;小红&#39;,</span><br><span class="line">    &#39;middle-school&#39;: &#39;No.1 Middle School&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;</span><br><span class="line">xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;</span><br><span class="line">xiaohong.name; &#x2F;&#x2F; &#39;小红&#39;</span><br></pre></td></tr></table></figure>
<p><strong>ps：写代码尽量规范，尽量用<code>.</code>访问</strong></p>
<ol start="2">
<li>
<p>由于对象是动态类型，因此可以随便给对象添加或修改属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming&#x3D;&#123;</span><br><span class="line">		name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F;undefined</span><br><span class="line">xiaoming.age&#x3D;18;  &#x2F;&#x2F;添加了age属性</span><br><span class="line">delete xiaoming.age;  &#x2F;&#x2F;删除name属性</span><br><span class="line">xiaoming.age;  &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.name; &#x2F;&#x2F;删除name</span><br><span class="line">xiaoming.name; &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检测属性存在性</p>
<ul>
<li>用<code>in</code>操作符，返回布尔值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用<code>hasOwnProperty()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  	name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-学习笔记02-模版与表单</title>
    <url>/2021/12/27/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E6%A8%A1%E7%89%88%E4%B8%8E%E8%A1%A8%E5%8D%95/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201226170026026.png" alt="image-20201226170026026" style="zoom:50%;" />
<p>应用于智能快递柜的密码校验web</p>
<a id="more"></a>
<p>最简单的flask项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>
<h2 id="一-模版"><a class="markdownIt-Anchor" href="#一-模版"></a> 一、模版</h2>
<p>在flask项目内新建一个<code>templates</code>文件夹放置html，新建static文件夹放置css。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211227172852877.png" alt="image-20211227172852877" style="zoom:50%;" />
<h3 id="1-html"><a class="markdownIt-Anchor" href="#1-html"></a> 1. html</h3>
<p>在视图函数<code>return</code>就行，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;xxx.html&#x27;</span>,params)</span><br><span class="line"><span class="comment"># params为传递给html页面的参数</span></span><br></pre></td></tr></table></figure>
<h3 id="2-css"><a class="markdownIt-Anchor" href="#2-css"></a> 2. css</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 在html <span class="tag">&lt;<span class="name">head</span>&gt;</span>内添加：</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-参数"><a class="markdownIt-Anchor" href="#3-参数"></a> 3. 参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,name=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8443</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二-表单"><a class="markdownIt-Anchor" href="#二-表单"></a> 二、表单</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>智能快递柜<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">action</span>=<span class="string">&quot;result&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请联系收件人<span class="tag">&lt;<span class="name">br</span>&gt;</span>获取密码<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关注body内部：</p>
<p><code>action</code>：post请求重定向到<code>result路由</code></p>
<p><code>input name</code>：input的name一定要写，用于app.py获取input里的值。</p>
<p><code>form action</code>：处理form数据的路由页面（视图函数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;result&#x27;</span>),password=password)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/result&#x27;,methods=&#x27;GET&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span>():</span></span><br><span class="line">    pwd=<span class="string">&#x27;123&#x27;</span></span><br><span class="line">    password=request.args.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> password==pwd:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;correct.html&#x27;</span>,password=password)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;error.html&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>其实整个流程很好理解：首先路由<code>'/'</code>首先渲染index.html，然后得先获取input里面的值，也就是<code>request.form[]</code>。当我们submit之后，<code>POST请求</code>得把我们获取到<code>input的值</code> <code>return</code>到新的路由<code>result</code>页面中，这就是<code>redirect(url_for(),args)</code>的作用。然后新的路由页面，得接收POST过来的信息，所以method是<code>GET</code>，获取信息的方法是<code>request.args.get['args']</code>。所以我们在html里的form的action中，必须得明确我们要把信息提交到那个路由<code>/result</code></p>
]]></content>
      <categories>
        <category>智能快递柜</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-02</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</url>
    <content><![CDATA[<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<p><code>for</code>循环三个条件可省略，但如果无退出条件，则死循环。退出：break</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="forin"><a class="markdownIt-Anchor" href="#forin"></a> for…in</h4>
<p>用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//&#x27;name&#x27;  &#x27;age&#x27;  &#x27;school&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//‘0’，‘1’，‘2‘</span></span><br><span class="line">  <span class="comment">/*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/</span></span><br><span class="line">  <span class="comment">/*请注意，for ... in对Array的循环得到的是String而不是Number。*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例三</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">//&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤继承属性，使用day01学的<code>hasOwnProperty()</code>方法实现。例如：</p>
<p>ps：或者使用<code>for...of</code>，这也是为什么设计<code>for...of</code>的原因之一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="keyword">if</span>(o.hasOwnProperty(key))&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">//不然会输出toString属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性<code>key</code>」</li>
</ul>
</blockquote>
<h4 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h4>
<p>请利用循环遍历数组中的每个名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>];</span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">var</span> i=arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forof"><a class="markdownIt-Anchor" href="#forof"></a> for…of</h3>
<blockquote>
<ul>
<li>
<p>for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。</p>
</li>
<li>
<p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p>
</li>
</ul>
</blockquote>
<p>参考 <a href="https://www.zhangxinxu.com/wordpress/2018/08/for-in-es6-for-of/">张鑫旭大佬的文章</a></p>
<h3 id="map和set"><a class="markdownIt-Anchor" href="#map和set"></a> Map和Set</h3>
<blockquote>
<p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
</blockquote>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4>
<p><code>Map</code>是一组「键值对」的结构，具有极快的查找速度。例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="string">&#x27;Micheal&#x27;</span>,<span class="number">95</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">88</span>],[<span class="string">&#x27;Tracy&#x27;</span>,<span class="number">93</span>])</span><br><span class="line">m.get(<span class="string">&#x27;Micheal&#x27;</span>); <span class="comment">//返回的是95！</span></span><br><span class="line"><span class="comment">//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字</span></span><br></pre></td></tr></table></figure>
<p>其他操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m= <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//新建空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">100</span>);  <span class="comment">//添加新 key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">1</span>);  <span class="comment">//覆盖上面的100，返回1</span></span><br><span class="line">m.has(<span class="string">&#x27;tang&#x27;</span>);  <span class="comment">//返回true</span></span><br><span class="line">m.delete(<span class="string">&#x27;tang&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4>
<p>与<code>Map</code>不同，Set只存「key」，不存「value」。key不能重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>'3'</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterable-forof"><a class="markdownIt-Anchor" href="#iterable-forof"></a> iterable &amp; for…of</h3>
<blockquote>
<p><code>Array</code>可以下标循环，但遍历<code>Map</code> 和<code>Set</code>就无法使用下标。为了统一集合类型，ES6引入了<code>iterable</code>类型，<code>Array</code> 、<code>Map</code>和<code>Set</code> 都属于<code>iterable</code>类型。</p>
</blockquote>
<p>具有<code>iterable</code>类型的「集合」，可以通过<code>for...of</code>循环来遍历</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本操作</title>
    <url>/2020/10/29/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。</p>
<p>这篇博文开个Linux栏目吧。</p>
<a id="more"></a>
<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2>
<ul>
<li>新建文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch test1.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>新建文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test_dir</span><br></pre></td></tr></table></figure>
<ul>
<li>复制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 源路径 （空格）目标路径 </span><br></pre></td></tr></table></figure>
<ul>
<li>移动/剪切/重命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 移动&#x2F;剪切</span><br><span class="line">mv test.txt 文件夹路径</span><br><span class="line"></span><br><span class="line"># 移动+重命名</span><br><span class="line">mv test.txt test_dir&#x2F;test2.txt #test_dir为文件夹</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前所在路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<ul>
<li>权限修改</li>
</ul>
<p>这个参数较多，比较复杂，详细的后面再出一篇博文专门讲这一点。这里只讲常用的几点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file  # 所有人可读写</span><br><span class="line">chmod 600 file  # 拥有者可读写</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm  # 删除文件</span><br><span class="line">rm -f  # 强制删除文件</span><br><span class="line">rm -r  # 删除文件夹</span><br><span class="line">rm -rf  # 强制删除文件夹</span><br><span class="line">注意尽量少用 rm -rf！很危险！</span><br></pre></td></tr></table></figure>
<ul>
<li>读取文档内容</li>
</ul>
<blockquote>
<p>常用语查看Linux的log日志文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  # 一次全部读取</span><br><span class="line">more  # 逐步读取</span><br><span class="line">tail -f  # 一直读取最新内容</span><br><span class="line">tail -n 行数 文件名  # 从第几行开始读</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-03</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/</url>
    <content><![CDATA[<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<h4 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4>
<p>调用函数时，按顺序传入参数。</p>
<blockquote>
<p>JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br><span class="line">abs(); <span class="comment">// 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免</span></span><br></pre></td></tr></table></figure>
<h4 id="arguments"><a class="markdownIt-Anchor" href="#arguments"></a> arguments</h4>
<ul>
<li>获得调用者的所有参数，但不是一个<code>Array</code></li>
<li>是一个关键字</li>
<li>只在函数内部起作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 308</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要善于利用<code>arguments</code>判断传入参数多少的作用</p>
</blockquote>
<h4 id="rest参数"><a class="markdownIt-Anchor" href="#rest参数"></a> rest参数</h4>
<blockquote>
<p>是ES6新增的特性，形式为：…变量名</p>
</blockquote>
<p>作用：获取函数多余的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取a，b之外的参数例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined 因为b在参数中被定义了，要直接输出</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<h3 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h3>
<ol>
<li>
<p>用<code>rest</code>参数编写一个<code>add()</code>函数，用于接收任意个参数并返回她们的和。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line">    rest.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elemnt</span>)</span>&#123;</span><br><span class="line">      sum += element;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个计算圆面积的函数<code>area_of_circle()</code>，它有两个参数：</p>
<ul>
<li>r: 表示圆的半径；</li>
<li>pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r,pi</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.14</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.1416</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r, pi</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span>[r,pi=<span class="number">3.14</span>]=<span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> pi*r*r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域和解构赋值"><a class="markdownIt-Anchor" href="#变量作用域和解构赋值"></a> 变量作用域和解构赋值</h3>
<h4 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h4>
<p>js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。</p>
<blockquote>
<p>注意：只是变量的声明，并不是赋值。</p>
</blockquote>
<h4 id="块级作用域"><a class="markdownIt-Anchor" href="#块级作用域"></a> 块级作用域</h4>
<p>ES6引入了新关键字 <code>let</code>，用<code>let</code>代替<code>var</code>可以声明一个块级作用域的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4>
<p>ES6引入了一个<code>const</code>关键字来定义常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<h4 id="解构赋值"><a class="markdownIt-Anchor" href="#解构赋值"></a> 解构赋值</h4>
<blockquote>
<p>此知识点小点比较多，详细请看<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808">廖雪峰的官网</a></p>
</blockquote>
<ul>
<li>在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>如果数组本身还有嵌套，只需要嵌套和层次对齐即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[x,[y,z]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br></pre></td></tr></table></figure>
<ul>
<li>从对象中取出其中几个属性的值，也可以用解构赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  name: <span class="string">&#x27;tang&#x27;</span>,</span><br><span class="line">  tel: <span class="string">&#x27;12345&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  password: <span class="string">&#x27;S-12345&#x27;</span>,</span><br><span class="line">  address:&#123;</span><br><span class="line">  	city:<span class="string">&#x27;beijing&#x27;</span>,</span><br><span class="line">  	street:No<span class="number">.1</span> Road,</span><br><span class="line">  	zipcode:<span class="string">&#x27;10000&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把person的name和tel取出给var定义的name,tel</span></span><br><span class="line"><span class="keyword">var</span> &#123;name,tel&#125;=person;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name=&#x27;</span>+name+<span class="string">&#x27;,&#x27;</span>+<span class="string">&#x27;tel=&#x27;</span>+tel);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name=tang</span></span><br><span class="line"><span class="comment">tel=12345</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果要对嵌套对象address里面的值进行赋值，也能用解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">address</span>:&#123;city,street&#125;&#125;=person;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要使用的变量名和属性名不一致，可以用下面的语法获取：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">password</span>:id&#125;=person;</span><br><span class="line"><span class="comment">//这里就是把password「属性」赋值给了变量id</span></span><br><span class="line"><span class="comment">//注意：是把password这个属性赋值给了id，所以password不是一个变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把<code>&#123;</code>开头的语句做块处理，<code>=</code> 不再合法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line">&#123;x,y&#125;=&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">300</span>&#125;;</span><br><span class="line"><span class="comment">//解决办法，用()括起来</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<h4 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h4>
<p><code>this</code>是一个特殊变量，始终指向当前对象。下面的例子就是<code>this</code>指向的对象是小明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y-<span class="built_in">this</span>.birth; <span class="comment">//当前对象为xiaoming</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但想要把age方法里面的内容拆开写，要怎么办呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写一个getAge()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写小明对象</span></span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  ame:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况一：</span></span><br><span class="line">xiaoming.age();<span class="comment">//正常返回25</span></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line">getAge; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么情况二返回的是<code>NaN</code>？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。</p>
</blockquote>
<p>想要指向正确，<strong>必须用<code>obj.xxx()</code>的形式调用</strong>，也就是「对象.方法名」</p>
<h4 id="that"><a class="markdownIt-Anchor" href="#that"></a> that</h4>
<p>我们先看看下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，<code>this</code>指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。</p>
<p><strong>修复方法：使用<code>that</code>变量，在方法内部一开始就首先捕获<code>this</code>：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age();<span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
</blockquote>
<h4 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h4>
<p>可以指定函数的<code>this</code>指向哪个对象，apply(this要指定的对象 , <code>Array</code>函数本身的参数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.getAge();<span class="comment">//25</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br></pre></td></tr></table></figure>
<p><code>apply()</code>把参数打包成Array再传入；<code>call()</code>把参数按顺序传入。二者功能类似。</p>
<p>例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。</p>
<blockquote>
<p>所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;  <span class="comment">//add函数的参数为x,y,f，而参数f是一个函数</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = add(<span class="number">-5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs); </span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p><strong>高阶函数将在下一篇博文详解</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>N1盒子部署我的网易云闹钟折腾记</title>
    <url>/2021/12/18/N1%E7%9B%92%E5%AD%90%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%BD%91%E6%98%93%E4%BA%91%E9%97%B9%E9%92%9F%E6%8A%98%E8%85%BE%E8%AE%B0/</url>
    <content><![CDATA[<p>前面N1盒子刷armbian的目的之一就是为了更好的安装我的网易云闹钟，早上更好的叫醒我。</p>
<p>但一路可谓是遇到了非常多坑。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122647253.png" alt="image-20211218122647253" /></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211218121833554.png" alt="image-20211218121833554" style="zoom:43%;" />
<a id="more"></a>
<h2 id="一-背景介绍"><a class="markdownIt-Anchor" href="#一-背景介绍"></a> 一、背景介绍</h2>
<p>一开始我刷了带桌面的ubuntu，把我坑得不要不要的！在桌面版终端命令执行python脚本或者鼠标点击mp4文件都有声音出来，但是一旦ssh或者在crontab中执行python脚本就没有声音！！！前前后后折腾了一个晚上毫无结果。</p>
<p>分析大概是桌面端的问题，也有可能是armbian和N1盒子不那么适配。所以还是换成了没有桌面端的debian。</p>
<h2 id="二-系统配置"><a class="markdownIt-Anchor" href="#二-系统配置"></a> 二、系统配置</h2>
<h3 id="1-更新apt"><a class="markdownIt-Anchor" href="#1-更新apt"></a> 1. 更新apt</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="2-换python3"><a class="markdownIt-Anchor" href="#2-换python3"></a> 2. 换python3</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除&#x2F;usr&#x2F;bin目录下的python link文件</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line"># 删除后再建立新的链接关系：</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure>
<h3 id="3-安装pip3"><a class="markdownIt-Anchor" href="#3-安装pip3"></a> 3. 安装pip3</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install python3-pip</span><br></pre></td></tr></table></figure>
<h3 id="4-baidu-aip"><a class="markdownIt-Anchor" href="#4-baidu-aip"></a> 4. baidu-aip</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install baidu-aip</span><br></pre></td></tr></table></figure>
<h3 id="5-mpg123或mplayer"><a class="markdownIt-Anchor" href="#5-mpg123或mplayer"></a> 5. mpg123或mplayer</h3>
<p>在树莓派上我是用mplayer的，但在N1盒子上使用mplayer播放音乐一卡一卡的。结果换成了mpg123就没问题了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mpg123</span><br><span class="line">apt-get install mpg123</span><br><span class="line"></span><br><span class="line"># mplayer</span><br><span class="line">apt-get install mplayer</span><br></pre></td></tr></table></figure>
<h2 id="三-配置声卡"><a class="markdownIt-Anchor" href="#三-配置声卡"></a> 三、配置声卡</h2>
<p>在pdd买了一个免驱的usb网卡，可以直接接3.5mm的音频。但使用mpg123播放音乐没有声音。根据前面树莓派的经验，应该是网卡配置有问题。因为armbian默认是card0的声卡，可能是一开始插了HDMI默认了是card0。我们要做的就是修改我们的usb设备为默认声卡就行。</p>
<h3 id="1-查看所有声卡信息"><a class="markdownIt-Anchor" href="#1-查看所有声卡信息"></a> 1. 查看所有声卡信息</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aplay -l </span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122844083.png" alt="image-20211218122844083" /></p>
<p>我们需要usb声卡的 card 数字<code>1</code> 和 device数字<code>0</code></p>
<h3 id="2-修改默认声卡文件"><a class="markdownIt-Anchor" href="#2-修改默认声卡文件"></a> 2. 修改默认声卡文件</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;asound.conf</span><br></pre></td></tr></table></figure>
<p>默认是没有asound.conf文件的，不要紧，直接新建添加就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults.pcm.card 1  </span><br><span class="line">defaults.pcm.device 0 </span><br><span class="line">defaults.ctl.card 1</span><br></pre></td></tr></table></figure>
<h3 id="3-测试声卡"><a class="markdownIt-Anchor" href="#3-测试声卡"></a> 3. 测试声卡</h3>
<p>upload一段mp3文件，然后使用mpg123播放查看有没有声音。如果没有，就reboot一下。大概率是OK的。</p>
<h2 id="四-部署网易云闹钟项目"><a class="markdownIt-Anchor" href="#四-部署网易云闹钟项目"></a> 四、部署网易云闹钟项目</h2>
<p>前面工具和相关依赖环境已经配置好了。直接git clone项目，然后修改相关配置就行。</p>
<p>详细请看GitHub项目：<a href="https://github.com/tangspoon66/NeteaseCloud-Clock#%E4%BA%94%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">开始搭建</a></p>
<h2 id="五-相关文章"><a class="markdownIt-Anchor" href="#五-相关文章"></a> 五、相关文章</h2>
<p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/48399585">alsa设置默认声卡</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm远程连接树莓派同步编辑py文件</title>
    <url>/2020/12/20/PyCharm%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E5%90%8C%E6%AD%A5%E7%BC%96%E8%BE%91py%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201220115218956.png" alt="image-20201220115218956" style="zoom:30%;" />
<p>直接在树莓派上面调试python脚本非常麻烦，作出一次修改就得删除然后上传重新覆盖，效率太低了。其实大部分编译器都会有远程连接服务器编辑代码的功能，PyCharm也不例外。</p>
<p>网上大多数都是在创建project时添加remote，这里我们说更实用的场景：直接在project创建好后，再添加remote。</p>
<a id="more"></a>
<hr />
<p>我们打开project的Preferences（macOS的快捷键是<code>commond</code>+<code>,</code>），然后在左上角的搜索框输入interpreter（解释器），然后如下图，点击Add。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219233324749.png" alt="image-20201219233324749" style="zoom:30%;" />
<br/>
<p>然后左侧栏选择SSH Interpreter，在右方填写好树莓派的ip、用户名，然后点击next。然后填写密码，<strong>记得Save password</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220113238699.png" alt="image-20201220113238699" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201219233510656.png" alt="image-20201219233510656" style="zoom:33%;" />
<br/>
<p>接下来，Interpreter处要选择好树莓派的python版本，默认选择路径是<code>/usr/bin/python</code>，这个路径其实就是我们执行<code>python</code>这个命令时使用的python，此路径默认2.7。2020年了我们当然要使用py3啦，所以我们要提前把<code>/usr/bin/pyhton</code>这个路径的python版本改为python3的。</p>
<p>剩下的我们就按照下图操作，然后点击Finish即可。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220114155921.png" alt="image-20201220114155921" style="zoom:50%;" />
<p>然后我们在项目中新建一个<code>test.py</code>文件，里面输入<code>print('test')</code>测试一下。可以看到，是已经自动上传到树莓派中了。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201220114703381.png" alt="image-20201220114703381" /></p>
<p>然后我们直接在FinalShell的的文件查看器中查看是否有<code>test.py</code>文件</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220114834281.png" alt="image-20201220114834281" style="zoom:40%;" />
<p>Done！</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的init()到底怎么理解？</title>
    <url>/2020/11/24/Python%E4%B8%AD%E7%9A%84init-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201119103811421.png" alt="image-20201119103811421" style="zoom:50%;" />
<p>在<code>Person</code>类里面有一个<code>__init__(self,name,age)</code>，这里我们分成<code>__init__()</code>和<code>self</code>，和<code>age</code> <code>name</code>三个部分来看。</p>
<a id="more"></a>
<p><code>__init__()</code>是初始化函数。为什么需要初始化呢？简单来说，我们在创建<code>Person</code>这个对象的时候，我们仅仅只是创建了一个<strong>模具</strong>，这个模具什么都没有，没有作为一个person应该有的name和age。这显然是不合理的。</p>
<p>所以我们在实例化对象<code>p=Person()</code>的时候，<code>Person</code>类马上开始初始化，创造出一个拥有<strong>属性</strong>的person。</p>
<p>那么<code>self</code>又是什么东西？</p>
<p><code>self</code>是必须的，缺少了会报错。在很多博客上都有说：“<code>self</code><strong>外部对象在类内部的表示</strong>”。这里我们说人话，注意听“<strong><em>谁调用，就表示谁</em></strong>”。这里我们把<code>Person</code>实例化给了<code>p</code>，所以就是<code>p</code>调用，简单理解就是这个<code>self</code>就是表示<code>p</code>。我们必须得把<code>p</code>传入到类里面，然后才能通过点<code>.</code>的方式去访问类的属性和方法呀。</p>
<hr />
<blockquote>
<p>参考资料</p>
<p>知乎回答： <a href="https://www.zhihu.com/question/46973549/answer/293788116">https://www.zhihu.com/question/46973549/answer/293788116</a></p>
<p>最良心的Python教程：</p>
<p><a href="https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md">https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-02｜复习</title>
    <url>/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-02%EF%BD%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p>
<p>第二天：函数的参数、传值、匿名函数</p>
<a id="more"></a>
<p><code>2021-12-17</code></p>
<p>01和这个02相隔有点久，这段时间在搞从老妈子从垃圾桶旁捡回来的主机，150块把它整复活了～然后把树莓派卖了，换了一台斐讯的N1盒子继续挂网易云闹钟。</p>
<h2 id="一-函数参数"><a class="markdownIt-Anchor" href="#一-函数参数"></a> 一、函数参数</h2>
<p>python的函数可以有多个返回值，实际上是先创建了一个元组然后再返回的。</p>
<h3 id="1-默认参数"><a class="markdownIt-Anchor" href="#1-默认参数"></a> 1. 默认参数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># b是默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b=<span class="number">1</span></span>):</span></span><br><span class="line">	<span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h4 id="1要在末尾"><a class="markdownIt-Anchor" href="#1要在末尾"></a> （1）要在末尾</h4>
<h4 id="2不能使用list这种形式做默认参数默认值必须为不可更改的整数-字符串-true-false-none等"><a class="markdownIt-Anchor" href="#2不能使用list这种形式做默认参数默认值必须为不可更改的整数-字符串-true-false-none等"></a> （2）不能使用<code>list=[]</code>这种形式做默认参数，默认值必须为不可更改的：整数、字符串、True、False、None等。</h4>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b=None</span>)</span></span><br><span class="line"><span class="function">	<span class="title">return</span> <span class="title">b</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">def</span> <span class="title">test</span>(<span class="params">a,b=[]</span>) 不会报错，但一旦对<span class="title">b</span>修改，返回结果会出错</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-位置参数关键字参数"><a class="markdownIt-Anchor" href="#2-位置参数关键字参数"></a> 2. 位置参数（关键字参数）</h3>
<p>python中可以根据<strong>参数名</strong>传参，所以不顺序传参也行（但最好顺序）。</p>
<h3 id="3-不定长参数可变参数"><a class="markdownIt-Anchor" href="#3-不定长参数可变参数"></a> 3. 不定长参数（可变参数）</h3>
<p>有时候在设计函数时，我们无法确定传入参数的多少，这时候就可以用<code>tuple元组</code>或<code>dist字典</code>来描述那些没有被定义的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a=<span class="number">1</span>,*b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">re=test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(re) <span class="comment">#结果：(2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dist</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a=<span class="number">1</span>,**b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">re=test(<span class="number">1</span>,b=(,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">print(re) <span class="comment">#结果：&#123;&#x27;b&#x27;:(2,3,4,5)&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>*b</code>返回结果是元组</p>
<p><code>**b</code>其实是不定长参数里的关键字参数，是通过关键字<code>b</code>确定的。</p>
<h3 id="4-强制使用关键字参数"><a class="markdownIt-Anchor" href="#4-强制使用关键字参数"></a> 4. 强制使用关键字参数</h3>
<p>把需要强制使用keyword的参数放在<code>*</code>后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,*,b</span>):</span></span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">re=test(<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line">print(re)</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20211217172829525.png" alt="image-20211217172829525" style="zoom:50%;" />
<h2 id="二-传值"><a class="markdownIt-Anchor" href="#二-传值"></a> 二、传值</h2>
<p>除了<code>list</code>和<code>dist</code>可变之外，其他像整形、浮点型、字符串、tuple等都不可变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">	print(a) <span class="comment">#a的值是不会被改变的</span></span><br><span class="line">	a=<span class="number">1000</span></span><br><span class="line">	print(a) <span class="comment"># 这里的a只是test()外的a的复制体，改变的也只是复制体的值</span></span><br><span class="line">	</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1000</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<h2 id="三-匿名函数"><a class="markdownIt-Anchor" href="#三-匿名函数"></a> 三、匿名函数</h2>
<p>不用def整体命名整个函数，用最简单的形式写一个回调函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum=<span class="keyword">lambda</span> num1,num2:num1+num2</span><br><span class="line">print(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>基本形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,arg2 : expression</span><br></pre></td></tr></table></figure>
<p>有个地方需要注意：下面的结果都是10001。因为num2是一个自由参数，是按<code>执行顺序</code>绑定值，不是定义时就绑定。</p>
<blockquote>
<p>可看python的执行顺序：<a href="https://pythontutor.com/visualize.html#mode=display">https://pythontutor.com/visualize.html#mode=display</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">num2 = <span class="number">100</span></span><br><span class="line">sum1 = <span class="keyword">lambda</span> num1 : num1 + num2 ;</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">10000</span></span><br><span class="line">sum2 = <span class="keyword">lambda</span> num1 : num1 + num2 ;</span><br><span class="line"></span><br><span class="line">print( sum1( <span class="number">1</span> ) )</span><br><span class="line">print( sum2( <span class="number">1</span> ) )</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211217180821420.png" alt="image-20211217180821420" /></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-01｜复习</title>
    <url>/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-01%EF%BD%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437.png" alt="image-20211208153223437" /></p>
<p>自己写了好几个python项目之后发现，好多知识都遗忘了，有些没有理解透导致执行效率不高。趁这段时间有空，重新学习一下。</p>
<p>list、dict、tuple、set、string</p>
<a id="more"></a>
<p><code>2021-12-07</code></p>
<h2 id="一-list列表"><a class="markdownIt-Anchor" href="#一-list列表"></a> 一、List列表</h2>
<h3 id="1-在特定位置增加元素"><a class="markdownIt-Anchor" href="#1-在特定位置增加元素"></a> 1. 在特定位置增加元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.insert(index,obj)</span><br></pre></td></tr></table></figure>
<h3 id="2-扩展"><a class="markdownIt-Anchor" href="#2-扩展"></a> 2. 扩展</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.extend(seq)</span><br></pre></td></tr></table></figure>
<p>是直接改变原来的list，不是生成一个新的list。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list1.extend(list2)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<h3 id="3-删除"><a class="markdownIt-Anchor" href="#3-删除"></a> 3. 删除</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="keyword">del</span> list[index]</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">list.pop(index) <span class="comment"># 默认最后一个元素，并返回该元素的值</span></span><br><span class="line"><span class="comment"># 方式三</span></span><br><span class="line">list.remove(obj) <span class="comment"># 参数是列表中元素，不返回任何值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;pop:&#x27;</span>, list1.pop(<span class="number">5</span>)) <span class="comment"># 输出x</span></span><br><span class="line">print(<span class="string">&#x27;remove:&#x27;</span>, lsit1.remove(<span class="string">&#x27;a&#x27;</span>)) <span class="comment"># 输出none</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-反向"><a class="markdownIt-Anchor" href="#4-反向"></a> 4. 反向</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.reverse()</span><br></pre></td></tr></table></figure>
<h3 id="5-排序"><a class="markdownIt-Anchor" href="#5-排序"></a> 5. 排序</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list.sort(reverse=<span class="literal">False</span>,key=<span class="literal">None</span>,cmp=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># reverse=false是默认方式：升序（小到大），True为降序</span></span><br><span class="line"><span class="comment"># key指定元素进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span>(<span class="params">elem</span>):</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line">print(random)</span><br><span class="line"><span class="comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br></pre></td></tr></table></figure>
<h2 id="二-tuple元组"><a class="markdownIt-Anchor" href="#二-tuple元组"></a> 二、tuple元组</h2>
<h3 id="1-单个元素要加逗号"><a class="markdownIt-Anchor" href="#1-单个元素要加逗号"></a> 1. 单个元素要加逗号</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple=(<span class="number">123</span>) <span class="comment"># print结果：123</span></span><br><span class="line">tuple=(<span class="number">123</span>,) <span class="comment"># print结果：(123,)</span></span><br><span class="line"><span class="comment"># 因为()既可以是括号也可以是元组，会有歧义。加个逗号就代表是元组啦</span></span><br></pre></td></tr></table></figure>
<h3 id="2-tuple的修改"><a class="markdownIt-Anchor" href="#2-tuple的修改"></a> 2. tuple的修改</h3>
<p><code>tuple是不可修改的</code>指的是每个元素的指向，永远不变。但我们可以嵌入一个数组，间接修改tuple</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[lsit1])</span><br><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list1[<span class="number">0</span>]=<span class="string">&#x27;x&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;tuple：&#x27;</span>,tuple)</span><br><span class="line"><span class="comment"># print结果 tuple： (1, 2, 3, 4, [&#x27;x&#x27;, &#x27;b&#x27;])</span></span><br></pre></td></tr></table></figure>
<h3 id="3-读取"><a class="markdownIt-Anchor" href="#3-读取"></a> 3. 读取</h3>
<p>换成<code>list</code>，再读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">list=[]</span><br><span class="line">list=tuple</span><br><span class="line">print(list[<span class="number">0</span>]) <span class="comment"># 获取元组第一个数据</span></span><br></pre></td></tr></table></figure>
<h2 id="三-dict字典"><a class="markdownIt-Anchor" href="#三-dict字典"></a> 三、dict字典</h2>
<p>因为list列表越长，查找起来就越慢。用字典dict可以解决问题。</p>
<p>字典中一个键值重复出现两次，那么以最后一次的值为准。</p>
<p><code>键</code>不可变，可以用字符串、数字、元祖。但就是不用数组（因为数组是可修改的，这与<code>键</code>是不可修改的冲突）</p>
<h3 id="1-增加"><a class="markdownIt-Anchor" href="#1-增加"></a> 1. 增加</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="2-修改"><a class="markdownIt-Anchor" href="#2-修改"></a> 2. 修改</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;a&#x27;</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="3-删除-2"><a class="markdownIt-Anchor" href="#3-删除-2"></a> 3. 删除</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</span><br><span class="line"># 通过键，删除值</span><br><span class="line">del dict1[&#39;a&#39;]</span><br><span class="line"># 删除所有元素</span><br><span class="line">dict1.clean</span><br><span class="line"># 删除字典</span><br><span class="line">del dict1</span><br></pre></td></tr></table></figure>
<h3 id="4-copy-浅拷贝"><a class="markdownIt-Anchor" href="#4-copy-浅拷贝"></a> 4. copy() 浅拷贝</h3>
<p>dict2=dict1这种方式是一引用，简单说就是给dict1起了另一条新名字而已。输出结果与dict1保持一致。</p>
<p>在介绍浅拷贝前，先认识一下深拷贝会更好。深拷贝是对象的完全拷贝，拷贝后的dist2是不受dist的变化影响的。也就是说，深拷贝后的dist2是独立的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211207192758608.png" alt="image-20211207192758608" style="zoom:32%;" />
<p>而浅拷贝则不是独立的。对浅拷贝的新dist2来说，操作对象是<code>值</code>，<code>键</code>是不会随dist1变的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211207192102217.png" alt="image-20211207192102217" style="zoom:30%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象</span></span><br><span class="line"> </span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"> </span><br><span class="line">print( <span class="string">&#x27;a = &#x27;</span>, a )</span><br><span class="line">print( <span class="string">&#x27;b = &#x27;</span>, b )</span><br><span class="line">print( <span class="string">&#x27;c = &#x27;</span>, c )</span><br><span class="line">print( <span class="string">&#x27;d = &#x27;</span>, d )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="string">&#x27;a = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;b = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;c = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line">(<span class="string">&#x27;d = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure>
<p>可以看到，深拷贝的d是完全不受a的变化而影响；而浅拷贝的c则被改变了<code>值</code>。</p>
<h2 id="四-set"><a class="markdownIt-Anchor" href="#四-set"></a> 四、set</h2>
<p>set是一个无序的、不重复的元素集。就像是一个不储存<code>值value</code>，只有<code>键key</code>的字典。</p>
<h3 id="1-创建"><a class="markdownIt-Anchor" href="#1-创建"></a> 1. 创建</h3>
<p>set的创建需要用<code>set()</code>方法，然后提供一个<code>list</code>作为输入集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1=set([])</span><br></pre></td></tr></table></figure>
<h3 id="2-删除"><a class="markdownIt-Anchor" href="#2-删除"></a> 2. 删除</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1=set([<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>])</span><br><span class="line">set1.remove(<span class="number">123</span>)</span><br><span class="line">print(set1) <span class="comment"># 结果：&#123;456,789&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-应用"><a class="markdownIt-Anchor" href="#3-应用"></a> 3. 应用</h3>
<h4 id="1-交集"><a class="markdownIt-Anchor" href="#1-交集"></a> 1. 交集</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1=set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">set2=set([<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">set3=set1&amp;set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-并集"><a class="markdownIt-Anchor" href="#2-并集"></a> 2. 并集</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set3=set1|set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-差集"><a class="markdownIt-Anchor" href="#3-差集"></a> 3. 差集</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set3=set1-set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;4&#125;</span></span><br><span class="line"></span><br><span class="line">set3=set2-set1</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;5,6&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-去除海量元素"><a class="markdownIt-Anchor" href="#4-去除海量元素"></a> 4. 去除海量元素</h4>
<p>这部分是最有意思的。刚好当天看到了有个腾讯三面题，40亿个qq号怎么去重。我在想，用<code>set</code>会怎么样？这里就涉及到<code>set</code>的一个属性——需要提供一个<code>list</code>集合作为数据输入。把40亿的数据变成的list显然不现实。所以这可以看做是用<code>set</code>去除海量元素的限制。</p>
<p>但是测试了一下1000w个7位数的整数去重，只花了2.3s！这个速度还是快到惊人的！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>,<span class="number">666</span>]  </span><br><span class="line">set1=set(list1)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure>
<h2 id="五-string"><a class="markdownIt-Anchor" href="#五-string"></a> 五、string</h2>
<h3 id="1-find"><a class="markdownIt-Anchor" href="#1-find"></a> 1. find()</h3>
<p>检测字符串中是否包含子字符串。可指定范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&#x27;tang&#x27;</span></span><br><span class="line">print(str.find(<span class="string">&#x27;n&#x27;</span>)) <span class="comment">##返回index位置</span></span><br><span class="line">print(str.find(<span class="string">&#x27;s&#x27;</span>)) <span class="comment">##返回-1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-index"><a class="markdownIt-Anchor" href="#2-index"></a> 2. index()</h3>
<p>用于查找位置。</p>
<h3 id="3-lower-upper"><a class="markdownIt-Anchor" href="#3-lower-upper"></a> 3. lower()、upper()</h3>
<p>大小写</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">str.upper()</span><br></pre></td></tr></table></figure>
<h4 id="4-split"><a class="markdownIt-Anchor" href="#4-split"></a> 4. split()</h4>
<p>分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">&#x27;tang#spoo#n&#x27;</span></span><br><span class="line">str.split(<span class="string">&#x27;#&#x27;</span>，<span class="number">1</span>)  <span class="comment">### [&#x27;tang&#x27;, &#x27;spoo#n&#x27;]</span></span><br><span class="line">str.split(<span class="string">&#x27;#&#x27;</span>)	  <span class="comment">### [&#x27;tang&#x27;, &#x27;spoo&#x27;, &#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="5-strip"><a class="markdownIt-Anchor" href="#5-strip"></a> 5. strip()</h3>
<p>去除两端指定符号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&#39; tangspoon &#39;</span><br><span class="line">str.strip(&#39; &#39;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-03｜复习</title>
    <url>/2021/12/17/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-03%EF%BD%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p>
<p>第三天：迭代、迭代器、list生成式</p>
<a id="more"></a>
<p><code>2021-12-18</code></p>
<h2 id="一-迭代"><a class="markdownIt-Anchor" href="#一-迭代"></a> 一、迭代</h2>
<p>python中<code>访问集合元素</code>的方式之一。说白了就是循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 遍历 dict 的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    print(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历 dict 的values</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    print(values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 字符串 集合里的元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二-迭代器"><a class="markdownIt-Anchor" href="#二-迭代器"></a> 二、迭代器</h2>
<h3 id="1-iter"><a class="markdownIt-Anchor" href="#1-iter"></a> 1. <code>iter()</code></h3>
<p>Python 的 <code>for</code> 循环就是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line">print(it)</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20211218164251631.png" alt="image-20211218164251631" style="zoom:50%;" />
<p>可以看到并不是直接通过<code>iter()</code>就可以迭代的。还是要通过for或者while打印出list1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>
<p>iter()只是获得了一个迭代对象，还需要通过循环遍历。</p>
<h3 id="2-next"><a class="markdownIt-Anchor" href="#2-next"></a> 2. <code>next()</code></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line">print(next(it))</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20211218165518356.png" alt="image-20211218165518356" style="zoom:50%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="keyword">print</span> ( next ( iter3 ) )</span><br><span class="line">    <span class="keyword">except</span> StopIteration :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># for i in (0,len(list1)):</span></span><br><span class="line"><span class="comment">#	print(next(it))</span></span><br></pre></td></tr></table></figure>
<h2 id="三-list生成式"><a class="markdownIt-Anchor" href="#三-list生成式"></a> 三、list生成式</h2>
<p>只是一种更简洁的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> iterable_var <span class="keyword">in</span> iterable]</span><br><span class="line">[expression <span class="keyword">for</span> iterable_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expression]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> rang(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure>
<p>注意：<code>y</code>是嵌套在<code>x</code>里面的for循环</p>
<h2 id="四-生成器generator"><a class="markdownIt-Anchor" href="#四-生成器generator"></a> 四、生成器generator</h2>
<p><strong>一边循环一遍计算，不必创建完整的<code>list</code>。</strong></p>
<p>以<code>()</code>的生成式/有<code>yield</code>存在就叫生成器。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># （）</span></span><br><span class="line">gen = (x*x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>()</span></span><br><span class="line"><span class="function">	<span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span>(<span class="params"><span class="number">5</span></span>):</span></span><br><span class="line">		<span class="keyword">yield</span> i</span><br><span class="line">print(test())</span><br><span class="line"><span class="comment"># 结果：&lt;generator object test at 0x105603660&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-为什么需要生成器"><a class="markdownIt-Anchor" href="#1-为什么需要生成器"></a> 1. 为什么需要生成器</h3>
<p>（1）生成一个非常大的<code>list</code>非常耗费储存空间</p>
<p>（2）如果我们只需要列表的前面一些值，就需要生成整个列表，后面部分的空间就被浪费了。</p>
<p>生成器表达式使用了一种叫lazy evaluation（惰性计算）的计算方法，调用方式是<code>call by need</code>。<strong>只有在被检索时才会被赋值</strong>。因此在列表比较长时使用内存会有效。</p>
<h3 id="2-遍历生成器的元素"><a class="markdownIt-Anchor" href="#2-遍历生成器的元素"></a> 2. 遍历生成器的元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen=(x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>
<h3 id="3-以函数的形式实现生成器"><a class="markdownIt-Anchor" href="#3-以函数的形式实现生成器"></a> 3. 以函数的形式实现生成器</h3>
<p>在实际运用中，大多数的generator都是通过函数来实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">		<span class="keyword">yield</span> i </span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure>
<p>但上面的例子非常不适合使用generator，因为generator最好的应用是——不想同一时间 将大量的结果 都分配到内存里。特别是结果集里还包含循环。</p>
<p>另外注意：在用函数生成的生成器中，执行过程是——遇到<code>yield</code>就中断，返回值。所以在一个函数中有多个<code>yield</code>时，无论多少次调用这个函数，每调用一次<code>yield</code>，这个<code>yield</code>就被抛弃掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">	print(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line">	<span class="keyword">yield</span>(<span class="number">1</span>)</span><br><span class="line">	print(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line">	<span class="keyword">yield</span>(<span class="number">2</span>)</span><br><span class="line">	print(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line">	<span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">t=test()</span><br><span class="line">print(next(t))</span><br><span class="line">print(next(t))</span><br><span class="line">print(next(t))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">step 2</span><br><span class="line">2</span><br><span class="line">step 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-04｜复习</title>
    <url>/2022/02/09/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-04%EF%BD%9C%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p>
<p>标准库：os、random、time、datetime</p>
<a id="more"></a>
<h2 id="一-os模块"><a class="markdownIt-Anchor" href="#一-os模块"></a> 一、os模块</h2>
<p>os模块是提供的接口可以实现跨平台访问。但有些例外。</p>
<h3 id="1-系统相关"><a class="markdownIt-Anchor" href="#1-系统相关"></a> 1. 系统相关</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.name <span class="comment"># 查看当前操作系统的命令，win--&gt;nt linux--&gt;posix</span></span><br><span class="line">os.environ <span class="comment"># 获取环境变量</span></span><br></pre></td></tr></table></figure>
<h3 id="2-文件和目录操作"><a class="markdownIt-Anchor" href="#2-文件和目录操作"></a> 2. 文件和目录操作</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd() <span class="comment">## 来获取当前工作目录</span></span><br><span class="line">os.chdir(<span class="string">&#x27;dirname&#x27;</span>) <span class="comment">## 相当于shell下的cd，改变当前脚本的目录</span></span><br><span class="line">os.remove(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">os.rename(<span class="string">&#x27;oldname&#x27;</span>,<span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)</span><br><span class="line">os.path.abspath(<span class="string">&#x27;dirname&#x27;</span>) <span class="comment">## 返回绝对路</span></span><br></pre></td></tr></table></figure>
<h3 id="3-执行命令"><a class="markdownIt-Anchor" href="#3-执行命令"></a> 3. 执行命令</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;command&#x27;</span>)</span><br><span class="line">os.popen(<span class="string">&#x27;command&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>两者区别是，前者指返回一个状态码，没有任何其他输出内容。后者会返回command的结果。比如我要执行<code>ls</code>这样的shell命令，就需要时候后者。</p>
<h2 id="二-random"><a class="markdownIt-Anchor" href="#二-random"></a> 二、random</h2>
<p>生成随机函数。该模块有在智能快递柜项目中应用：生成六位随机密码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 0～1浮点数</span></span><br><span class="line">random.random()</span><br><span class="line"><span class="comment">#2 指定范围浮点数</span></span><br><span class="line">random.uniform(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">#3 指定范围整数</span></span><br><span class="line">random.randint(<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">#4 固定间隔的随机数</span></span><br><span class="line">random.randrange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#5 在固定的sequence中随机生成</span></span><br><span class="line">random.choice([<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;cdd&#x27;</span>])</span><br><span class="line"><span class="comment">#6 打乱列表元素</span></span><br><span class="line">ll=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line">print(ll)</span><br><span class="line"><span class="comment">#5 切片返回随机固定长度</span></span><br><span class="line">random.sample(<span class="string">&#x27;list&#x27;</span>,num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：#6中不能直接<code>print('random.shuffle(list)')</code>，该库的作用是打乱列表元素，是直接作用于改变列表的，并不会有任何返回值。</p>
<h3 id="三-time时间模块"><a class="markdownIt-Anchor" href="#三-time时间模块"></a> 三、time时间模块</h3>
<p>只支持到2038年，需要更换到datetime。</p>
<p>在python中有三种方式来表示时间：时间戳、格式化时间字符串、结构化时间。</p>
<h3 id="1-时间戳"><a class="markdownIt-Anchor" href="#1-时间戳"></a> 1. 时间戳</h3>
<p>时间戳在<a href="https://blog.tangspoon.cn/2021/12/06/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%BD%AC%E5%8F%91B%E7%AB%99UP%E4%B8%BB%E5%8A%A8%E6%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1python%E8%84%9A%E6%9C%AC/">《原创｜转发B站UP主动态到微信python脚本》</a>有相关应用，可以通过<code>time.time()</code>获得。获得时间戳后可有用<code>time.localtime(time.time())</code>来转化为结构化时间。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220209155458114.png" alt="image-20220209155458114" style="zoom:50%;" />
<p>时间戳可做算术运算：计算程序运行时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">	time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">t1=time.time()</span><br><span class="line">func()</span><br><span class="line">t2=time.time()</span><br><span class="line">print(t2-t1)</span><br></pre></td></tr></table></figure>
<h3 id="2-结构化时间struct_time"><a class="markdownIt-Anchor" href="#2-结构化时间struct_time"></a> 2. 结构化时间(struct_time)</h3>
<p>一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code></p>
<p>注意：<code>time.localtime()</code>的作用是格式化时间戳为本地时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lt = time.localtime()</span><br><span class="line">print(lt[:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># (2022, 2, 9)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-格式化时间字符串"><a class="markdownIt-Anchor" href="#3-格式化时间字符串"></a> 3. 格式化时间字符串</h3>
<p>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>类似的方式即可获得格式化时间的字符串。</p>
<p>比如我用<code>time.localtime(time.time())</code>获得了具有结构化时间，现在我要格式化成我想要的时间格式：20220101，我可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct_time&#x3D;time.localtime(time.time())</span><br><span class="line">time.strftime(&#39;%Y%m%d&#39;,struct_time)</span><br></pre></td></tr></table></figure>
<h3 id="4-反向格式化"><a class="markdownIt-Anchor" href="#4-反向格式化"></a> 4. 反向格式化</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=<span class="string">&#x27;20220901&#x27;</span></span><br><span class="line">st=time.strptime(t,<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment">#输出time.struct_time(tm_year=2022, tm_mon=9, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=244, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>t</code>和<code>st</code>里面的格式必须相同。比如<code>t</code>的年月日使用<code>-</code>隔开，那么<code>%Y-%m</code></p>
<h3 id="四-datetime"><a class="markdownIt-Anchor" href="#四-datetime"></a> 四、datetime</h3>
<p>time和datetime的区别：前者到1970～2038年，后者比前者高级了不少，可以理解为是对前者进行了封装，提供了更多的实用函数。</p>
<p>主要包含有几个类别：</p>
<ul>
<li>
<ol>
<li>time：只关注时间</li>
</ol>
</li>
<li>
<ol start="2">
<li>date：只关注日期</li>
</ol>
</li>
<li>
<ol start="3">
<li>datetime：以上两者都有</li>
</ol>
</li>
<li>
<ol start="4">
<li>timedelta：计算时间跨度</li>
</ol>
</li>
<li>
<ol start="5">
<li>tzinfo：时区</li>
</ol>
</li>
</ul>
<p>注意：几个类别都是属于datetime模块的函数，都需要导入使用。</p>
<p>实际使用中，用的比较多的是<code>3</code>和<code>4</code>，<code>1、2</code>和<code>3</code>并没有太大区别，也就是说基本可以取代。</p>
<p>所以，我上面图片中的代码其实可以更好的优化为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过time.time()获得当前时间戳,通过fromtimestamp转换成date</span></span><br><span class="line">dt=date.fromtimestamp(time.time())</span><br><span class="line">print(dt.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>N1盒子折腾记</title>
    <url>/2021/12/18/N1%E7%9B%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0/</url>
    <content><![CDATA[<p>这段时间看到树莓派涨价太厉害，然后感觉我的树莓派3b+好像吃灰了一段时间，还有性能实在太过剩。之前有留意到斐讯的N1盒子性能也很强，也可以刷armbian，其实是可以用来替代树莓派的。在pdd 110💰入手了一台，包电源。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211218121833554.png" alt="image-20211218121833554" style="zoom:33%;" />
<a id="more"></a>
<h2 id="一-刷机armbian"><a class="markdownIt-Anchor" href="#一-刷机armbian"></a> 一、刷机armbian</h2>
<p>在pdd手上拿回来的是<code>openwrt</code>，但我还是喜欢armbian多一点，因为可自定义程度可以非常高。所以本教程是在openwrt的基础上刷armbian。刷其他系统大同小异，都是先制作好系统U盘👉插入N1盒子👉开机👉执行sh脚本或者nand-sata-install写入emmc。</p>
<h3 id="1-前期准备"><a class="markdownIt-Anchor" href="#1-前期准备"></a> 1. 前期准备</h3>
<h4 id="11-物料"><a class="markdownIt-Anchor" href="#11-物料"></a> 1.1 物料</h4>
<p>HDMI线、16g U盘（不需要usb公对公）</p>
<h4 id="12-系统-577-debian"><a class="markdownIt-Anchor" href="#12-系统-577-debian"></a> 1.2 系统 5.77 Debian</h4>
<p><a href="https://pan.baidu.com/s/1kivlyMxyiZfGG3YTMI4NMw">https://pan.baidu.com/s/1kivlyMxyiZfGG3YTMI4NMw</a></p>
<p>提取码: e3cm</p>
<p><strong>强烈不建议选择Ubuntu的桌面版！强烈不建议选择Ubuntu的桌面版！因为到后面的python脚本和crontab会有问题。用 5.77 Debian 命令版5分钟就刷完，后期安装任何工具和依赖都非常快速。反倒Ubuntu桌面版有一大堆的问题。</strong></p>
<h4 id="13-其他工具下载"><a class="markdownIt-Anchor" href="#13-其他工具下载"></a> 1.3 其他工具下载</h4>
<p>U盘系统制作工具：<a href="https://www.balena.io/etcher/">balenaEtcher</a></p>
<p>dbt文件：在5.77 Debian下载链接里面有</p>
<h3 id="2-制作系统u盘"><a class="markdownIt-Anchor" href="#2-制作系统u盘"></a> 2. 制作系统U盘</h3>
<h4 id="21-烧录"><a class="markdownIt-Anchor" href="#21-烧录"></a> 2.1 烧录</h4>
<p>这一步直接使用balenaEtcher烧录就行，非常简单。</p>
<h4 id="22-拷贝dbt文件"><a class="markdownIt-Anchor" href="#22-拷贝dbt文件"></a> 2.2 拷贝dbt文件</h4>
<p>在烧录后的U盘里面，有个dbt文件夹。把下载下来的dbt文件👉复制到U盘的dbt文件夹内</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122227863.png" alt="image-20211218122227863" /></p>
<h4 id="23-修改uenv文件"><a class="markdownIt-Anchor" href="#23-修改uenv文件"></a> 2.3 修改uEnv文件</h4>
<p>在U盘系统目录里，有个uEnv.ini文件，把data_name=xxx修改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtb_name&#x3D;&#x2F;dtb&#x2F;meson-gxl-s905d-phicomm-n1-xiangsm.dtb</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122320412.png" alt="image-20211218122320412" /></p>
<p><strong>至此，启动U盘制作完成。</strong></p>
<h2 id="二-写入emmc"><a class="markdownIt-Anchor" href="#二-写入emmc"></a> 二、写入emmc</h2>
<p>插入U盘就会自动加载，debian默认是root，密码1234。后面会要你更改。</p>
<p>然后执行下面命令就可以写入emmc了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nand-sata-install</span><br></pre></td></tr></table></figure>
<p>网上有的教程说执行/root/install.sh可以，但还是建议以我上面的方式写入。</p>
<p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h2 id="三-其他配置"><a class="markdownIt-Anchor" href="#三-其他配置"></a> 三、其他配置</h2>
<p>Wi-Fi、时区、apt源等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">armbian-config</span><br></pre></td></tr></table></figure>
<p>到这里，N1盒子的armbian系统基本配置好啦～</p>
<h2 id="四-相关文章"><a class="markdownIt-Anchor" href="#四-相关文章"></a> 四、相关文章</h2>
<p><a href="https://yuerblog.cc/2019/10/23/%E6%96%90%E8%AE%AFn1-%E5%AE%8C%E7%BE%8E%E5%88%B7%E6%9C%BAarmbian%E6%95%99%E7%A8%8B/">斐讯N1 – 完美刷机Armbian教程</a>(建议阅读)</p>
<p><a href="https://www.twoeggz.com/info/745423.html">秒变万能家庭服务器！斐讯N1 armbian安装指南</a></p>
<p><a href="https://www.right.com.cn/forum/forum.php?mod=forumdisplay&amp;fid=158&amp;filter=typeid&amp;typeid=21">N1盒子Armbian-5.77 on N1, so far so good</a></p>
<p><a href="https://wh0.is/p/%E6%96%90%E8%AE%AFn1%E8%A3%85ubuntuarmbian-%E5%B0%B4%E5%B0%AC%E5%A4%8D%E6%B4%BB%E8%AE%B0%E5%BD%95/">斐讯N1装Ubuntu(Armbian)+尴尬复活记录</a></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-05｜查漏补缺</title>
    <url>/2022/02/05/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-05%EF%BD%9C%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323-20220209184953475.png" alt="image-20211208153223437" /></p>
<p>数据类型和变量、递归、切片、range</p>
<a id="more"></a>
<h2 id="一-基础"><a class="markdownIt-Anchor" href="#一-基础"></a> 一、基础</h2>
<h3 id="1-数据类型和变量"><a class="markdownIt-Anchor" href="#1-数据类型和变量"></a> 1. 数据类型和变量</h3>
<h4 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h4>
<p>对于很大的数，可以用100_000_000表示</p>
<h4 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h4>
<p>会出现四舍五入的情况</p>
<h4 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h4>
<ul>
<li>
<p>转义字符：\ +需要转的字符。例如我要在’ '里输出&quot;&quot;，\&quot;即可</p>
</li>
<li>
<p><strong>r’ '内部的不会被转义</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;111&#x27;</span><span class="string">r&#x27;\t&#x27;</span><span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line"><span class="comment"># 111\t1111</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多行输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;&#x27;&#x27;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行</span></span><br><span class="line">第二行</span><br><span class="line">第三行</span><br></pre></td></tr></table></figure>
<h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4>
<p>变量在内存中的表示</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220208141522481.png" alt="image-20220208141522481" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220208141533655.png" alt="image-20220208141533655" /></p>
</li>
</ul>
<h3 id="2-编码"><a class="markdownIt-Anchor" href="#2-编码"></a> 2. 编码</h3>
<p>ASCII是美国一开始设计计算机制定的，用不了其他语言。Unicode可以解决所有语言的编码问题，但是长度是固定的。UTF-8是可变的，可以节省许多空间。</p>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就要转化为UTF-8编码。所以在当你打开一个txt文件时，计算机会把UTF-8的文件转换为Unicode的，然后交给内存处理，当编辑完成后，再转换为UTF-8保存到硬盘。</p>
<h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4>
<h5 id="s"><a class="markdownIt-Anchor" href="#s"></a> %s</h5>
<p>最方便的格式化方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;name:%s,age:%s&#x27;</span> %(<span class="string">&#x27;tang&#x27;</span>,<span class="number">25</span>))</span><br></pre></td></tr></table></figure>
<p>在python中，当<code>%</code>是个普通字符时，需要加多一个%来显示。例如我需要输出<code>7%</code>时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;%s%%&#x27;</span> %<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h5 id="f-string"><a class="markdownIt-Anchor" href="#f-string"></a> f-string</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># f&#x27;&#123;变量&#125;&#x27;</span></span><br><span class="line">r=<span class="number">3</span></span><br><span class="line">s=<span class="number">22</span>*r</span><br><span class="line">print(<span class="string">f&#x27;r is:<span class="subst">&#123;r&#125;</span>,s is:<span class="subst">&#123;s&#125;</span>)</span></span><br></pre></td></tr></table></figure>
<p>#####保留小数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.1f 一位</span><br><span class="line">.2f 两位</span><br></pre></td></tr></table></figure>
<h3 id="3-list和tuple"><a class="markdownIt-Anchor" href="#3-list和tuple"></a> 3. list和tuple</h3>
<h4 id="list的增删改"><a class="markdownIt-Anchor" href="#list的增删改"></a> list的增删改</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line">list.append()</span><br><span class="line">list.insert(i,string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">list.pop() <span class="comment">#删除最后一个</span></span><br><span class="line">list.pop(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">list[i]=string</span><br></pre></td></tr></table></figure>
<h4 id="tuple的特性"><a class="markdownIt-Anchor" href="#tuple的特性"></a> tuple的特性</h4>
<ul>
<li>不能更改</li>
<li>优点：安全。能用tuple即用tuple</li>
</ul>
<p>不过注意</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t=(<span class="number">1</span>) <span class="comment">#代表的是整数1，不是tuple只有1这个元素</span></span><br><span class="line"><span class="comment">#正确表示应该是在后面加个逗号</span></span><br><span class="line">t=(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure>
<p>可变的tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;(1,2,[&#39;a&#39;,&#39;b&#39;])</span><br><span class="line">t[2][0]&#x3D;&#39;A&#39;</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<h4 id="dict和set"><a class="markdownIt-Anchor" href="#dict和set"></a> dict和set</h4>
<p>具体在《草根学python》复习中查看。</p>
<h3 id="4运算符"><a class="markdownIt-Anchor" href="#4运算符"></a> 4.运算符</h3>
<h4 id="身份运算符-is-is-not"><a class="markdownIt-Anchor" href="#身份运算符-is-is-not"></a> 身份运算符 is 、is not</h4>
<p>判断两个表示符是不是引用自同一个对象，就像<code>id(x)==id(y)</code>一个道理。</p>
<p>而<code>==</code>则是判断两个<code>值</code>是否相等。</p>
<h2 id="二-函数-递归"><a class="markdownIt-Anchor" href="#二-函数-递归"></a> 二、函数-递归</h2>
<p>递归知识重复执行操作的方法。只需要理解到最小规模的逻辑，设计出等价关系式即可。</p>
<p>递归的特征：自己调用自己，有一定的结束条件，效率不高</p>
<p>斐波函数</p>
<blockquote>
<p>1,1,2,3,5,8,13</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非递归方法（普通循环）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">        temp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = temp</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"><span class="comment"># 核心思想就是把a,b从第一位开始，整体向后移一位。a=b，b=temp就可以实现整体向后移的目的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">## 结束条件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib2(n<span class="number">-2</span>)+fib2(n<span class="number">-1</span>) <span class="comment">## 等价关系式</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure>
<p>可以看到两种算法的思想是不一样的。非递归方法需要抽象出一定的规律，根据这个规律来设计算法。比如上面的a,b整体向后移，根据这个规律来设计出用一个temp来储存后面b需要的数据。而递归的思想是指设计出口和缩小规模的逻辑，具体后面怎么实现不管。比如上面我们只需要想清楚是前一个数+后一个数即可，那么我们就可以直接设计出<code>fib(n-1)+fib(n-2)</code>这种超级简约的算法。</p>
<p>关于递归的最好理解是来自知乎的一篇文章：<a href="https://www.zhihu.com/question/31412436">对于递归有没有什么好的理解方法？</a></p>
<blockquote>
<h3 id="递归的三大要素"><a class="markdownIt-Anchor" href="#递归的三大要素"></a> 递归的三大要素</h3>
<p><strong>第一要素：明确你这个函数想要干什么</strong></p>
<p><strong>第二要素：寻找递归结束条件</strong></p>
<p>当n=1或者n=2时的一些特殊情况</p>
<p><strong>第三要素：找出函数的等价关系式</strong>(最难)</p>
<p>求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少</p>
</blockquote>
<h2 id="三-高级特性"><a class="markdownIt-Anchor" href="#三-高级特性"></a> 三、高级特性</h2>
<h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3>
<p>应用于<code>list</code>和<code>tuple</code>取部分元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list&#x3D;[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p>取前面三个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list[0,3]</span><br></pre></td></tr></table></figure>
<p>取倒数第一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list[-1]</span><br></pre></td></tr></table></figure>
<p>取倒数两个（就是从<code>-2</code>一直到最后）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list[-2:]</span><br></pre></td></tr></table></figure>
<p>前十个，每两个取一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list[:<span class="number">10</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>所有数，每5个取一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(l[::5])</span><br></pre></td></tr></table></figure>
<h2 id="四-range"><a class="markdownIt-Anchor" href="#四-range"></a> 四、range()</h2>
<p>range(start,stop,step)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">range(100,0,-1) # 从100倒数回0，每次步进1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-06｜算法-排序</title>
    <url>/2022/02/12/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-06%EF%BD%9C%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220212144332679.png" alt="image-20220212144332679" style="zoom:85%;" />
<p>冒泡、选择、插入、快速排序</p>
<a id="more"></a>
<blockquote>
<h3 id="排序算法的稳定性"><a class="markdownIt-Anchor" href="#排序算法的稳定性"></a> 排序算法的稳定性</h3>
<p>排序算法的稳定性是指，在排序过程中，值相同的元素间的相对位置跟排序前的相对位置是一样的。举个例子，排序前一个数组为{3, 2, 1, 2’, 4}，我们用2’来区分第二个2和第一个2，假如是稳定的排序算法，它的结果一定是这样{1, 2, 2’, 3, 4}，而如果不稳定的算法，它的结果有可能是这样{1, 2’, 2, 3, 4}。</p>
<p>为什么我们要强调稳定性呢？举个例子，假如我们需要排序一个订单，需要按照时间和价格进行升序排序，首先会先将所有订单按时间升序排序，然后再进行价格的升序排序，假如价格排序不是一个稳定的排序，那么订单的时间就有可能不会按升序排列，所以在特定情况下，排序算法的稳定性是一个比较重要的考虑因素。</p>
<p>作者：特雷西多士<br />
链接：<a href="https://juejin.cn/post/6844903966514348040">https://juejin.cn/post/6844903966514348040</a><br />
来源：稀土掘金<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="一-冒泡排序"><a class="markdownIt-Anchor" href="#一-冒泡排序"></a> 一、冒泡排序</h3>
<blockquote>
<p>参考：<a href="https://github.com/facert/python-data-structure-cn/tree/master/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2">https://github.com/facert/python-data-structure-cn/tree/master/5.排序和搜索</a></p>
</blockquote>
<p>「冒泡」这个命名十分形象：越小的元素会逐渐冒泡到数列的前端。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220211111950717.png" alt="image-20220211111950717" /></p>
<p>缺点：低效</p>
<ul>
<li>每个数据都得经过若干次交换才能找到自己的位置。特别是对于大号靠前的数据。</li>
<li>假如数组在冒泡排序的途中已经排好了正确的顺序，算法还是会迭代到最后一个元素，浪费性能和时间。</li>
</ul>
<p>优点：稳定性好</p>
<p>因为只有当两个数不相等时才会交换，所以例如像5和5`这样的（前后不一样，值一样）是不会交换的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">data</span>):</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> data[i]&gt;data[i+<span class="number">1</span>]:</span><br><span class="line">                data[i],data[i+<span class="number">1</span>]=data[i+<span class="number">1</span>],data[i]</span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">bubbleSrot(data)</span><br><span class="line">print(<span class="string">&#x27;冒泡排序：&#x27;</span>, data)</span><br></pre></td></tr></table></figure>
<h3 id="二-选择排序"><a class="markdownIt-Anchor" href="#二-选择排序"></a> 二、选择排序</h3>
<blockquote>
<p>参考：<a href="https://github.com/facert/python-data-structure-cn/tree/master/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2">https://github.com/facert/python-data-structure-cn/tree/master/5.排序和搜索</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span>(<span class="params">data</span>):</span></span><br><span class="line">	<span class="keyword">for</span> now_len <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">    temp_location=<span class="number">0</span></span><br><span class="line">    	<span class="keyword">for</span> now_location <span class="keyword">in</span> range(<span class="number">1</span>,now_len+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[now_location]&gt;data[temp_location]:</span><br><span class="line">                temp_location=now_location</span><br><span class="line">                </span><br><span class="line">data[temp_location],data[now_location]=data[now_location],data[temp_location]</span><br><span class="line">     </span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">bubbleSrot(data)</span><br><span class="line">print(<span class="string">&#x27;选择排序：&#x27;</span>, data)  </span><br></pre></td></tr></table></figure>
<h3 id="三-插入排序"><a class="markdownIt-Anchor" href="#三-插入排序"></a> 三、插入排序</h3>
<p>目前个人觉得最好理解的教程是Derrick Sherril这位YouTuber</p>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=byHi41L9vTM">https://www.youtube.com/watch?v=byHi41L9vTM</a></p>
</blockquote>
<p>直接上代码，狗都能看懂。其实就是当数列前一个大于后一个的时候，两个数字交换。但为了持续比较，需要在一个<code>while</code>里面不断判断，每次<code>i-1</code>就可以遍历前面的<code>unsorted</code>的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(data)):</span><br><span class="line">        <span class="keyword">while</span> data[i<span class="number">-1</span>]&gt;data[i] <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            data[i<span class="number">-1</span>],data[i] = data[i], data[i<span class="number">-1</span>]</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">insertSrot(data)</span><br><span class="line">print(<span class="string">&#x27;插入排序：&#x27;</span>, data) </span><br></pre></td></tr></table></figure>
<h3 id="四-快速排序递归排序"><a class="markdownIt-Anchor" href="#四-快速排序递归排序"></a> 四、快速排序（递归排序）</h3>
<p>快速排序的最简单解释同样来自Derrick Sherril</p>
<blockquote>
<p>解学武之快速排序：<a href="https://www.youtube.com/watch?v=kFeXwkgnQ9U">https://www.youtube.com/watch?v=kFeXwkgnQ9U</a></p>
</blockquote>
<p>以随便一个数为标准，Derrick用了最后一个。提取出标准数，遍历数组剩下的值，比标准数小的放在左边，大的在右。然后一直递归下去就可以。结束条件是不用比较的最小规模：当数组只剩下1个或0个的时候。这时我们直接返回长度只有1个或0个的数组即可。</p>
<p>另外有个讲算法很详细的网站：</p>
<blockquote>
<p><a href="http://data.biancheng.net/view/117.html">http://data.biancheng.net/view/117.html</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = data.pop()</span><br><span class="line"></span><br><span class="line">    items_bigger = []</span><br><span class="line">    items_smaller = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> item &lt; pivot:</span><br><span class="line">            items_smaller.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items_bigger.append(item)</span><br><span class="line">    <span class="keyword">return</span> quickSort(items_smaller) + [pivot] + quickSort(items_bigger)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;快速排序：&#x27;</span>, quickSort(data))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="五-其他"><a class="markdownIt-Anchor" href="#五-其他"></a> 五、其他</h3>
<p>其他还有归并排序和希尔排序。日后在Coursera的Data Structrues课程中再深入学习。</p>
<blockquote>
<p><a href="https://www.coursera.org/learn/python-data?action=enroll">https://www.coursera.org/learn/python-data?action=enroll</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志-07｜数据结构</title>
    <url>/2022/02/14/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-07%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220212213658145.png" alt="image-20220212213658145" style="zoom:50%;" />
<p>栈、单链表。</p>
<p>会进修 Coursera 的 Data Structures 课程，日后完善丰富。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>学习数据结构的好助手：<a href="https://pythontutor.com/">Python Tutor</a>。可以展示python代码的每一步执行。</li>
<li>非常好的博客：<a href="https://nemo.cool/254.html">多种数据结构的python实现形式</a></li>
<li><a href="https://github.com/facert/python-data-structure-cn/tree/master/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8">python-data-structrue-cn</a></li>
<li><a href="https://codingdict.com/article/4850">CodingDict的Python数据结构</a></li>
</ol>
</blockquote>
<p>理解：数据结构：数据以哪种方式、组织形式存储在电脑中，每一种储存方式都有其特点。</p>
<p>在设计一个程序/模块前，通常需要选择好数据结构，然后再设计算法。举个不太恰当的例子：我在做网易云闹钟时，需要储存<code>uid</code>和<code>url</code>，使用列表存储和读取都比较缓慢，但使用字典就非常快速的。（列表是数据结构「序列」的一种类型，而字典则是一种「可变形容器」。关于数据类型和数据结构的区别可详细查看知乎的提问：<a href="https://www.zhihu.com/question/21165020">「数据结构」和「数据类型」两个概念的本质，区别与联系</a>。里面一位叫「沈兄」的回答很好理解。）</p>
<h2 id="一-栈"><a class="markdownIt-Anchor" href="#一-栈"></a> 一、栈</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20220210102612544.png" alt="image-20220210102612544" style="zoom: 50%;" />
<ul>
<li>也叫后进先出表</li>
<li>栈顶top：插入删除操作的顶端</li>
<li>栈底bottom</li>
<li>栈元素个数为0时：空栈</li>
<li>插入：push</li>
<li>删除：pop</li>
<li>时间复杂度为O（1）</li>
</ul>
<p>我们用python来构造出栈这个数据结构：进栈、出栈、查看最顶元素、判断是否为空、返回栈的大小。</p>
<p>实现原理就是用数组以左为基点，逆时针旋转90度，结合数组的append和pop操作，就是一个栈了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, limit=<span class="number">10</span></span>):</span></span><br><span class="line">        self.stack = []  <span class="comment"># 存放元素</span></span><br><span class="line">        self.limit = limit  <span class="comment"># 栈容量极限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span>  <span class="comment"># 判断栈是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) &gt;= self.limit:</span><br><span class="line">            print(<span class="string">&#x27;StackOverflowError&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;pop from an empty stack&#x27;</span>)  <span class="comment"># 空栈不能被弹出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span>  <span class="comment"># 查看堆栈的最上面的元素</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span>  <span class="comment"># 判断栈是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.stack)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span>  <span class="comment"># 返回栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br></pre></td></tr></table></figure>
<p>题目：根据栈的结构特点，检查括号是否完全匹配。</p>
<p>我们可以利用「左括号」进栈，在遍历到「右括号」时，就出栈。括号匹配的情况是：当pop完最后一个元素后，栈是empty的，这种情况就是True的。括号不匹配有两种情况：左括号&gt;右括号，左括号&lt;右括号。第一种栈is not empty的时候就是不匹配的。第二种当栈is empty的时候括号不匹配。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接上面的stack代码。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balanced_parenthesses</span>(<span class="params">parenthesses</span>):</span></span><br><span class="line">	stack=Stack(len(parenthesses))</span><br><span class="line">    <span class="keyword">for</span> parenthess <span class="keyword">in</span> parenthesses:</span><br><span class="line">        <span class="keyword">if</span> parenthess==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.push(parenthess)</span><br><span class="line">        <span class="keyword">elif</span> parenthess==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack.is_empty:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> stack.is_empty </span><br><span class="line">	<span class="comment"># 如果True就是对称的。对称的情况是左括号刚好被pop完，没有右括号了，直接跳出循环判断是否为空即可。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    examples = [<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;((())&#x27;</span>, <span class="string">&#x27;()))&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;Balanced parentheses demonstration:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> examples:</span><br><span class="line">        print(example + <span class="string">&#x27;: &#x27;</span> + str(balanced_parentheses(example)))</span><br></pre></td></tr></table></figure>
<h2 id="二-链表"><a class="markdownIt-Anchor" href="#二-链表"></a> 二、链表</h2>
<h3 id="1-单链表"><a class="markdownIt-Anchor" href="#1-单链表"></a> 1. 单链表</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/chenmozhe22/article/details/108751941">Python—链表基础（小白入门系列）—节点 &amp; 单向链表</a></p>
</blockquote>
<h4 id="链表组成"><a class="markdownIt-Anchor" href="#链表组成"></a> 链表组成</h4>
<p>链表实际上由两部分组成：head 和 节点node。head永远指向第一个node；node由元素和下一节点的指向next两部分组成。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220212155951415.png" alt="image-20220212155951415" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220212155924559.png" alt="image-20220212155924559" /></p>
<h4 id="链表的用处优势和劣势"><a class="markdownIt-Anchor" href="#链表的用处优势和劣势"></a> 链表的用处（优势和劣势）</h4>
<p>对于列表，是一块大的连续内存空间，每次初始化都需要开辟一大块内存，空间利用率低。更重要的是，插入一个元素，所有其他元素的位置都变了。所以在插入、删除元素的时候效率比较低。</p>
<p>优势：</p>
<ul>
<li>链表是非连续的内存空间，每个节点单独存在自己的内存空间，通过指针指向下一个节点。</li>
<li>如果在某个地方插入一个节点，只需要改变指针的指向即可，不用其他元素都变动。</li>
</ul>
<p>劣势：</p>
<ul>
<li>每次查找一个元素，都必须从头指针开始一个一个往下查找。</li>
<li>如果中间某个节点指向断开，那错误节点后面的所有其他节点就都找不到了。</li>
</ul>
<p>从上面可以看出，插入数据 链表胜于列表。</p>
<p>我们在明白了链表的组成之后，我们用python来实现实现该数据结构。</p>
<h4 id="node节点的理解"><a class="markdownIt-Anchor" href="#node节点的理解"></a> node节点的理解</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创造一个node类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleNode</span>(<span class="params">object</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="comment"># item存放数据元素</span></span><br><span class="line">        self.item=item</span><br><span class="line">        <span class="comment"># next是下一个节点node的指向</span></span><br><span class="line">    	self.next=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>我们尝试利用链表的原理，来应用一下next的指向</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">node1 = singleNode(<span class="number">5</span>)</span><br><span class="line">node2 = singleNode(<span class="number">8</span>)</span><br><span class="line">node1.next = node2</span><br><span class="line">print(node1.item) <span class="comment"># 5</span></span><br><span class="line">print(node1.next.item) <span class="comment"># 8</span></span><br><span class="line">print(node2) </span><br></pre></td></tr></table></figure>
<p>由<code>line5</code>输出8，可以知道我们是可以通过<code>node1</code>来实现<code>node2</code>的输出的，表示链接成功。</p>
<p><code>line3</code>的作用很重要：把<code>node1</code>指向<code>node2</code>。其实就是把<code>node2</code>的内存地址赋值给<code>node1.next</code>。</p>
<h4 id="添加节点的真实过程"><a class="markdownIt-Anchor" href="#添加节点的真实过程"></a> 添加节点的真实过程</h4>
<p>链表对象具有的功能必须有：添加节点。但添加节点应该是先把新元素指向给<code>node1</code>，然后再把<code>head</code>移动到新元素上。如果先移动<code>head</code>，新的元素还没有指向<code>node1</code>，这时候指向已经断裂了。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220212170801427.png" alt="image-20220212170801427" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220212170828666.png" alt="image-20220212170828666" /></p>
<p>下面我们开始定义链表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleLinkedlist</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># 新node</span></span><br><span class="line">        node = singleNode(item)</span><br><span class="line">        <span class="comment"># 先把新的链接域指向头及节点，也就是__head的指向位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="comment"># 将链表的头__head指向新节点</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_first_node</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = singleLinkedlist()</span><br><span class="line">s.add(<span class="number">6</span>)</span><br><span class="line">s.add(<span class="number">1</span>)</span><br><span class="line">fn=s.get_first_node()</span><br><span class="line">print(fn.item)</span><br></pre></td></tr></table></figure>
<p>有些概念要明确：在设计程序时，我们应该以程序最小规模来思考设计。我们设计<code>add()</code>方法，链表的最小规模是一个节点都没有。所以<code>add()</code>方法可以这样思考：在创建了一个新node之后，就先处理这个node的指向next（不然就断了连接），也就是指向下一个<strong>node的地址：其实就是head</strong>。然后移动head指向node的地址。</p>
<h4 id="链表的其他方法"><a class="markdownIt-Anchor" href="#链表的其他方法"></a> 链表的其他方法</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># 判断是否为空</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">	<span class="keyword">return</span> self.__head=<span class="literal">None</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 计算长度</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">       count=<span class="number">0</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           count+=<span class="number">1</span></span><br><span class="line">           cur=cur.next <span class="comment"># cur.next代表下一个元素，所以这个操作代表着__head的后移</span></span><br><span class="line">           </span><br><span class="line">       <span class="keyword">return</span> count</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 遍历链表的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           print(cur.item)</span><br><span class="line">           cur=cur.next</span><br><span class="line">           </span><br><span class="line">   <span class="comment"># 在末尾添加节点</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self</span>):</span></span><br><span class="line">       node=singleLinkedlist()</span><br><span class="line">       <span class="keyword">if</span> self.is_empty():</span><br><span class="line">           self.__head=node</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur=self.__haed</span><br><span class="line">           <span class="keyword">while</span> cur.next!=<span class="literal">None</span>: <span class="comment"># 最后一个node的node.next是None</span></span><br><span class="line">               cur=cur.next</span><br><span class="line">           cur.next=node</span><br><span class="line"><span class="comment"># 插入节点</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,pos,item</span>):</span></span><br><span class="line">       <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入，也就是一开始写的add操作</span></span><br><span class="line">       <span class="keyword">if</span> pos&lt;=<span class="number">0</span>:</span><br><span class="line">           self.add(item)</span><br><span class="line">       <span class="keyword">elif</span> pos&gt;(self.length()<span class="number">-1</span>): <span class="comment"># 尾部</span></span><br><span class="line">           self.pop(item)</span><br><span class="line">       <span class="keyword">else</span>: <span class="comment"># 中部</span></span><br><span class="line">           node = singleLinkedlist(item)</span><br><span class="line">           cur=self.__head</span><br><span class="line">           count=<span class="number">0</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span> count&lt;(pos<span class="number">-1</span>):</span><br><span class="line">               count+=<span class="number">1</span></span><br><span class="line">               cur=cur.next</span><br><span class="line">               </span><br><span class="line">           node.next=cur.next <span class="comment"># 先把新node指向pos的后一个数,也就是cur.next</span></span><br><span class="line">           cur.next=node <span class="comment"># 然后再把在pos的node指向新node</span></span><br><span class="line">   <span class="comment"># 查找    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,item</span>):</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">if</span> cur.item==item:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           cur=cur.next</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>由上面可以总结出几种操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cur=self.head</span><br><span class="line"><span class="comment"># cur.next 代表的是下一个node的一个整体</span></span><br><span class="line"><span class="comment"># head 代表当前的node</span></span><br><span class="line"><span class="comment"># 指针移动</span></span><br><span class="line">cur=cur.next <span class="comment"># 直接后一个的节点的地址传给了cur，这就达到了指针后移的目的。</span></span><br></pre></td></tr></table></figure>
<h3 id="2-双链表"><a class="markdownIt-Anchor" href="#2-双链表"></a> 2. 双链表</h3>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/chenmozhe22/article/details/108772812">Python—链表基础（小白入门系列）—节点 &amp; 双向链表</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>The following packages have unmet dependencies: Depends: xxx but is to be installed</title>
    <url>/2022/01/26/The-following-packages-have-unmet-dependencies-Depends-xxx-but-is-to-be-installed/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126144850057.png" alt="image-20220126144850057" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libxml2-dev : Depends: libxml2 (&#x3D; 2.9.3+dfsg1-1ubuntu0.7) but 2.9.4+dfsg1-7+deb10u2 is to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure>
<p>今天在安装shairplay的时候出现了以上问题</p>
<p>原因是以来版本不一样</p>
<p>解决方法很简单——卸载、重装即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt remove libxml2-dev</span><br><span class="line">apt install libxml2-dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>frp内网穿透怎么用？｜访问内网web项目</title>
    <url>/2022/02/11/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BD%9C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211224213850815.png" alt="image-20211224213850815" style="zoom:35%;" />
<p>想做一个智能快递柜，想法是快递员扫码进入网页，输入信息验证成功后，香橙派就控制打开电磁锁。因为对esp和MQTT协议不熟悉，所以只能选择香橙派+内网穿透曲线救国的方式实现效果。当然，成本也会高很多。（esp几块钱，香橙派二手70+）</p>
<a id="more"></a>
<h2 id="一-服务端"><a class="markdownIt-Anchor" href="#一-服务端"></a> 一、服务端</h2>
<p>服务端应用在vps。（如果是arm系统，需要更改wget的地址）</p>
<h3 id="1-拉取源代码修改配置"><a class="markdownIt-Anchor" href="#1-拉取源代码修改配置"></a> 1. 拉取源代码&amp;修改配置</h3>
<p>（我这个是0.38版本）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.38.0&#x2F;frp_0.38.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line">mv frp_0.38.0_linux_amd64 frps</span><br><span class="line">cd frps</span><br><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20211224202926625.png" alt="image-20211224202926625" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">dashboard_port &#x3D; 7500</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">vhost_http_port &#x3D; 8443</span><br></pre></td></tr></table></figure>
<p><code>bind_port</code>：server端和client端对接端口</p>
<p><code>dashboard_port</code>：frp面板端口</p>
<p><code>vhost_http_port</code>：http服务端口</p>
<h3 id="2-放行端口"><a class="markdownIt-Anchor" href="#2-放行端口"></a> 2. 放行端口</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 8443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 7000 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 7500 -j ACCEPT</span><br><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.up.rules</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br></pre></td></tr></table></figure>
<h3 id="3-启动"><a class="markdownIt-Anchor" href="#3-启动"></a> 3. 启动</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;frps -c .&#x2F;frps.ini &gt; frps.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p><code>nohup</code>：可以把frps后台启动</p>
<blockquote>
<p>关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 关闭frp</span><br><span class="line">ps -aux|grep frp| grep -v grep</span><br><span class="line"># 找出进程id xxx</span><br><span class="line">kill -9 xxx</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211224211757919.png" alt="image-20211224211757919" /></p>
<h2 id="二-客户端"><a class="markdownIt-Anchor" href="#二-客户端"></a> 二、客户端</h2>
<p>同样也要下载0.38版本（要和服务端相同）</p>
<p>macOS下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_darwin_amd64.tar.gz">frp_0.38.0_darwin_amd64.tar.gz</a></p>
<p>linux下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz">frp_0.38.0_linux_amd64.tar.gz</a></p>
<p>Windows下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_windows_amd64.zip">frp_0.38.0_windows_amd64.zip</a></p>
<p>树莓派/香橙派下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_arm.tar.gz">frp_0.38.0_linux_arm.tar.gz</a></p>
<p><strong>我这里以macOS版演示</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.38.0&#x2F;frp_0.38.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.38.0_darwin_amd64.tar.gz</span><br><span class="line">mv frp_0.38.0_darwin_amd64 frpc</span><br><span class="line">cd frpc</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; xxxxx</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">type &#x3D; http</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 8443</span><br><span class="line">use_encryption &#x3D; false</span><br><span class="line">use_compression &#x3D; true</span><br><span class="line">custom_domains &#x3D; frp.xxxx.cn</span><br></pre></td></tr></table></figure>
<p><code>server_addr</code>：是服务端的ip，也就是vps的ip</p>
<p><code>server_port</code>：要和服务端填写的<code>bind_port</code>一致</p>
<p><code>local_port</code>：要和服务端填写的<code>vhost_http_port</code>一致</p>
<p><code>custom_domains</code>：服务端的ip/域名</p>
<h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c .&#x2F;frpc.ini &gt; frpc.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211224211909398.png" alt="image-20211224211909398" /></p>
<h3 id="三-面板"><a class="markdownIt-Anchor" href="#三-面板"></a> 三、面板</h3>
<p>访问地址：ip:7500</p>
<p>访问不了可能是没有放行端口</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211224212321698.png" alt="image-20211224212321698" /></p>
<p><strong>有个HTTP服务证明内网穿透已经成功</strong></p>
<hr />
<p>⚠️注意：内网web项目端口要和<code>vhost_http_port</code>保持一致</p>
<p><strong>实例</strong></p>
<p>使用<code>webpy</code>框架建立个demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装webpy</span><br><span class="line">python3 -m pip install web.py&#x3D;&#x3D;0.61</span><br></pre></td></tr></table></figure>
<p>在电脑桌面新建个<code>test.py</code>项目，内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import web</span><br><span class="line">import logging</span><br><span class="line"> </span><br><span class="line">urls&#x3D;(&#39;&#x2F;&#39;, &#39;Index&#39;)</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level&#x3D;logging.NOTSET)</span><br><span class="line"> </span><br><span class="line">app &#x3D; web.application(urls, globals())</span><br><span class="line"> </span><br><span class="line">class Index:</span><br><span class="line">    def GET(self):</span><br><span class="line">        logging.info(&#39;你好世界&#39;)</span><br><span class="line">        web.header(&#39;Content-Type&#39;, &#39;text&#x2F;html;charset&#x3D;UTF-8&#39;)</span><br><span class="line">        return &#39;你好世界&#39;</span><br><span class="line"> </span><br><span class="line">def notfound():</span><br><span class="line">    return web.notfound(&quot;Sorry, the page you were looking for was not found.&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.notfound &#x3D; notfound;</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>运行web项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python test.py <span class="number">8443</span></span><br></pre></td></tr></table></figure>
<p>⚠️注意：标明要8443端口</p>
<p>浏览器访问 ip:8443</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211224213434793.png" alt="image-20211224213434793" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211224213708050.png" alt="image-20211224213708050" /></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>智能快递柜</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<a id="more"></a>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux使用supervisor实现开机自启</title>
    <url>/2022/01/04/linux%E4%BD%BF%E7%94%A8supervisor%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220104144501685.png" alt="image-20220104144501685" style="zoom:30%;" />
<p>智能快递柜项目需要flask和内网穿透实现开机自启，使用supervisor非常方便。</p>
<a id="more"></a>
<p>相关Introduce在<a href="http://supervisord.org/introduction.html#overview">官网</a>有，这里只记录在<strong>香橙派</strong>armbian环境下的使用方法。</p>
<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<h3 id="查看项目安装位置"><a class="markdownIt-Anchor" href="#查看项目安装位置"></a> 查看项目安装位置</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis supervisor</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220104145552053.png" alt="image-20220104145552053" /></p>
<h3 id="配置conf"><a class="markdownIt-Anchor" href="#配置conf"></a> 配置conf</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;supervisor</span><br><span class="line"># 新建log方便下面使用</span><br><span class="line">touch supervisor.log</span><br><span class="line">vim supervisor.conf</span><br></pre></td></tr></table></figure>
<p>在文件最后添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:xxx]</span><br><span class="line">command&#x3D;xxxxxxx                                                  </span><br><span class="line">autostart&#x3D;true                                                                        </span><br><span class="line">autorestart&#x3D;true                                                             </span><br><span class="line">stdout_logfile &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;supervisor.log</span><br><span class="line">startsecs &#x3D; 5</span><br><span class="line">stopwaitsecs&#x3D;0</span><br></pre></td></tr></table></figure>
<p><code>line1</code>: 填写项目名称（例如我的是express_system）</p>
<p><code>line2</code>：执行脚本的命令（例如我的是python /root/express_system/app.py）</p>
<p><code>autostart</code>：在 supervisord 启动的时候也自动启动</p>
<p><code>autorestart</code>：程序异常退出后自动重启</p>
<p><code>startsecs</code>：启动 5 秒后没有异常退出，就当作已经正常启动了</p>
<p><code>stopwaitsecs</code>：停止等待时间</p>
<h3 id="重启"><a class="markdownIt-Anchor" href="#重启"></a> 重启</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure>
<h2 id="supervisor其他命令"><a class="markdownIt-Anchor" href="#supervisor其他命令"></a> supervisor其他命令</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 输入查看自启程序的状态</span><br><span class="line">supervisorctl</span><br><span class="line"></span><br><span class="line">#关闭所有任务</span><br><span class="line">supervisorctl shutdown</span><br><span class="line"></span><br><span class="line"># 启动某个进</span><br><span class="line">supervisorctl start programxxx</span><br><span class="line"></span><br><span class="line"># 重启某个进程</span><br><span class="line">supervisorctl restart programxxx</span><br><span class="line"></span><br><span class="line"># 停止全部进程 注：start、restart、stop都不会载入最新的配置文件</span><br><span class="line">supervisorctl stop all</span><br><span class="line"></span><br><span class="line"># 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。</span><br><span class="line">supervisorctl reload</span><br><span class="line"></span><br><span class="line"># 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>智能快递柜</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS重装Homebrew</title>
    <url>/2022/02/12/macOS%E5%AE%89%E8%A3%85aira2%E5%AF%BC%E8%87%B4Homebrew%E5%8F%97%E6%8D%9F%EF%BD%9C%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220205152726453.png" alt="image-20220205152726453" style="zoom:50%;" />
<p>Homebrew可谓是macOS的大杀器，aira2是下载届的大杀器。前两天安装aria2的时候，出现了openssl版本错误的问题，我就使用<code>brew install openssl</code>的命令升级到<code>openssl3</code>，结果越搞越乱，到最后直接brew命令都是用不了。刚好能不能通过重新安装brew来解决问题？可是一系列问题随之出现。</p>
<a id="more"></a>
<h2 id="一-解决方法一"><a class="markdownIt-Anchor" href="#一-解决方法一"></a> 一、解决方法一</h2>
<p>使用官方命令重装Homebrew，无法连接到github。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;HEAD&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220205153314436.png" alt="image-20220205153314436" /></p>
<blockquote>
<p>curl: (7) Failed to connect to <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> port 443: Connection refused</p>
</blockquote>
<p>更换了阿里云的源也无法解决问题。</p>
<p>最后bilibili一个up主<code>mintimate</code>，他自己写了一个自动安装脚本，一下子帮我完美解决问题。</p>
<p>mintimate的blog地址：<a href="https://mintimate.cn/2020/04/05/Homebrew/">https://mintimate.cn/2020/04/05/Homebrew/</a></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20220205153750700.png" alt="image-20220205153750700" style="zoom:50%;" />
<h2 id="一-解决方法二"><a class="markdownIt-Anchor" href="#一-解决方法二"></a> 一、解决方法二</h2>
<p>详情请查看：<a href="https://blog.tangspoon.cn/2022/02/05/macOS%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%8C%E8%A7%A3%E5%86%B3curl%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/">macOS 让终端走代理，解决 curl 失败问题</a></p>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>原创｜macOS 系统安装python库成功，但pycharm无法显示 解决方法</title>
    <url>/2022/04/15/macOS-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85python%E5%BA%93%E6%88%90%E5%8A%9F%EF%BC%8C%E4%BD%86pycharm%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415163327255.png" alt="image-20220415163327255" /></p>
<h2 id="一-分析"><a class="markdownIt-Anchor" href="#一-分析"></a> 一、分析</h2>
<p>原因：两个python解释器不一样。</p>
<p>pycharm的解释器安装位置：<img src="https://picbed.tangspoon.cn/uPic/image-20220415161119490.png" alt="image-20220415161119490" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;python3</span><br></pre></td></tr></table></figure>
<p>而系统的解释器pip安装位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用如下命令查找随便一个module</span><br><span class="line">pip install xxxx</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415161451567.png" alt="image-20220415161451567" /></p>
<p>解释器其实也就是可执行的python程序，大概率实在这里。只要在这里路径找到python3.7的可执行程序就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Location: &#x2F;Users&#x2F;spoon&#x2F;opt&#x2F;anaconda3</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415161803704.png" alt="image-20220415161803704" /></p>
<p>macOS的可执行程序都在bin文件夹中。果不其然～就在这里。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415162207465.png" alt="image-20220415162207465" /></p>
<h2 id="二-解决方式"><a class="markdownIt-Anchor" href="#二-解决方式"></a> 二、解决方式</h2>
<p>接下来在Python Interpreter中设置一个新的解释器就可以。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415162252164.png" alt="image-20220415162252164" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220415162538948-20220415163111895.png" alt="image-20220415162538948" /></p>
<p>稍微等待加载就可以。</p>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS让终端走代理，解决curl失败问题</title>
    <url>/2022/02/09/macOS%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%8C%E8%A7%A3%E5%86%B3curl%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220205160123197.png" alt="image-20220205160123197" /></p>
<a id="more"></a>
<p>前提是你得有代理</p>
<p>我使用的是<code>ClashX.app</code>软件，可以看到HTTP端口是7892</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220205155421631.png" alt="image-20220205155421631" /></p>
<p>那么我们要让终端走HTTP代理，在终端执行下面的代码即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7892;export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7892</span><br></pre></td></tr></table></figure>
<p>注意：只是在当前页面终端页面有效。</p>
<p>测试是否生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl ip.gs</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220205155734830.png" alt="image-20220205155734830" /></p>
<p>现在就应该可以<code>curl</code>github的内容了。</p>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>个人理解TCP/IP</title>
    <url>/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/</url>
    <content><![CDATA[<blockquote>
<p>本文学习参考文章：<a href="https://www.odaily.com/post/5133541">https://www.odaily.com/post/5133541</a></p>
</blockquote>
<h2 id="tcpip是什么"><a class="markdownIt-Anchor" href="#tcpip是什么"></a> TCP/IP是什么？</h2>
<p>TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP……</p>
<a id="more"></a>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108121828480.png" alt="image-20201108121828480" style="zoom:50%;" />
<blockquote>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段 (segment)，在网络层叫做数据报 (datagram)，在链路层叫做帧 (frame)。</p>
</blockquote>
<h2 id="tcpip的分层管理"><a class="markdownIt-Anchor" href="#tcpip的分层管理"></a> TCP/IP的分层管理</h2>
<p>TCP/IP参考模型：网络接口层、网络层、传输层和应用层。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108121428320.png" alt="image-20201108121428320" style="zoom:50%;" />
<p>网络上很多会从下往上理解，但从上往下会更符合普通用户的理解。</p>
<ul>
<li>
<p>应用层：这一层的任务是：将接收到的数据包按照「协议」解读成各种类型的数据，然后把这些数据打包传到下一层：传输层。协议有：HTTP、FTP、SMTP、Telnet、NFS、RIP等。</p>
<p>例如：我要发一封邮件，就要用SMTP协议把数据包解读，传给传输层帮我传输。</p>
</li>
<li>
<p>传输层（TCP层）：这层的任务是：确保分割的单元在另一端正确地到达，它建立端口到端口的连接。用TCP/UDP协议，把应用层传来的数据进行分割成以数据报文段为单位的数据包交给下一层（网络层）。（这是在「网络」中两台机器互相传数据。）</p>
</li>
<li>
<p>网络层（IP层）：这层的任务是把传输层的数据，在众多的路由器中「找到路」，传给下一层。</p>
<p>该层常见的协议有：IP，ICMP，ARP，RARP</p>
</li>
<li>
<p>网络接口层（数据连接+物理层）：负责传输「局域网」的数据。这层使用什么协议取决于所使用的无力网络：如果物理网是LAN，那么通常使用的是以太网协议以及他的变体。</p>
<p>两台主机之间是通过网卡进行发送和接受数据的，**以太网在「子网」内以广播的形式发送数据。**光靠MAC地址并不能让两台主机通信，因为如果两台主机不在同一子网，以太网协议就不能用了。这时需要通过网路层来区分每台主机所在的网络是哪个子网。</p>
</li>
</ul>
<p>上面的整个流程举个例子：我向我朋友发一封邮件，内容为“你好！”，这时候在「应用层」就使用SMTP协议对邮件内容进行打包整理，传给「传输层」，用TCP/UDP协议来切割数据（传输的过程都是在网络中进行的，不是局域网）。可是数据都要传去哪里呢？这件事交给「网络层」（IP），它会选择一条路径把交到离你最近的路由器上，再由光线传到我们家里的广猫中，这个时候就交给「网络接口层的协议」发挥作用了，在局域网中把广猫的数据通过网线或wifi发送到我们的电脑网卡中开始接收。</p>
<h2 id="tcp-udp与其他"><a class="markdownIt-Anchor" href="#tcp-udp与其他"></a> TCP、UDP与其他</h2>
<p>TCP协议：面向连接的、基于字节流的、可靠的传输层通信协议</p>
<ul>
<li>
<p>面向连接：需要经过三次握手后，client与servers端才会开始进行数据的传输（但我握手过程中传送的包不包含任何数据）</p>
</li>
<li>
<p>稳定可靠：能把数据准确可靠地传给对方，简单来说就是，它把数据切成一个个数据包，从第一只数据包开始传，传送成功就翻倍，发现失败就地爬起来，从绊倒的那只数据包重新开始，周而复始。</p>
</li>
<li>
<p>基于字节流服务：把大块数据分割成以报文段为单位的数据包进行管理。</p>
</li>
</ul>
<p>UDP、ARP、RARP概念相对简单，具体可以参考文章：<a href="https://www.odaily.com/post/5133541">一文看懂互联网TCP/UDP协议</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>中国移动电视盒子刷机｜当贝市场</title>
    <url>/2021/12/05/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E5%88%B7%E6%9C%BA%EF%BD%9C%E5%BD%93%E8%B4%9D%E5%B8%82%E5%9C%BA%E9%9A%8F%E4%BE%BF%E8%A3%85APP/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211205120819625.png" alt="image-20211205120819625" /></p>
<a id="more"></a>
<h2 id="一-下载固件"><a class="markdownIt-Anchor" href="#一-下载固件"></a> 一、下载固件</h2>
<blockquote>
<p>这一步非常重要，搞不好会变砖。</p>
</blockquote>
<h3 id="1-确定机型"><a class="markdownIt-Anchor" href="#1-确定机型"></a> 1. 确定机型</h3>
<p>我的是：魔百盒CM201-2</p>
<p><img src="https://picbed.tangspoon.cn/uPic/IMG_3714.JPG" alt="IMG_3714" /></p>
<h3 id="2-确定芯片型号可跳过但有风险"><a class="markdownIt-Anchor" href="#2-确定芯片型号可跳过但有风险"></a> 2. 确定芯片型号（可跳过，但有风险）</h3>
<blockquote>
<p>为什么可跳过呢？因为会有一些型号通刷包，就像我这个CM201-2就有，但可能会有变砖风险。</p>
</blockquote>
<p>这一步需要拆开外壳，拧开两个隐藏在脚垫的螺丝就行。我的板子型号：M8273。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211205121237365.png" alt="image-20211205121237365" /></p>
<h3 id="3-寻找-下载固件"><a class="markdownIt-Anchor" href="#3-寻找-下载固件"></a> 3. 寻找、下载固件</h3>
<p>带着机型、板子型号到搜索引擎搜索固件。在这里给两个比较靠谱的论坛：</p>
<p>小白刷机网「免费」：<a href="http://xiaobaishuaji.com/">http://xiaobaishuaji.com/</a></p>
<p>智能电视网「大多付费，但信息多」：<a href="https://www.znds.com/">https://www.znds.com/</a></p>
<p>麒麟刷机网「内容非常详尽」：<a href="https://www.szjytx.com/">https://www.szjytx.com/</a></p>
<h3 id="4-后路"><a class="markdownIt-Anchor" href="#4-后路"></a> 4. 后路</h3>
<p>是在找不到固件的话，可以加入上面三个论坛的交流群，会有很多大佬直接甩个链接给你下载。</p>
<p>我进了一个「魔百盒（IPTV盒子）技」，群号：517426928，氛围很好。（无广告哈）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211205113956266.png" alt="image-20211205113956266" style="zoom:50%;" />
<blockquote>
<p>CM201-2 ZG M8273版本的固件</p>
<p>百度云下载链接：<a href="https://pan.baidu.com/s/15Rv34NR4XMg-x2wVgCOPY">https://pan.baidu.com/s/15Rv34NR4XMg-x2wVgCOPY</a> 提取码：5nir</p>
<p>115：<a href="https://115.com/s/sw3vijh3z1i#">https://115.com/s/sw3vijh3z1i#</a>    访问码：ra18</p>
<p>腾讯微云：<a href="https://share.weiyun.com/yXW7Czpr">https://share.weiyun.com/yXW7Czpr</a> 密码：o9tkro</p>
</blockquote>
<h2 id="二-备份原版固件可跳过"><a class="markdownIt-Anchor" href="#二-备份原版固件可跳过"></a> 二、备份原版固件（可跳过）</h2>
<p>这一步我是跳过了的，因为需要ttl备份，花的时间太多，而且看了一下闲鱼这种破解好的机顶盒才几十一个。变砖了也不心疼。</p>
<p>相关备份有很多教程，每个型号都不一样，请自行搜索。</p>
<h2 id="三-开始刷机"><a class="markdownIt-Anchor" href="#三-开始刷机"></a> 三、开始刷机</h2>
<blockquote>
<ol>
<li>准备一个8G或以下的U盘</li>
<li>不要看刷机包里面的教程！！有问题！！</li>
</ol>
</blockquote>
<h3 id="1-文件处理"><a class="markdownIt-Anchor" href="#1-文件处理"></a> 1. 文件处理</h3>
<p>解压文件包后，如下。（第一个文件夹只有两个文件）</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20211205114147760.png" alt="image-20211205114147760" /></p>
<blockquote>
<p>这里一定要按照我的步骤操作，<strong>不要</strong>看压缩包里面的“免拆刷机步骤.txt”</p>
</blockquote>
<p>在U盘中新建一个LOST.DIR的文件夹，然后把上图中第一个文件夹里面的“full-CM201-2-002.460.006-20180324120441.zip”复制到U盘里刚刚新建的LOST.DIR里面，然后把update.zip直接复制在U盘根目录。（如下）</p>
<p><img src="https://picbed.tangspoon.cn/uPic/Xnip2021-12-03_23-07-04-20211205110830145.jpg" alt="Xnip2021-12-03_23-07-04" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/Xnip2021-12-03_23-07-14.jpg" alt="Xnip2021-12-03_23-07-14" /></p>
<h3 id="2-机顶盒操作刷机"><a class="markdownIt-Anchor" href="#2-机顶盒操作刷机"></a> 2. 机顶盒操作刷机</h3>
<p>盒子开机，连续顺序点按遥控菜单键和音量减键，进入Recovery刷机模式。</p>
<p>选择从u盘刷入full-CM201-2-002.460.006-20180324120441.zip。</p>
<p>刷完机后重新启动机器，按遥控器的<strong>设置按钮</strong>。</p>
<p>无线/有线连接网络，查看网络信息，记下盒子的IP地址。（这一步可以直接路由器中查看盒子的ip）</p>
<p>运行免拆目录里的-双击执行-文件，按要求输入盒子IP地址。（这一步尽量用Windows系统电脑，因为macOS电脑好像会有问题）</p>
<p>批处理执行完毕后，盒子重启自动刷机直至完毕。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/IMG_3715.JPG" alt="IMG_3715" /></p>
<h2 id="四-唠叨几句"><a class="markdownIt-Anchor" href="#四-唠叨几句"></a> 四、唠叨几句</h2>
<p>刷机有风险，看自己承受能力折腾。</p>
<p>魔百盒有很多代工厂，每个配件可能都会不一样，都会导致刷机的失败。所以，尽量找那种和所有硬件信息（cpu、wifi模块、闪存类型……）都匹配的固件。</p>
<p>刷机过程可能不会和教程一模一样，就自己理解整个流程，灵活变通一下吧。而且反正几十块一个而已，变砖了大不了重新买一个，大胆搞，学多点东西。</p>
<p>（我要看人生一串去了）</p>
<p><img src="https://picbed.tangspoon.cn/uPic/IMG_3716.JPG" alt="IMG_3716" /></p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Respeaker语音接收模块的声卡配置</title>
    <url>/2022/03/03/%E4%BD%BF%E7%94%A8Respeaker%E8%AF%AD%E9%9F%B3%E6%8E%A5%E6%94%B6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%A3%B0%E5%8D%A1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220303100857343.png" alt="image-20220303100857343" style="zoom: 33%;" />
<p>很久很久之前，打算用树莓派做个具有语音识别功能的语音闹钟，但难度是意想不到的大，且该模块的唤醒距离要非常近。但其中遇到了一个问题非常值得记录：在类似树莓派、香橙派这种开发版中声卡的设置问题。</p>
<a id="more"></a>
<p>使用mplayer播放出现错误</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201224162311029.png" alt="image-20201224162311029" style="zoom:50%;" />
<p>大概率是新加入的respeaker占用了原来音响的声卡位置。</p>
<p>我们先查看一下实现play的设备<code>aplay -l</code>。只有一个<code>card 0：Headphones</code></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201224163249311.png" alt="image-20201224163249311" /></p>
<p>我们再查找一下实现record的设备<code>arecord -l</code>。只有一个<code>card 1: seeed4micviocec</code>，也就是新加入的respeaker。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201224163506998.png" alt="image-20201224163506998" /></p>
<p>我们查看一下配置默认声卡配置文件是<code>/etc/asound.conf</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201224162833679.png" alt="image-20201224162833679" style="zoom: 50%;" />
<p>google之后，在这里找到了答案</p>
<p><a href="https://blog.csdn.net/emithfla/article/details/104461976">https://blog.csdn.net/emithfla/article/details/104461976</a></p>
<p><code>vim /etc/asound.conf</code></p>
<p>然后在pcm.playback下添加下面内容即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> capture.pcm &#123;</span><br><span class="line">	type plug</span><br><span class="line">	slave.pcm &quot;hw:1,0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果出错，直接修改成上面csdn文章里的一样。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>树莓派</tag>
        <tag>声卡配置</tag>
      </tags>
  </entry>
  <entry>
    <title>原创 ｜ Hexo在generate后出现错误“LaTeX-incompatible input and strict mode is set to &#39;warn&#39;: Unicode text character 开 used in math mode [unicodeTextInMathMode]”</title>
    <url>/2020/11/19/%E5%8E%9F%E5%88%9B-%20%7C%20-Hexo%E5%9C%A8generate%E5%90%8E%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E2%80%9CLaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-%E5%BC%80-used-in-math-mode-unicodeTextInMathMode-%E2%80%9D/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201119113956277.png" alt="image-20201119113956277" style="zoom: 33%;" />
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<blockquote>
<p>完美主义不允许。</p>
</blockquote>
<p>这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。</p>
<a id="more"></a>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119114327053.png" alt="image-20201119114327053" style="zoom:50%;" />
<h1 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h1>
<p>在逐篇blog排查过没有拼写错误后，然后逐渐采取了一个很蠢的方式：逐篇删除文章，查找问题所在的博文（还好这个新站点博文数量还不多）。</p>
<p>在删除了《正则表达式-01》这篇文章，执行<code>sudo hexo s</code>后，报错消失。</p>
<p>打开文章，从头开始逐段删除，终于定位到具体的段落</p>
<p>然后在这个段落中再逐渐删除找报错点。终于定位到了！是$这个符号搞的鬼。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119115329340.png" alt="image-20201119115329340" style="zoom:50%;" />
<p><strong>基于直觉，加了一个转义字符<code>\</code>，报错消失～</strong></p>
<h2 id="出错原因"><a class="markdownIt-Anchor" href="#出错原因"></a> 出错原因</h2>
<p>可以看到下图，是有两个$的，而在Markdown语法中，<strong>两个$符号是数学符号和公式</strong>的使用。要想使用单个$，要加个转义字符<code>\</code>。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119115616169.png" alt="image-20201119115616169" style="zoom:50%;" />
<h1 id="总结体会"><a class="markdownIt-Anchor" href="#总结体会"></a> 总结体会</h1>
<ul>
<li>遇到问题要及早解决。如果我第一次遇到了这片文章的故障，就想办法解决，相比现在才去用蠢办法解决时间会节省太多了（起码不用特地写一篇blog～）。</li>
<li>要努力做一个完美主义的人。完美主义我觉得是一个程序员/IT从业者必须具备的一个特质。如果没有完美主义，就很难会深究一个问题。遇到问题就想“能用就行，随便啦”，这个程序员的大忌啊。要“尽量”把每一件事情都做得完美，日后才能安安稳稳过日子嘛。</li>
<li>问题要深究。解决了问题之后，还要知道为什么，日后才不会重复犯错误。就像这次加了转义字符解决了问题，还继续深究为什么会这样，才知道了在markdown中$的用法。</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>原创 ｜ macOS 使用HTMLTestRunner与unittestreport失败解决过程</title>
    <url>/2020/12/07/%E5%8E%9F%E5%88%9B-%EF%BD%9C-macOS-%E4%BD%BF%E7%94%A8HTMLTestRunner%E4%B8%8Eunittestreport%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20201207170003712.png" alt="image-20201207170003712" /></p>
<h3 id="一-背景"><a class="markdownIt-Anchor" href="#一-背景"></a> 一、背景</h3>
<p>在《Python自动化测试实战》中，使用的是HTMLTestRunner，但教程使用的是windows系统，本人使用的macOS与其有点出入。Baidu和Google的帖子全都是在手动下载py文件，然后手动放到Python的lib文件夹中，但本macOS无效。</p>
<a id="more"></a>
<h3 id="二-解决过程"><a class="markdownIt-Anchor" href="#二-解决过程"></a> 二、解决过程</h3>
<p>然后尝试换个思路，自动化测试报告中肯定不止只有老旧的HTMLTestRunner这个库呀，会不会有功能更加丰富、使用更方便、美观的第三方库呢？果然，有一个<a href="https://pypi.org/project/unittestreport/">unittestreport</a> 让人极为惊喜。</p>
<p>安装过程显示是非常简单的，直接使用pip安装。但我install之后import还是没反应。疑惑。这时，突然想起Pycharm中的Interpreter的配置，是可以直接安装第三方库的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207160205161.png" alt="image-20201207160205161" style="zoom:50%;" />
<p>在Install Package后，就可以成功使用unittestreport了。</p>
<h3 id="三-如何使用"><a class="markdownIt-Anchor" href="#三-如何使用"></a> 三、如何使用</h3>
<p>在<a href="http://testingpai.com/article/1595507317340">此文章</a>中有提示。我自己写了个简单的demo，可直接运行，<a href="https://file.tangspoon.cn/t/qbXL4C">点此下载</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> unittestteport <span class="keyword">import</span> TestRunner,HTMLTestRunner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步：加载测试套件</span></span><br><span class="line">suite1 = unittest.defaultTestLoader.discover(<span class="string">r&quot;xxx\xxx\cases&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：创建运行对象，传入测试套件</span></span><br><span class="line">runner = HTMLTestRunner(stream=open(<span class="string">&quot;report.html&quot;</span>,<span class="string">&#x27;wb&#x27;</span>), title=<span class="string">&#x27;木森的测试报告&#x27;</span>,)</span><br><span class="line"><span class="comment"># 第三步：执行测试</span></span><br><span class="line">runner.run()</span><br></pre></td></tr></table></figure>
<h3 id="四-advanced"><a class="markdownIt-Anchor" href="#四-advanced"></a> 四、advanced</h3>
<h4 id="1-为什么pip安装不能直接使用而直接在pycharm-interpreter安装就可以使用呢"><a class="markdownIt-Anchor" href="#1-为什么pip安装不能直接使用而直接在pycharm-interpreter安装就可以使用呢"></a> 1. 为什么pip安装不能直接使用，而直接在Pycharm Interpreter安装就可以使用呢？</h4>
<p>打开Pycharm Interpreter的Avaliable Packages界面，仔细查看，会发现其实会有一个钩子选项。从这里可以得到提示，可能与一个叫site packages的文件夹有关。可以从这里入手。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207161245421.png" alt="image-20201207161245421" style="zoom:50%;" />
<p>我们看看Project中的External Libraries都有哪些，打开一看，有了site-packes！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207162437233.png" alt="image-20201207162437233" style="zoom:45%;" />
<p>在里面可以找到我们刚刚导入的unittestreport，还有之前折腾失败的HTMLTestRunner。</p>
<p>pip安装失败，难道是pip安装的路径有问题？那我们查一下通过pip安装的unittestreport是在哪里。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201207163426073.png" alt="image-20201207163426073" /></p>
<p>在上述路径中删除一个库，PyCharm的External Libraries中的site-packages中就少了被删除的库，由此可证明其实<code>pip install unittestreport</code>已经成功了，只是我们还未在项目的解释器（PyCharm的Interpreter）中添加而已。其实这就像和我们使用selenium一样，每次新建一个project，<strong>就需要在解释器中添加相应的包才能使用的。</strong></p>
<h4 id="2-为什么网上手动引入htmltestrunnerpy的方法行不通呢"><a class="markdownIt-Anchor" href="#2-为什么网上手动引入htmltestrunnerpy的方法行不通呢"></a> 2. 为什么网上手动引入HTMLTestRunner.py的方法行不通呢？</h4>
<p>我们研究了上面的问题后，其实可以发现：我们是要在/Users/换成自己的用户名/opt/anaconda3/lib/python3.7/site-packages/中，创建一个HTMLTestRunner文件夹，然后把py文件放进即可。而不是放入什么bin目录或者lib目录。</p>
<p><strong>手动引入其他第三方库类似。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207165459498.png" alt="image-20201207165459498" style="zoom:50%;" />
<p><strong>或者更简单的，我们可以直接通过PyCharm的解释器在线添加packages。</strong></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>原创｜自建房没有丰巢？自己造一个！｜打造智能快递柜</title>
    <url>/2022/01/14/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%87%AA%E5%BB%BA%E6%88%BF%E6%B2%A1%E6%9C%89%E4%B8%B0%E5%B7%A2%EF%BC%9F%E8%87%AA%E5%B7%B1%E9%80%A0%E4%B8%80%E4%B8%AA%EF%BC%81%EF%BD%9C%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220126161032850.png" alt="image-20220126161032850" style="zoom:30%;" />
<p>前些日子家里装修，网购了好多好多东西。但城中村里没有类似丰巢那样的投递柜（对，我这条村真的没有），放在村里的代收点1块一个小件，2块一个大件，比丰巢还贵？而且感觉要跑超过500m去那个快递很麻烦。所以，我为什么不能自己造一个“丰巢”呢？</p>
<a id="more"></a>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126161110667.png" alt="image-20220126161110667" /></p>
<p>物料：</p>
<p>香橙派、USB继电器、5v电磁锁、单门柜子。</p>
<h2 id="一-思路"><a class="markdownIt-Anchor" href="#一-思路"></a> 一、思路</h2>
<p>投递员扫描二维码进入网页，填密码，打开柜子。所以项目主要分为两部分：</p>
<ol>
<li>软件：验证密码和控制电磁锁的系统</li>
<li>硬件：托管系统的硬件，电磁锁</li>
</ol>
<p>系统实际上就只有一个密码校验功能，很简单。用flask写超级快。</p>
<p>硬件部分我选择了香橙派托管flask网页，内网穿透让在外网的投递员访问系统，配合USB继电器来控制电磁锁的开关。</p>
<h2 id="二-硬件"><a class="markdownIt-Anchor" href="#二-硬件"></a> 二、硬件</h2>
<h3 id="1-香橙派zero-512mb"><a class="markdownIt-Anchor" href="#1-香橙派zero-512mb"></a> 1. 香橙派zero 512mb</h3>
<p>闲鱼70包邮</p>
<h3 id="2-电磁锁"><a class="markdownIt-Anchor" href="#2-电磁锁"></a> 2. 电磁锁</h3>
<p>购买5v的即可</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150623931.png" alt="image-20220126150623931" /></p>
<h3 id="3-usb继电器"><a class="markdownIt-Anchor" href="#3-usb继电器"></a> 3. USB继电器</h3>
<p>优点：免驱、5V供电、商家提供详细说明</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150308608.png" alt="image-20220126150308608" /></p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150521278.png" alt="image-20220126150521278" /></p>
<h2 id="三-软件系统"><a class="markdownIt-Anchor" href="#三-软件系统"></a> 三、软件系统</h2>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20220103113637980.png" alt="image-20220103113637980" /></p>
<h3 id="1-flask-主程序-apppy"><a class="markdownIt-Anchor" href="#1-flask-主程序-apppy"></a> 1. flask 主程序 <a href="http://app.py">app.py</a></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for</span><br><span class="line"><span class="keyword">import</span> decrypt</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;result&#x27;</span>,</span><br><span class="line">                                password=password))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/result&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span>():</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        encrypt_text = f.read()</span><br><span class="line">    password = request.args.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> password == decrypt.decrypt_data(encrypt_text):</span><br><span class="line">        os.system(<span class="string">&#x27;bash /root/express_system/open.sh&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;correct.html&quot;</span>,</span><br><span class="line">                               password=password)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;error.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, port=<span class="number">8443</span>)</span><br></pre></td></tr></table></figure>
<p>注意：上面 line20 要放<code>password.txt</code>的绝对路径</p>
<h3 id="2-opensh"><a class="markdownIt-Anchor" href="#2-opensh"></a> 2. <a href="http://open.sh">open.sh</a></h3>
<p>插入usb电磁继电器之后，香橙派会识别出USB设备。我购买的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo -n -e &quot;\xA0\x01\x01\xA2&quot; &gt;&#x2F;dev&#x2F;ttyUSB0</span><br><span class="line">sleep 0.5s</span><br><span class="line">echo -n -e &quot;\xA0\x01\x00\xA1&quot; &gt;&#x2F;dev&#x2F;ttyUSB0</span><br></pre></td></tr></table></figure>
<h3 id="3-decryptpy"><a class="markdownIt-Anchor" href="#3-decryptpy"></a> 3. <a href="http://decrypt.py">decrypt.py</a></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不用做任何修改</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> PKCS1_cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">key_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(key_file) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        key = RSA.importKey(data)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_data</span>(<span class="params">encrypt_msg</span>):</span></span><br><span class="line">    private_key = get_key(<span class="string">&#x27;xxxx/xxxx/rsa_private_key.pem&#x27;</span>)</span><br><span class="line">    cipher = PKCS1_cipher.new(private_key)</span><br><span class="line">    back_text = cipher.decrypt(base64.b64decode(encrypt_msg), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> back_text.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意：line15 填写绝对路径</p>
<h3 id="4-每周更换密码并发送到微信-randpwdweeklypy"><a class="markdownIt-Anchor" href="#4-每周更换密码并发送到微信-randpwdweeklypy"></a> 4. 每周更换密码并发送到微信 <a href="http://randPwdWeekly.py">randPwdWeekly.py</a></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> PKCS1_cipher</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此脚本设置每周执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">key_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(key_file) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        key = RSA.importKey(data)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_data</span>(<span class="params">msg</span>):</span></span><br><span class="line">    public_key = get_key(<span class="string">&#x27;rsa_public_key.pem&#x27;</span>)</span><br><span class="line">    cipher = PKCS1_cipher.new(public_key)</span><br><span class="line">    encrypt_text = base64.b64encode(cipher.encrypt(bytes(msg.encode(<span class="string">&quot;utf8&quot;</span>))))</span><br><span class="line">    <span class="keyword">return</span> encrypt_text.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server_url = <span class="string">&#x27;https://sctapi.ftqq.com/xxxxxxxx.send&#x27;</span></span><br><span class="line">    randPwd = str(random.randint(<span class="number">100000</span>, <span class="number">1000000</span>))</span><br><span class="line">    print(randPwd)</span><br><span class="line">    <span class="comment"># server酱发送到wechat</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;智能快递柜密码已更新!!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;desp&#x27;</span>: <span class="string">&#x27;新密码是：&#x27;</span> + randPwd</span><br><span class="line">    &#125;</span><br><span class="line">    requests.post(server_url, params=data)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password2.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(randPwd)</span><br><span class="line">    encrypt_data(randPwd)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(encrypt_data(randPwd))</span><br></pre></td></tr></table></figure>
<p>注意：<code>line24</code> 要改成自己的server酱的<code>key</code></p>
<h3 id="5-生成rsa的两种key-creatersa_keypy"><a class="markdownIt-Anchor" href="#5-生成rsa的两种key-creatersa_keypy"></a> 5. 生成RSA的两种key  createRSA_Key.py</h3>
<p>该脚本只执行一次即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只用一次！！</span></span><br><span class="line"></span><br><span class="line">random_generator = Random.new().read</span><br><span class="line">rsa = RSA.generate(<span class="number">2048</span>, random_generator)</span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">private_key = rsa.exportKey()</span><br><span class="line">print(private_key.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">public_key = rsa.publickey().exportKey()</span><br><span class="line">print(public_key.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/rsa_private_key.pem&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(private_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/rsa_public_key.pem&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(public_key)</span><br></pre></td></tr></table></figure>
<h2 id="四-项目运行"><a class="markdownIt-Anchor" href="#四-项目运行"></a> 四、项目运行</h2>
<h3 id="1-获取项目"><a class="markdownIt-Anchor" href="#1-获取项目"></a> 1. 获取项目</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tangspoon66&#x2F;express_sys.git</span><br></pre></td></tr></table></figure>
<h3 id="2-安装flask"><a class="markdownIt-Anchor" href="#2-安装flask"></a> 2. 安装flask</h3>
<p>参考：<a href="https://blog.tangspoon.cn/2020/12/26/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-Hello/">Flask 学习笔记 - Hello</a></p>
<h3 id="3-flask后台运行"><a class="markdownIt-Anchor" href="#3-flask后台运行"></a> 3. flask后台运行</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">screen -S express_sys</span><br></pre></td></tr></table></figure>
<p>在新弹出的screen里输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python &#x2F;root&#x2F;express_sys&#x2F;app.py</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有screen</span><br><span class="line">screen -ls</span><br><span class="line"># 返回screen</span><br><span class="line">screen -d screen</span><br></pre></td></tr></table></figure>
</blockquote>
<p>随后可以关闭会话窗口，flask项目还是可以访问的。</p>
<h3 id="4-配置内网穿透frp"><a class="markdownIt-Anchor" href="#4-配置内网穿透frp"></a> 4. 配置内网穿透frp</h3>
<p>参考：<a href="https://blog.tangspoon.cn/2021/12/24/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BD%9C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B9%E7%9B%AE/">frp 内网穿透怎么用？｜访问内网 web 项目</a></p>
<h3 id="5-flask-和-frp开机自启"><a class="markdownIt-Anchor" href="#5-flask-和-frp开机自启"></a> 5. flask 和 frp开机自启</h3>
<p>参考：<a href="https://blog.tangspoon.cn/2022/01/04/linux%E4%BD%BF%E7%94%A8supervisor%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/">linux 使用 supervisor 实现开机自启</a></p>
<h3 id="6-还需要更改一些绝对路径之类的"><a class="markdownIt-Anchor" href="#6-还需要更改一些绝对路径之类的"></a> 6. 还需要更改一些绝对路径之类的。</h3>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Flask</tag>
        <tag>Python</tag>
        <tag>OrangePi</tag>
      </tags>
  </entry>
  <entry>
    <title>原创｜转发B站UP主动态到微信python脚本</title>
    <url>/2021/12/06/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%BD%AC%E5%8F%91B%E7%AB%99UP%E4%B8%BB%E5%8A%A8%E6%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1python%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211206213430058.png" alt="image-20211206213430058" style="zoom:40%;" />
<h2 id="一-需求"><a class="markdownIt-Anchor" href="#一-需求"></a> 一、需求</h2>
<p>B站关注了非常多up主，每天动态99+，但其实绝大部分的UP主我都不感兴趣。我每天都得手动寻找那些必看的UP。在寻找的过程中，大数据推荐让我忍不住看了一个又一个的视频，浪费时间不够专注。</p>
<p>所以，需要开发一个<strong>每天定时把我每天必看的UP主的动态转发到微信</strong>，这样避免了手动寻找和被大数据推荐的干扰，专注力大大提高。</p>
<a id="more"></a>
<h2 id="二-思路"><a class="markdownIt-Anchor" href="#二-思路"></a> 二、思路</h2>
<p>如果动态的发出日和系统当天日期相等，就把动态链接发送到微信。所以我们第一步是要获取到动态的发出日。第二步要完成的是而把信息转发到微信的功能，可以借助**<a href="https://sct.ftqq.com/upgrade?fr=sc">server酱</a>**完成。</p>
<h2 id="三-获取动态的发出日期"><a class="markdownIt-Anchor" href="#三-获取动态的发出日期"></a> 三、获取动态的发出日期</h2>
<h3 id="1-抓取动态api"><a class="markdownIt-Anchor" href="#1-抓取动态api"></a> 1. 抓取动态API</h3>
<p>上网找了一下，好像没有直接提供有关于动态的api，那我们F12看看。想要定位到UP主，api的参数肯定是带有uid，所以我们可以直接筛选出相关的api。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211206191118663.png" alt="image-20211206191118663" style="zoom:50%;" />
<p>然后我们在两个api的response数据里面搜索<code>dynamic</code>，可以分析出第二条是应该就是我们可以用到的api了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211206191429552.png" alt="image-20211206191429552" style="zoom:50%;" />
<p><strong>Request URL:</strong></p>
<p><a href="https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history?visitor_uid=XXXXX&amp;host_uid=XXXXX&amp;offset_dynamic_id=0&amp;need_top=1&amp;platform=web">https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history?visitor_uid=XXXXX&amp;host_uid=XXXXX&amp;offset_dynamic_id=0&amp;need_top=1&amp;platform=web</a></p>
<p>从上面可以看出，参数有好几个。进一步在postman上测试出只有 <code>host_uid</code>是必须的参数。所以我们得出了Bilibili的动态api与必须参数：</p>
<blockquote>
<p><code>api</code>：<a href="https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history">https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history</a></p>
<p><code>data</code>：host_uid（string，必填）</p>
</blockquote>
<h3 id="2-数据分析"><a class="markdownIt-Anchor" href="#2-数据分析"></a> 2. 数据分析</h3>
<p>在response里面搜索time，找到有个叫<code>timestamp</code>的字段。这很明显是时间戳。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211206194517975.png" alt="image-20211206194517975" style="zoom:30%;" />
<p>我们在<a href="https://tool.lu/timestamp/">时间戳在线转换网</a>里查看时间。经过对比，第一个<code>timestamp</code>就是我们需要的数据！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211206200625092.png" alt="image-20211206200625092" style="zoom:33%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20211206200652112.png" alt="image-20211206200652112" style="zoom:34%;" />
<h2 id="四-server酱的使用"><a class="markdownIt-Anchor" href="#四-server酱的使用"></a> 四、server酱的使用</h2>
<p><code>server酱</code>的应用场景：<a href="https://sct.ftqq.com/apps">https://sct.ftqq.com/apps</a></p>
<p>使用<code>server酱</code>的使用也非常简单，官方有介绍（图中的<code>*</code>，是你们注册后的到的sendkey）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20211206201723794.png" alt="image-20211206201723794" style="zoom: 33%;" />
<p>我们只需要制造好<code>title</code>和 <code>desp</code>参数的内容即可完成功能。</p>
<h2 id="五-uid列表的读取与写入"><a class="markdownIt-Anchor" href="#五-uid列表的读取与写入"></a> 五、uid列表的读取与写入</h2>
<p>因为是个人使用，所以没有写数据库，直接从<code>uid.txt</code>中读取数据。</p>
<p>但如果想要添加自己喜欢的up主要怎么更快捷的操作？答案可以从我的另一篇文章<a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/">《智能闹钟（五）｜如何优雅地关闭闹钟？》</a>中找到答案——IOS的快捷指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> xxxx &gt;&gt; uid.txt</span><br></pre></td></tr></table></figure>
<p>注意，图中的<code>每次均询问</code>是快捷指令的其中一个功能，在编辑脚本的时候可选。</p>
<img src="https://picbed.tangspoon.cn/uPic/IMG_3759.jpg" alt="IMG_3759" style="zoom: 33%;" />
<img src="https://picbed.tangspoon.cn/uPic/IMG_3760.jpg" alt="IMG_3760" style="zoom:25%;" />
<h2 id="六-部署到vps"><a class="markdownIt-Anchor" href="#六-部署到vps"></a> 六、部署到vps</h2>
<h3 id="1-建立uidtxt"><a class="markdownIt-Anchor" href="#1-建立uidtxt"></a> 1. 建立uid.txt</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch &#x2F;home&#x2F;uid.txt</span><br><span class="line"># 添加uid</span><br><span class="line">vi &#x2F;home&#x2F;uid.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-安装requests模块"><a class="markdownIt-Anchor" href="#2-安装requests模块"></a> 2. 安装requests模块</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># debian9</span><br><span class="line">apt-get install python-requests -y</span><br><span class="line"># centos</span><br><span class="line">yum install python-requests -y</span><br></pre></td></tr></table></figure>
<h3 id="2-换成python3"><a class="markdownIt-Anchor" href="#2-换成python3"></a> 2. 换成python3</h3>
<p>部署到vps可能会出现如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xc0 in position 7: ordi”</span><br></pre></td></tr></table></figure>
<p>这是因为出现系统中默认使用python2，换成python3就可以解决问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除/usr/bin目录下的python link文件</span></span><br><span class="line">sudo rm -rf /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除后再建立新的链接关系：</span></span><br><span class="line">sudo ln -s /usr/bin/python3<span class="number">.5</span> /usr/bin/python</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果想切换回python2.7</span></span><br><span class="line">sudo rm -rf /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/ptyhon2<span class="number">.7</span> /usr/bin/python</span><br></pre></td></tr></table></figure>
<h3 id="3-设置crontab定时任务"><a class="markdownIt-Anchor" href="#3-设置crontab定时任务"></a> 3. 设置crontab定时任务</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 22 * * * python BDynamicToWechat.py</span><br><span class="line"># 每天晚上10点执行任务</span><br></pre></td></tr></table></figure>
<h3 id="4-重启crontab"><a class="markdownIt-Anchor" href="#4-重启crontab"></a> 4. 重启crontab</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">service cron restart</span><br></pre></td></tr></table></figure>
<h2 id="七-效果"><a class="markdownIt-Anchor" href="#七-效果"></a> 七、效果</h2>
<img src="https://picbed.tangspoon.cn/uPic/IMG_3761.jpg" alt="IMG_3761" style="zoom:33%;" />
<img src="https://picbed.tangspoon.cn/uPic/IMG_3762.jpg" alt="IMG_3762" style="zoom:33%;" />
<h2 id="八-代码"><a class="markdownIt-Anchor" href="#八-代码"></a> 八、代码</h2>
<p><strong>欢迎star</strong></p>
<blockquote>
<p>github地址：<a href="https://github.com/tangspoon66/BDynamicToWechat">https://github.com/tangspoon66/BDynamicToWechat</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>后盾人MySQL-基本操作</title>
    <url>/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>感谢<a href="https://houdunren.gitee.io/note/mysql/">后盾人</a>的MySQL教程</p>
</blockquote>
<a id="more"></a>
<h2 id="查询数据"><a class="markdownIt-Anchor" href="#查询数据"></a> 查询数据</h2>
<p>用的两张表：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108122852734.png" alt="image-20201108122852734" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201108122922049.png" alt="image-20201108122922049" style="zoom:50%;" />
<h4 id="字段处理"><a class="markdownIt-Anchor" href="#字段处理"></a> 字段处理</h4>
<ul>
<li>查询制定字段，并排序字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select description,cname from class;</span><br></pre></td></tr></table></figure>
<h4 id="条件筛选"><a class="markdownIt-Anchor" href="#条件筛选"></a> 条件筛选</h4>
<ul>
<li>根据条件查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where cname&#x3D;&#39;php&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询包含关键词的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where description like &#39;%p%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>合并「列」返回查询结果</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select concat(id,cname) as &#39;class_info&#39; from class;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123002633.png" alt="image-20201108123002633" style="zoom:50%;" />
<ul>
<li>介绍中不包含php的班级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where description not like &#39;%php%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询学生所在班级编号，并去除重复值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct class_id from stu;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询年龄在20~35岁的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from stu where age between 20 and 35;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找2、3班的所有同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id in(2,3);</span><br></pre></td></tr></table></figure>
<ul>
<li>查找除了1、3班的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id not in(1,3);</span><br></pre></td></tr></table></figure>
<h4 id="null"><a class="markdownIt-Anchor" href="#null"></a> NULL</h4>
<ul>
<li>查询没有非配班级的学生姓名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname from stu where class_id is null;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123032831.png" alt="image-20201108123032831" style="zoom:50%;" />
<ul>
<li>查询结果中对没分配班级的学生显示未分配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname,ifnull(class_id,&#39;未分配&#39;) from stu;</span><br></pre></td></tr></table></figure>
<h4 id="排序结果"><a class="markdownIt-Anchor" href="#排序结果"></a> 排序结果</h4>
<ul>
<li>按学生年龄从大到小排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by age desc;</span><br></pre></td></tr></table></figure>
<ul>
<li>班级从大到小排序，相同班级的同学年龄从小到大排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by class_id desc,age asc;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是多个条件的罗列。</p>
</blockquote>
<ul>
<li>随机获得一名同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by rand() limit 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后报名的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by id desc limit 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二和第三报名的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by id asc limit 1,2;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找2班年龄最小的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id&#x3D;2 and age is not null order by age asc limit 1;</span><br><span class="line"># 注意不要忘了order by age中的age</span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上：排序中选择某个特定对象，可以用limit来限制。但一定要先排好序再使用。</p>
</blockquote>
<h2 id="删除记录"><a class="markdownIt-Anchor" href="#删除记录"></a> 删除记录</h2>
<ul>
<li>删除所有年龄小于20的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from stu where age&lt;20;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除所有年龄小在30并没有班级的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from stu where age&#x3D;30 and class_id is null;</span><br></pre></td></tr></table></figure>
<h2 id="添加记录"><a class="markdownIt-Anchor" href="#添加记录"></a> 添加记录</h2>
<ul>
<li>添加一条记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into stu SET sname&#x3D;&#39;小明&#39;,age&#x3D;22,class_id&#x3D;1;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加多条件记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into stu(sname,class_id,age) values(&#39;小明&#39;,2,32),(&#39;小张&#39;,3,45);</span><br><span class="line"># 注意不要忘了values</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>后盾人MySQL-多表操作</title>
    <url>/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<blockquote>
<p>MySQL 表的操作还是有很多需要理解的地方，在此感谢<a href="https://houdunren.gitee.io/note/mysql/8%20%E5%A4%9A%E8%A1%A8%E6%94%BB%E7%95%A5.html#%E5%A4%9A%E8%A1%A8%E6%94%BB%E7%95%A5">后盾人</a>的文章。</p>
</blockquote>
<a id="more"></a>
<h2 id="join"><a class="markdownIt-Anchor" href="#join"></a> JOIN</h2>
<h4 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> inner join</h4>
<ul>
<li>查询一班的所有同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select s.id,sname,cname from stu s join class c on s.class_id&#x3D;c.id where c.id&#x3D;1; </span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级发表的文章数量，来操作多张表的关联操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 班级：class</span><br><span class="line"># 文章：article</span><br><span class="line"># 但class与article未设置直接连接，还需用stu联合起来（stu作为桥梁：用stu的class_id把class的id联合，然后再用stu的id把article的stu_id联合）</span><br><span class="line">select c.id,count(*) from stu as s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id;</span><br><span class="line"># 1. 计算数量用count(*)；2. 为什么用group by后面的是c.id呢？因为题目要求是「每个班级发表的文章数量」，所以肯定是用class的id来排的。</span><br></pre></td></tr></table></figure>
<ul>
<li>一班的所有女生发表的文章</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一班：class</span><br><span class="line"># 女生：stu</span><br><span class="line"># 文章：article</span><br><span class="line">select c.id,a.title from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">where sex&#x3D;&#39;女&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>哪个班级发表的文章超过两篇</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.id,count(*) as total from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id</span><br><span class="line">having total &gt;&#x3D;2;</span><br><span class="line"># 注意total是在count(*)设置的</span><br><span class="line"># having total也就是拥有count（*）这个数&gt;&#x3D;2的</span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级文章的总点击数与平均点击数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.id,sum(a.click) as class_sum,avg(a.click) from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id</span><br><span class="line">order by class_sum asc;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级有多少同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 班级：class</span><br><span class="line"># 学生：stu</span><br><span class="line">select c.id,count(*) from stu s join class c on s.class_id&#x3D;c.id group by c.id;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201028233614831.png" alt="image-20201028233614831" style="zoom:50%;" />
<p>上面是两张表连立后的新表，可以看到直接通过cname来统计每个班有多少人（有两个cname就证明有两个人）</p>
<ul>
<li>学生人数大于两个的班级名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as c</span><br><span class="line">ON s.class_id &#x3D; c.id</span><br><span class="line">GROUP BY c.cname</span><br><span class="line">HAVING total&gt;&#x3D;2;</span><br></pre></td></tr></table></figure>
<h4 id="outer-join"><a class="markdownIt-Anchor" href="#outer-join"></a> outer join</h4>
<p>外链接包括<code>left join</code>与<code>right join</code>，可以简单理解为 <code>LEFT JOIN</code>会包含<strong>左侧所有表记录</strong>，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>
<p>获取没有设置QQ的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s.sname FROM stu AS s LEFT JOIN stu_info as i</span><br><span class="line">ON s.id &#x3D; i.stu_id</span><br><span class="line">WHERE i.qq is null;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>吐血原创整理｜怎么把java web项目部署到centos7中？</title>
    <url>/2020/12/12/%E5%90%90%E8%A1%80%E5%8E%9F%E5%88%9B%E6%95%B4%E7%90%86%EF%BD%9C%E6%80%8E%E4%B9%88%E6%8A%8Ajava-web%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0centos7%E4%B8%AD%EF%BC%9F/</url>
    <content><![CDATA[<p>今天打开FinalShell，在vps列表最底下发现了一个叫“pr”的备注，瞬间想起6美元上的一个灵车pacificrack。双击后，震惊，链接居然绿了！连接速度居然还变快了……想不到近一年过去了还没翻车。既然这样，那就用来干点“正事”吧，把失败了的宠物论坛重新搭建起来，折腾一下。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_16-53-56.jpg" alt="Xnip2020-12-11_16-53-56" style="zoom:50%;" />
<a id="more"></a>
<p>在linux环境上部署javaweb项目比想象中的要简单太多，<strong>只需要java环境、mysql、tomcat三样</strong>。</p>
<p>我们先查看一下VPS是否自带有以上环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep java</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">rpm -qa|grep tomcat</span><br></pre></td></tr></table></figure>
<p>还好，都没有（不然我还得卸载）。所以，第一步是装好java环境。</p>
<h2 id="一-安装java环境"><a class="markdownIt-Anchor" href="#一-安装java环境"></a> 一、安装java环境</h2>
<h3 id="1-使用wget高效率下载jdk8安装java环境"><a class="markdownIt-Anchor" href="#1-使用wget高效率下载jdk8安装java环境"></a> 1. 使用wget高效率下载jdk8，安装java环境</h3>
<p>进入<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">jdk8</a>下载页面，点击下载链接。（注意到链接左上角是有一把锁🔒的，<strong>证明点击后还有验证项目</strong>，所以不是直接wget这条url。）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211183815811.png" alt="image-20201211183815811" style="zoom:50%;" />
<p>点入链接，打勾后，直接在Download下右键（不是左键！），复制下载链接，这条链接才是可以直接在VPS下wget的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211184247551.png" alt="image-20201211184247551" style="zoom:50%;" />
<p>然后我们连上VPS，输入wget，然后粘贴上面的下载链接。有了VPS后，我们要利用好VPS优秀的远程网络，不要再傻傻的下载到本地电脑，然后再手动上传到VPS中，简直多此一举。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_17-03-50.jpg" alt="Xnip2020-12-11_17-03-50" style="zoom:50%;" />
<blockquote>
<p>注意，我为什么不直接把下载链接分享出来呢？因为每条下载链接的有效性只能保持一段时间，过后就会失效。具体多久没有探究。oracle公司考虑得真的非常完美，感觉这样其中一个好处就是：可以大幅提高官网的访问率和官方方式下载率，不用一条链接用万年。</p>
</blockquote>
<h3 id="2-解压包"><a class="markdownIt-Anchor" href="#2-解压包"></a> 2. 解压包</h3>
<p>然后我们再/usr/local目录下创建一个名叫java的目录，把刚下载的jdk tar.gz包解压到这里，详细命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建java目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line"># 解压jdk包到java目录</span><br><span class="line">tar -zxvf 包名 -C &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line"># 查看解压包名</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211190147742.png" alt="image-20201211190147742" style="zoom: 50%;" />
<p><strong>注意！<code>ls</code>后就像上图一样，java文件夹内只能有一个jdk的包，不要放置其他内容</strong></p>
<h3 id="3-配置环境变量"><a class="markdownIt-Anchor" href="#3-配置环境变量"></a> 3. 配置环境变量</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>然后如图添加以下内容，然后保存，退出。（注意红框的内容自行更换为自己下载的包名，也就是上面<code>ls</code>查看出来的）</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_17-36-34.jpg" alt="Xnip2020-12-11_17-36-34" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># java</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_271</span><br><span class="line">export CLASSPATH&#x3D;$CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F;</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>然后更新文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h3 id="4-验证"><a class="markdownIt-Anchor" href="#4-验证"></a> 4. 验证</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211191148413.png" alt="image-20201211191148413" style="zoom:50%;" />
<p>出现上图，java环境安装成功！</p>
<p>如果出现了什么幺蛾子的话，就看error提示吧。linux问题很多，很难一一说明。死活有问题的话，就重装系统，换个系统吧，这是最最最没办法中的办法。</p>
<hr />
<h2 id="二-安装mysql-57"><a class="markdownIt-Anchor" href="#二-安装mysql-57"></a> 二、安装MySQL 5.7</h2>
<h3 id="1-检查是否有冲突的mariadb-lib然后卸载"><a class="markdownIt-Anchor" href="#1-检查是否有冲突的mariadb-lib然后卸载"></a> 1. 检查是否有冲突的mariadb-lib，然后卸载</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211195150651.png" alt="image-20201211195150651" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看是否存在mariadb</span><br><span class="line">rpm -qa|grep mariadb</span><br><span class="line"># 卸载</span><br><span class="line">rpm -e --nodes mariadb-libs-5.5.64-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h3 id="2-下载mysql安装包"><a class="markdownIt-Anchor" href="#2-下载mysql安装包"></a> 2. 下载MySQL安装包</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载rpm</span><br><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line"># 安装</span><br><span class="line">yum localinstall mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="3-安装"><a class="markdownIt-Anchor" href="#3-安装"></a> 3. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>
<p>安装完毕后，启动mysql服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p>查看mysql服务是否启动成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep mysql</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211203901096.png" alt="image-20201211203901096" style="zoom:50%;" />
<h3 id="4-修改密码"><a class="markdownIt-Anchor" href="#4-修改密码"></a> 4. 修改密码</h3>
<p>查询MySQL的临时密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211205414107.png" alt="image-20201211205414107" style="zoom:50%;" />
<p>复制临时密码，使用临时登录MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>修改密码，然后刷新权限</p>
<blockquote>
<p>把下面的xxx修改成自己的密码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;xxxx&#39;;</span><br><span class="line"># 刷新权限！一定要！</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>最后尝试使用新修改的密码重新登陆。</p>
<hr />
<h2 id="三-安装tomcat-8"><a class="markdownIt-Anchor" href="#三-安装tomcat-8"></a> 三、安装tomcat 8</h2>
<h3 id="1-使用wegt下载targz包"><a class="markdownIt-Anchor" href="#1-使用wegt下载targz包"></a> 1. 使用wegt下载tar.gz包</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212093710258.png" alt="image-20201212093710258" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201212093839753.png" alt="image-20201212093839753" style="zoom:50%;" />
<h3 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建tomcat文件夹</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line"># 解压</span><br><span class="line">tar -zvxf xxx(你的tomcat包名) -C &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line"># 重命名</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">mv  xxx(你的tomcat包名) tomcat8</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212094351216.png" alt="image-20201212094351216" style="zoom:50%;" />
<h3 id="3-防火墙开放端口"><a class="markdownIt-Anchor" href="#3-防火墙开放端口"></a> 3. 防火墙开放端口</h3>
<p>查看防火墙开放情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212094507455.png" alt="image-20201212094507455" style="zoom:50%;" />
<p>如果显示<code>-bash: firewall-cmd: 未找到命令</code>,证明没有防火墙。下方是防火墙的相关操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装防火墙</span><br><span class="line">yum install firewalld</span><br><span class="line"># 开启防火墙</span><br><span class="line">systemtcl start firewalld</span><br><span class="line"># 开放8080与3306端口，然后重启防火墙</span><br><span class="line">firewalld-cmd --add-port&#x3D;8080&#x2F;tcp --permanent</span><br><span class="line">firewalld-cmd --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 重新查看开放端口列表</span><br><span class="line">firewalld-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p>如图显示，则端口开启成功</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212095454503.png" alt="image-20201212095454503" style="zoom:50%;" />
<h3 id="4-开启tomcat尝试外部访问"><a class="markdownIt-Anchor" href="#4-开启tomcat尝试外部访问"></a> 4. 开启tomcat，尝试外部访问</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 有关tomcat的脚本都在bin目录下，bat后缀为windows用户的脚本</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;tomcat8&#x2F;bin &amp;&amp; ls</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212095835339.png" alt="image-20201212095835339" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行tomcat</span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure>
<p>尝试外部访问：在浏览器中输入VPS的ip:8080。如图，tomcat部署成功！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212100051835.png" alt="image-20201212100051835" style="zoom:50%;" />
<h3 id="5-配置开机启动"><a class="markdownIt-Anchor" href="#5-配置开机启动"></a> 5. 配置开机启动</h3>
<p>创建tomcat8系统服务文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tomcat8.service</span><br></pre></td></tr></table></figure>
<p>然后在文件中粘贴如下内容，保存后退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Tomcat8</span><br><span class="line">After&#x3D;syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;shutdown.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>最后启用tomcat8系统配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable tomcat8</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212100604097.png" alt="image-20201212100604097" style="zoom:50%;" />
<hr />
<h2 id="四-导入javaweb项目的sql文件到vps的数据库中"><a class="markdownIt-Anchor" href="#四-导入javaweb项目的sql文件到vps的数据库中"></a> 四、导入javaweb项目的sql文件到VPS的数据库中</h2>
<p><strong>注意：以下命令一行一行逐渐执行，不是直接复制粘贴</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装上传下载工具</span><br><span class="line">cd ~ &amp;&amp; yum install lrzsz</span><br><span class="line"># 上传</span><br><span class="line">rz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入mysql</span><br><span class="line">mysql -uroot -p</span><br><span class="line"># 查看数据库</span><br><span class="line">show databases;</span><br><span class="line"># 新建数据库</span><br><span class="line">creat database xxx(你的数据库名) default charater set utf8 collate utf8_general_ci;</span><br><span class="line"># 使用数据库</span><br><span class="line">use xxx(你的数据库名)</span><br><span class="line"># 导入你的sql文件，路径为你sql文件的路径</span><br><span class="line">source &#x2F;xxx&#x2F;xxx&#x2F;xxx.sql;</span><br><span class="line"># 查看sql文件的table，是否导入成功</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212103535073.png" alt="image-20201212103535073" style="zoom:50%;" />
<p>导入sql成功！现在VPS数据库中已经有我们的数据表了！</p>
<hr />
<h2 id="五-上传war包到vps中"><a class="markdownIt-Anchor" href="#五-上传war包到vps中"></a> 五、上传war包到VPS中</h2>
<p>先在IDEA打包好war包，打包方法参考：<a href="https://blog.csdn.net/qq_1290259791/article/details/78619353">intellij idea打包war包</a>。</p>
<p>我们使用<code>rz</code>命令把war包上传到tomcat8里的wabapps文件夹下。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212104332240.png" alt="image-20201212104332240" style="zoom:50%;" />
<p>稍等一下，我们再查看一下webapps有什么变化。可以看到上传pet.war后还多了一个pet文件，原因是tomcat帮我们把war项目自动解析了。这个pet就是我们运行中的pet项目。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212104528197.png" alt="image-20201212104528197" style="zoom:50%;" />
<p>此时我们访问尝试访问 <strong>ip:8080/项目路径</strong>，如无意外，项目访问成功。但我部署项目中就很少没有意外的，这次我就404了……</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212145923339.png" alt="image-20201212145923339" style="zoom:50%;" />
<hr />
<h2 id="六-故障解决"><a class="markdownIt-Anchor" href="#六-故障解决"></a> 六、故障解决</h2>
<h3 id="1-访问出现404"><a class="markdownIt-Anchor" href="#1-访问出现404"></a> 1. 访问出现404</h3>
<p>javaweb部署导致404出现的原因有挺多种的，当然我们可以选择Google、Baidu，但其实最快、最稳妥的办法就是<strong>查看tomcat的日志</strong>。访问不了tomcat会给出针对性的报错原因的。</p>
<p>tomcat的日志在/xxx(tomcat安装目录)/logs/catalina.out</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212150457465.png" alt="image-20201212150457465" style="zoom:50%;" />
<p>查看日志最后100行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 100 catalina.out</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-12_14-56-28.jpg" alt="Xnip2020-12-12_14-56-28" style="zoom:50%;" />
<p>一眼就看出是MySQL的问题！导致这个原因一般只有两个：首先是jdbc文件mysql配置信息错误，不然就是数据库版本不对。</p>
<p>打开idea，查看项目的jdbc配置文件，果然这里的password忘记更改成VPS数据库的密码了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212151256298.png" alt="image-20201212151256298" style="zoom:50%;" />
<p>重新编译，打包war包。</p>
<p>删除VPS中tomcat/webapps中的项目war包 和 自动解析生成的项目文件夹</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212151758556.png" alt="image-20201212151758556" style="zoom:50%;" />
<p>然后重新上传新打包的war包，然后等待大概两分钟（tomcat要重新部署新的war包），过后我们再尝试尝试访问 ip:8080/项目文件。</p>
<p>然后然后……总是如此曲折</p>
<h3 id="2-样式不见了"><a class="markdownIt-Anchor" href="#2-样式不见了"></a> 2. 样式不见了……</h3>
<p>真是天秀～，查看log也没有报错。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212152345134.png" alt="image-20201212152345134" style="zoom:40%;" />
<p>那就F12，看看Console，所有的何css、js资源都无法获取，</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-12_15-58-19.jpg" alt="Xnip2020-12-12_15-58-19" style="zoom:50%;" />
<p>网络搜索了一下，在这里<a href="https://www.geek-share.com/detail/2744094259.html">这篇文章</a>里获取到了一点点思路，是获取的路径有问题。那么我们在本地idea上编译然后F12，对比看看</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-13_15-01-19.jpg" alt="Xnip2020-12-13_15-01-19" style="zoom: 40%;" />
<p>从上图我们可以看到，我们的资源多了一个项目名称的目录，index自然获取不到在外部的resources里的css、js文件。可是当时为这个问题已经折腾了一整天了，完完整整的一天，思路已经被局限，没有想到在webapps下的ROOT目录。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213150725829.png" alt="image-20201213150725829" style="zoom:50%;" />
<p>在晚上9点折腾无果后，决定加Roothub项目作者交流一下，看看能否获得提示。第二天交流后有一句话给了我提示：“可以设置根路径访问的。”一句惊醒梦中人～</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-13_14-30-10.jpg" alt="Xnip2020-12-13_14-30-10" style="zoom:50%;" />
<p>想到我们直接输入ip访问的Apache Tomcat的首页是部署在ROOT目录下的，这个就是tomcat的根目录呀。那我直接把ROOT下的文件替换成我的<strong>项目下的所有文件</strong>能不能直接访问呢？</p>
<p>但不知道为何，使用命令行无法操作ROOT这个目录，想要cp备份不行，cd进入也不行，rm也不行。只好使用FinalShell的图形界面操作了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213153848470.png" alt="image-20201213153848470" style="zoom:50%;" />
<p>在替换操作之后，VPS监控到CPU占用率马上提高，可能是tomcat已经在部署项目了。等CPU占比下来后，访问 ip:8080，成功访问。</p>
<p>其实这种做法是一种折中的解决办法吧，那假如我还有其他要部署的项目呢？还是直接覆盖ROOT目录？这样就在一台VPS下只能存在一个javaweb项目了。这显然是不合理的。</p>
<p>综合搜索资料后分析，出现这种情况大概是原项目作者在开发时使用的是绝对路径。但具体怎么回事目前还未有足够时间去深究，以后有机会再研究。</p>
<hr />
<h2 id="七-域名访问项目"><a class="markdownIt-Anchor" href="#七-域名访问项目"></a> 七、域名访问项目</h2>
<p>这里重点讲述tomcat的配置，域名解析什么的就略过吧。相关配置在tomcat/conf/server.xml。</p>
<h3 id="1-修改成80端口访问"><a class="markdownIt-Anchor" href="#1-修改成80端口访问"></a> 1. 修改成80端口访问</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213161121091.png" alt="image-20201213161121091" style="zoom:50%;" />
<h3 id="3-改域名"><a class="markdownIt-Anchor" href="#3-改域名"></a> 3. 改域名</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi server.xml</span><br></pre></td></tr></table></figure>
<p>需要修改两个地方：进入vi后，键入<code>esc</code>，直接键入<code>/</code> ，然后输入Engine，回车。把localhost修改成自己的域名。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213162200088.png" alt="image-20201213162200088" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201213162403247.png" alt="image-20201213162403247" style="zoom:50%;" />
<p>最后重启tomcat即可！</p>
<blockquote>
<p>MySQL参考：<a href="https://www.jianshu.com/p/1dab9a4d0d5f">https://www.jianshu.com/p/1dab9a4d0d5f</a></p>
<p>tomcat部署参考：<a href="https://ken.io/note/centos7-tomcat-setup">https://ken.io/note/centos7-tomcat-setup</a></p>
<p>部署到根目录参考：<a href="https://www.cnblogs.com/xdot/p/8418655.html">https://www.cnblogs.com/xdot/p/8418655.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>常用linux脚本记录</title>
    <url>/2021/12/05/%E5%B8%B8%E7%94%A8%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211205110525139.png" alt="image-20211205110525139" /></p>
<p>linux有非常多好用的一键脚本加快效率，在此做个记录。</p>
<a id="more"></a>
<h2 id="1-添加swap"><a class="markdownIt-Anchor" href="#1-添加swap"></a> 1. 添加swap</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;files.ioiox.com&#x2F;projects&#x2F;swap&#x2F;swap.sh &amp;&amp; chmod +x swap.sh &amp;&amp; .&#x2F;swap.sh</span><br></pre></td></tr></table></figure>
<h2 id="2-lnmp一键可选择安装"><a class="markdownIt-Anchor" href="#2-lnmp一键可选择安装"></a> 2. lnmp一键可选择安装</h2>
<p>oneinstack：<a href="https://oneinstack.com/auto/">https://oneinstack.com/auto/</a></p>
<h2 id="3-改成上海时间"><a class="markdownIt-Anchor" href="#3-改成上海时间"></a> 3. 改成上海时间</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.删除自带的localtime</span><br><span class="line">rm -rf &#x2F;etc&#x2F;localtime</span><br><span class="line"># 2.创建软链接到localtime</span><br><span class="line">ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure>
<h2 id="4-卸载python3"><a class="markdownIt-Anchor" href="#4-卸载python3"></a> 4. 卸载python3</h2>
<p>用于把python3.7换成python3.5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 卸载</span><br><span class="line">rpm -qa|grep python3|xargs rpm -ev --allmatches --nodeps</span><br><span class="line"># 删除所有残余文件</span><br><span class="line">whereis python3 |xargs rm -frv </span><br><span class="line"># 查看现有安装的python</span><br><span class="line">whereis python </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（一）｜macOS入门使用树莓派3B+</title>
    <url>/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>最近，苹果手机坏了，暂时用回一加6古董机。iOS的捷径可以实现每日闹钟停止后可以自动播放网易云音乐的每日推荐歌曲，这个功能真的太喜欢了。但是会有10%的几率播放失败，而且安卓系统并没有类似功能。可能你会想到目前的智能音箱调闹钟不就可以了吗？首先，智能音箱对网络依赖极强，网络故障啥都干不了。其次，智能音箱并没有对接到网易云的每日推荐歌单，闹钟播放的歌曲都是随机的。</p>
<p>因此，作为一个geek，还是自己亲手打造一个可以播放网易云每日推荐歌曲的闹钟吧！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219132040671.png" alt="image-20201219132040671" style="zoom:50%;" />
<a id="more"></a>
<hr />
<h2 id="一-烧录镜像"><a class="markdownIt-Anchor" href="#一-烧录镜像"></a> 一、烧录镜像</h2>
<h3 id="1-格式化内存卡"><a class="markdownIt-Anchor" href="#1-格式化内存卡"></a> 1. 格式化内存卡</h3>
<p>macOS使用SD Memory Card Formatter格式化内存卡，<a href="https://www.sdcard.org/downloads/formatter/eula_mac/index.html">点击此处</a>进入官网下载。（拉到最下面点击accept）</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201219113330224.png" alt="image-20201219113330224" /></p>
<p>打开SD Card Formatter，按照下图操作。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219105251370.png" alt="image-20201219105251370" style="zoom:50%;" />
<p>如下，证明格式化成功</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219105330442.png" alt="image-20201219105330442" style="zoom:50%;" />
<h3 id="2-下载树莓派镜像文件"><a class="markdownIt-Anchor" href="#2-下载树莓派镜像文件"></a> 2. 下载树莓派镜像文件</h3>
<p><a href="https://www.raspberrypi.org/software/operating-systems/">点击此处</a>进入下载页面，我这里下载Lite版的，下载完后<strong>不用解压</strong>。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219110531165.png" alt="image-20201219110531165" style="zoom:25%;" />
<h3 id="3-下载烧录工具"><a class="markdownIt-Anchor" href="#3-下载烧录工具"></a> 3. 下载烧录工具</h3>
<p>macOS可以使用 Etcher烧录树莓派，戳这里进入官网：<a href="https://etcher.io/">https://etcher.io</a></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219110853874.png" alt="image-20201219110853874" style="zoom: 33%;" />
<p>选择你刚才下载的镜像（zip 格式），然后选择你的储存卡，点 Flash！即可烧录系统。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219111417310.png" alt="image-20201219111417310" style="zoom:33%;" />
<p>耐心等待一段时间，大概需要5分钟就可烧录成功。</p>
<p><strong>注意：烧录后TF卡名字会变为：<code>boot</code>。</strong></p>
<h3 id="4-编写ssh连接与wifi配置文件"><a class="markdownIt-Anchor" href="#4-编写ssh连接与wifi配置文件"></a> 4. 编写ssh连接与wifi配置文件</h3>
<p>新建两个<code>txt</code>文件，分别命名为：<code>ssh</code>、<code>wpa_supplicant.conf</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219112541652.png" alt="image-20201219112541652" style="zoom:50%;" />
<ul>
<li>
<p><code>ssh</code>文件是没有后缀的</p>
</li>
<li>
<p><code>wpa_supplicant.conf</code>写入下面信息：</p>
<blockquote>
<ol>
<li>SSID名字中不能有符号<code>.</code></li>
<li>优先级范围为1-10</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country&#x3D;CN</span><br><span class="line">ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant Group&#x3D;netdev</span><br><span class="line">update_config&#x3D;1</span><br><span class="line"></span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;Wifi1的名字&quot;</span><br><span class="line">	psk&#x3D;&quot;密码&quot;</span><br><span class="line">	priority&#x3D;优先级，越大越优先</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;Wifi2的名字&quot;</span><br><span class="line">	psk&#x3D;&quot;密码&quot;</span><br><span class="line">	priority&#x3D;优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然后将这两个文件移动至烧录系统镜像后TF卡的根目录。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219113232972.png" alt="image-20201219113232972" style="zoom:50%;" />
</li>
</ul>
<blockquote>
<p><strong>在Finder中推出TF卡！！！</strong> 要养成好习惯！不然容易烧卡！</p>
<p><strong>在Finder中推出TF卡！！！</strong> 要养成好习惯！不然容易烧卡！</p>
</blockquote>
<hr />
<h2 id="二-准备开机"><a class="markdownIt-Anchor" href="#二-准备开机"></a> 二、准备开机</h2>
<blockquote>
<p>树莓派3B+的电源要求是5V 2.5A的，最好不要太低，否则会损坏机器。（近300块啊）</p>
</blockquote>
<h3 id="1-ssh连接"><a class="markdownIt-Anchor" href="#1-ssh连接"></a> 1. ssh连接</h3>
<p>进入到我们的路由器中，然后查看树莓派的IP地址。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219115812140.png" alt="image-20201219115812140" style="zoom:50%;" />
<p>ssh工具推荐使用FinalShell，按下图填写</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219120353131.png" alt="image-20201219120353131" style="zoom: 33%;" />
<p>连接成功。可以看到会提示让我们修改ssh密码，但是因为我日常忘记各种密码，我就直接用默认的吧。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219123856310.png" alt="image-20201219123856310" style="zoom:33%;" />
<h2 id="三-系统设置"><a class="markdownIt-Anchor" href="#三-系统设置"></a> 三、系统设置</h2>
<h3 id="1-软件源更改"><a class="markdownIt-Anchor" href="#1-软件源更改"></a> 1. 软件源更改</h3>
<p>一定要更改源，不然下载程序会非常慢。这里改成清华源。</p>
<p>（1）先安装vim（你可以使用nano或者vi，我个人喜欢vim）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>（2）修改<code>source.list</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<p>先把里面的<strong>所有内容都注释掉</strong>，然后增加下面两行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br></pre></td></tr></table></figure>
<p>（3）再修改<code>raspi.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list</span><br></pre></td></tr></table></figure>
<p>同样，先把里面的<strong>所有内容都注释掉</strong>，然后增加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure>
<p>（4）最后，进行更新</p>
<blockquote>
<p><strong>第二条命令执行时间会比较长。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="2-更改时区"><a class="markdownIt-Anchor" href="#2-更改时区"></a> 2. 更改时区</h3>
<p>查看时区是否为你的当地时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>如果不是，执行命令更改成Asia-Shanghai</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219134431642.png" alt="image-20201219134431642" style="zoom:50%;" />
<p>基本设置done！</p>
<hr />
<h2 id="四-关闭派不能直接拔出电源"><a class="markdownIt-Anchor" href="#四-关闭派不能直接拔出电源"></a> 四、关闭派不能直接拔出电源！！</h2>
<p>注意⚠️：</p>
<p><strong>关闭树莓派不能直接拔出电源！！！</strong></p>
<p>正确关闭树莓派方法是：先执行<code>sudo halt</code>，然后等待只有电源指示灯亮的时候（或者等待20s），再拔电源。</p>
<hr />
<p>下一篇我们利用Node.js版本的网易云api<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/">NeteaseCloudMusicApi</a>，写一个py脚本，实现定时播放网易云音乐每日推荐歌曲。</p>
<hr />
<h2 id="五-相关文章"><a class="markdownIt-Anchor" href="#五-相关文章"></a> 五、相关文章</h2>
<ol>
<li><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></li>
<li><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（三）| 使用「网易云音乐 NodeJS 版 API 接口」播放每日推荐歌曲</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/#more">智能闹钟（四）-整合搭建</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/#more">智能闹钟（五）｜如何优雅地关闭闹钟？</a></li>
</ol>
<br/>
<br/>
<p>参考资料：</p>
<p><a href="https://stepneverstop.github.io/burn-system2raspberry-in-macos.html">https://stepneverstop.github.io/burn-system2raspberry-in-macos.html</a></p>
<p><a href="https://sspai.com/post/37356">https://sspai.com/post/37356</a></p>
<p><a href="https://www.icxbk.com/article/detail/1077.html">https://www.icxbk.com/article/detail/1077.html</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（三）| 使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲</title>
    <url>/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89%7C%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201222151927493.png" alt="image-20201222151927493" style="zoom:50%;" />
<a id="more"></a>
<hr />
<h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2>
<ol>
<li>
<p>使用前请仔细查看里面的<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%b0%83%e7%94%a8%e5%89%8d%e9%a1%bb%e7%9f%a5">调用前须知</a></p>
</li>
<li>
<p>进行简单的需求分析：</p>
</li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222153644738.png" alt="image-20201222153644738" style="zoom:45%;" />
<br/>
<h2 id="一-搭建api"><a class="markdownIt-Anchor" href="#一-搭建api"></a> 一、搭建API</h2>
<p>我个人选择了把接口搭建在<strong>VPS</strong>中，7x24x365在线，等调试好语音识别模块后再部署到树莓派上。但如果你的是是国外的服务器，请仔细阅读一下文档内的「<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%b0%83%e7%94%a8%e5%89%8d%e9%a1%bb%e7%9f%a5">调用前须知</a>」，里面有提示相关的注意事项。当然，如果仅仅学习API的调用的话，我们可以搭建在本机电脑中。</p>
<blockquote>
<p>注意⚠️：<strong>以下所有步骤均默认在管理员（root）用户下进行</strong></p>
</blockquote>
<br/>
<h3 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Binaryify&#x2F;NeteaseCloudMusicApi.git</span><br><span class="line"># 进入到项目文件内</span><br><span class="line">cd xxx&#x2F;xxx&#x2F;NeteaseCloudMusicApi  </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-运行"><a class="markdownIt-Anchor" href="#2-运行"></a> 2. 运行</h3>
<h4 id="1在vps运行"><a class="markdownIt-Anchor" href="#1在vps运行"></a> （1）在「VPS」运行</h4>
<p>要想API 7x24x365 在线，让项目保持后台运行就可以。我这里运用了比较简单的方法：<code>screen</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd NeteaseCloudMusicApi</span><br><span class="line"># 新建一个名为NeteaseCloud的screen</span><br><span class="line">screen -S NeteaseCloud</span><br><span class="line"># 在新生成的窗口中运行API</span><br><span class="line">node app.js</span><br><span class="line"># 然后就可以放心把窗口关掉了</span><br></pre></td></tr></table></figure>
<br/>
<p><strong>在开放<code>3000</code>端口后</strong>，我们尝试访问<code>http://VPS的ip:3000</code>。如无意外，我们会看到：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222160756839.png" alt="image-20201222160756839" style="zoom:33%;" />
<p><br/>那么我们如何恢复<code>screen</code>呢？</p>
<blockquote>
<p>注意⚠️：恢复<code>screen</code>一定要在新建<code>screen</code>的用户下进行。我上面是进入到了<code>root</code>中</p>
</blockquote>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line"># 查看所有screen</span><br><span class="line">screen -ls </span><br><span class="line"># 找到我们的NeteaseCloud</span><br><span class="line">screen -r screen的id</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222161602742.png" alt="image-20201222161602742" style="zoom: 50%;" />
<p>想要关闭<code>screen</code>，我们可以看到上图有提示：<code>1 Socket in /var/run/screen/S-root</code>，我们进入到这个文件夹删除相应的文件，就可以关闭<code>screen</code>了。</p>
<br/>
<h4 id="2在本地电脑运行"><a class="markdownIt-Anchor" href="#2在本地电脑运行"></a> （2）在「本地电脑」运行</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 想要运行项目，仍然要进入项目文件夹中</span><br><span class="line">cd NeteaseCloudMusicApi</span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="3修改端口运行"><a class="markdownIt-Anchor" href="#3修改端口运行"></a> （3）「修改端口」运行</h4>
<p>服务器启动默认端口为 3000，若想使用其他端口，请先将你的端口放行，然后使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mac&#x2F;Linux</span><br><span class="line">PORT&#x3D;4000 node app.js</span><br><span class="line"># windows</span><br><span class="line">set PORT&#x3D;4000 &amp;&amp; node app.js</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="二-登陆"><a class="markdownIt-Anchor" href="#二-登陆"></a> 二、登陆</h2>
<blockquote>
<p>文档里面提供了手机、邮箱两种登陆方式，但<strong>使用邮箱登陆会返回<code>402</code>错误码</strong>，我们直接使用手机登陆。</p>
</blockquote>
<p>接口地址 : <code>/login/cellphone</code></p>
<p>调用例子 : <code>/login/cellphone?phone=xxx&amp;password=yyy</code></p>
<p>要注意：下面的大部分接口都要登陆成功后才能使用，而登陆接口<code>response</code>信息中会有带有<code>cookie</code>，所以我们要使用<code>session()</code>来保持登陆状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">phone = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">pwd = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    login_url = url + <span class="string">&#x27;/login/cellphone&#x27;</span></span><br><span class="line">    login = s.get(login_url, data=&#123;<span class="string">&#x27;phone&#x27;</span>: phone, </span><br><span class="line">                                   <span class="string">&#x27;password&#x27;</span>: pwd&#125;)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> login.status_code <span class="keyword">is</span> <span class="number">200</span>:</span><br><span class="line">            print(<span class="string">&#x27;恭喜！登陆成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;Exception&#x27;</span>,e)</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="三-获取所有每日推荐歌曲信息"><a class="markdownIt-Anchor" href="#三-获取所有每日推荐歌曲信息"></a> 三、获取所有每日推荐歌曲信息</h2>
<p><strong>使用该接口需要完成「登陆」后才能使用。</strong></p>
<p>接口地址 : <code>/recommend/songs</code></p>
<p>调用例子 : <code>/recommend/songs</code></p>
<p>我们尝试使用<code>postman</code>请求接口，<code>response</code>信息如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222180112139.png" alt="image-20201222180112139" style="zoom: 33%;" />
<br/>
<p>仔细看会发现会发现，<code>response</code>中是没有歌曲播放<code>url</code>的！那怎么播放歌曲呢？</p>
<p>别急，我们仔细思考一下，唯一能识别出一首歌的标志只有<code>id</code>，那会不会有其他接口可以通过<code>id</code>获得可流媒体播放的<code>url</code>呢？</p>
<p>翻遍了文档终于找到<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%8e%b7%e5%8f%96%e9%9f%b3%e4%b9%90-url">相关信息</a>。（我觉得作者应该把该接口放在更前面的位置）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222180707359.png" alt="image-20201222180707359" style="zoom: 33%;" />
<br/>
<p>我们使用postman请求，观察<code>response</code>数据结构。然后开始编码通过<code>id</code>获取播放<code>url</code>，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取每日推荐歌曲id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSongs_id</span>():</span></span><br><span class="line">    <span class="comment"># 获取每日推荐歌曲字典</span></span><br><span class="line">    dailySongs_url = url + <span class="string">&#x27;/recommend/songs&#x27;</span></span><br><span class="line">    dailySongs_object = s.get(dailySongs_url)</span><br><span class="line">    songs_dict = dailySongs_object.json()  </span><br><span class="line">    <span class="comment"># 0~31首</span></span><br><span class="line">    <span class="keyword">for</span> list_index <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        song_id.append(songs_dict[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;dailySongs&#x27;</span>][list_index][<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> song_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取播放url</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSongs_url</span>():</span></span><br><span class="line">    getSongs_url = url + <span class="string">&#x27;/song/url&#x27;</span></span><br><span class="line">    <span class="comment"># 传入song_id[]作为data</span></span><br><span class="line">    song_id = getSongs_id()</span><br><span class="line">    song_url_object = s.post(getSongs_url, data=&#123;<span class="string">&#x27;id&#x27;</span>:song_id&#125;)</span><br><span class="line">    song_url_dict = song_url_object.json()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        songs_url.append(song_url_dict[<span class="string">&#x27;data&#x27;</span>][i][<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> songs_url</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="四-播放音乐"><a class="markdownIt-Anchor" href="#四-播放音乐"></a> 四、播放音乐</h2>
<p>参考了网络资料，在Linux中播放音乐有几种选择，用得比较多的是<code>pygame</code>和<code>mplayer</code>。但不知什么原因我树莓派一直装不了<code>pygame</code>，所以最终选择了<code>mplayer</code>作为我的播放器。</p>
<h3 id="1-安装mplayer"><a class="markdownIt-Anchor" href="#1-安装mplayer"></a> 1. 安装mplayer</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mplayer</span><br></pre></td></tr></table></figure>
<h3 id="2-调整树莓派声音输出"><a class="markdownIt-Anchor" href="#2-调整树莓派声音输出"></a> 2. 调整树莓派声音输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入系统设置</span><br><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p>依次进入：<code>System Options</code> - <code>Audio</code> - <code>Headphones</code>，最后一定要选择<code>&lt;Finish&gt;</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219181840492.png" alt="image-20201219181840492" style="zoom:50%;" />
<h3 id="3-重启"><a class="markdownIt-Anchor" href="#3-重启"></a> 3. 重启！！！</h3>
<p>设置完声卡之后，一定要重启系统！不然不会生效。在这里卡了挺久的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="4-基本使用方式"><a class="markdownIt-Anchor" href="#4-基本使用方式"></a> 4. 基本使用方式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mplayer file&#x2F;url</span><br></pre></td></tr></table></figure>
<p>但要如何在python脚本中调用<code>mplayer</code>呢？使用<code>os.system('cmd' %s)</code>或<code>Subprocess.Popen('cmd')</code>，具体区别可以参考<a href="https://blog.csdn.net/taohuaxinmu123/article/details/48828255">这篇文章</a>，一句话说完就是：前者比较老旧，但会显示<code>cmd</code>命令执行的信息；后者强大，支持多种参数和模式，但没有输出信息。</p>
<p>在整个项目中我们两个模块都会用到，在播放音乐部分我们使用前者，后面「渐入渐出部分」我们再使用后者。</p>
<br/>
<p>先尝试播放日推第一首歌。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从左到右解析一下代码：单引号<code>''</code>里的内容就是<code>os.system('cmd')</code>中的<code>cmd</code>，<code>&quot;%s&quot;</code>是<code>str</code>类型的参数，输出<code>&gt;</code>（重定向）到<code>/dev/null 2&gt;&amp;1</code>文件，该文件会像黑洞一样吞噬所有的输入，同时也不会获得任何输出，单引号<code>''</code>部分的代码意思是mplayer播放%s的url，且不输出信息。更详细的意思请看<a href="https://blog.csdn.net/ithomer/article/details/9288353">这里</a>。后面的<code>%</code> 和 <code>song_url[0]</code>中间是有个空格的，这个就是传到<code>&quot;%s&quot;</code>的参数。</p>
</blockquote>
<br/>
<p>要播放32首歌曲，可以写个<code>for</code>循环，重复执行mplayer的播放操作即可。</p>
<p>这部分代码整合到了下方的「优化播放流程」当中。</p>
<br/>
<p><strong>至此，文章一开头的需求分析全部模块已经基本完成，但仍有优化空间</strong></p>
<hr />
<h2 id="五-项目优化整合"><a class="markdownIt-Anchor" href="#五-项目优化整合"></a> 五、项目优化整合</h2>
<p><strong>我们做项目应该更贴近生活考虑，带给用户更好的体验</strong>，所以还得在细节中下点功夫。</p>
<h3 id="1-优化播放流程"><a class="markdownIt-Anchor" href="#1-优化播放流程"></a> 1. 优化播放流程</h3>
<p>早上醒来<strong>意识是不清醒</strong>的，第一时间播放「天气」肯定听不清楚，而且完全没让人有个好心情啊！所以「天气播报」应该往后捎捎。由此大概确定项目的完整播放流程为：先播放一到两首歌，然后「天气播报」，然后再播放剩下的歌曲。</p>
<p>同时，我们大概率会在第一次播放时听不清楚具体温度，所以我们应该做两次天气的播报。</p>
<blockquote>
<p>注意⚠️：下方代码<code>line</code> <code>12</code>播放天气文件的py脚本，要填写绝对路径！绝对路径！不然无法播放天气！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 播放模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playmusic</span>():</span></span><br><span class="line">    <span class="comment"># getSongs_url()函数在上面以实现</span></span><br><span class="line">    songs_url = getSongs_url()</span><br><span class="line">    print(<span class="string">&#x27;开始播放音乐&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&#x27;第一首歌&#x27;</span>)</span><br><span class="line">        <span class="comment"># 先播放第一首</span></span><br><span class="line">        os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 播放两次天气</span></span><br><span class="line">        print(<span class="string">&#x27;播放天气&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        	os.system(<span class="string">&#x27;python /tmp/clock/TextToVoice.py&#x27;</span>)</span><br><span class="line">        <span class="comment"># 开始随机播放2～32首</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            <span class="comment"># print(&#x27;播放第&#x27; + str(i) + &#x27;首&#x27;)</span></span><br><span class="line">            os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[i])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;Exception&#x27;</span>, e)</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-渐入播放"><a class="markdownIt-Anchor" href="#2-渐入播放"></a> 2. 渐入播放</h3>
<p>如果播放的音乐一开始非常大声，我们很容易受惊。</p>
<p>所以在播放第一首歌时，渐入。我们可以有两种设计方式，第一种是通过mplayer的<code>slave</code>模式修改，另一种通过<code>amixer</code>修改Linux系统的声音。这里我选择后者，相对来说会更简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amxier调音量基本使用</span></span><br><span class="line">amixer sset 声卡名字(str类型) volume音量(volume%)</span><br><span class="line"><span class="comment"># 例如：amixer sset Headphone 20%</span></span><br></pre></td></tr></table></figure>
<br/>
<p>思路：使用一个<code>for</code>循环，先从一个低音量开始，在<code>range()</code>里面每次递增%<code>1</code>，在每一次循环（递增）中，都会有0.3秒的延迟，这样就实现了较为顺滑的渐入操作。</p>
<p>在python里面控制<code>amixer</code>模块，这次我们尝试使用<code>subprocess.Popen(cmd)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slowUp</span>():</span></span><br><span class="line">    <span class="comment"># %0 and %100</span></span><br><span class="line">    volume = <span class="number">65</span></span><br><span class="line">    <span class="comment"># 每次增加%1，一直从 %65 ～ %90</span></span><br><span class="line">    <span class="keyword">for</span> volume <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 延迟 0.3 秒递增</span></span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">        command = [<span class="string">&quot;amixer&quot;</span>, <span class="string">&quot;sset&quot;</span>, <span class="string">&quot;Headphone&quot;</span>, <span class="string">&quot;&#123;&#125;%&quot;</span>.format(volume)]</span><br><span class="line">        subprocess.Popen(command)</span><br></pre></td></tr></table></figure>
<br/>
<p><strong>但有个很重要的问题</strong>：我们要怎么使用这个渐入函数呢？直接嵌入到播放第一首歌前面吗？肯定不对的，因为程序会先执行完<code>slowUp()</code>函数完成了音量的递增之后，再开始播放音乐。这样是毫无意义的。</p>
<p><strong>有两个解决办法。</strong></p>
<p>第一个是多线程，但对多线程不太熟悉，用不好可能很容易崩，以后详细学习后，再进行代码重构。</p>
<p>第二种就比较机灵点：设置<strong>两个时间一样</strong>的<code>crontab</code>任务，一个执行播放音乐的py脚本，另一个执行渐入渐入的脚本。也就是把多线程这件事交给了<code>crontab</code>！</p>
<p><strong>夸夸自己，真是太机智了！</strong></p>
<hr />
<h2 id="六-设置crontab定时执行脚本"><a class="markdownIt-Anchor" href="#六-设置crontab定时执行脚本"></a> 六、设置crontab定时执行脚本</h2>
<p>说好的是闹钟嘛，我们不能忘记自己最根本的需求。我们把这件事交给<code>crontab</code>就可以。</p>
<h3 id="1-更改树莓派时间"><a class="markdownIt-Anchor" href="#1-更改树莓派时间"></a> 1. 更改树莓派时间</h3>
<p>一般树莓派刷机完后，时间都不会是中国时区的时间，所以我们要先更改到中国上海的。如何更改时区请查看：<a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></p>
<h3 id="2-设置crontab任务"><a class="markdownIt-Anchor" href="#2-设置crontab任务"></a> 2. 设置crontab任务</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&amp;&gt;&gt; /home/clock/log.log</code>表示脚本输出内容到log.log中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分 小时 星期 月 年 command</span></span><br><span class="line"><span class="comment"># 执行主脚本Netease.py播放天气，注意要使用绝对路径！</span></span><br><span class="line"><span class="number">00</span> <span class="number">7</span> * * * python /home/clock/Netease.py &amp;&gt;&gt; /home/clock/log.log</span><br><span class="line"><span class="comment"># 执行VolControl.py渐入，注意要使用绝对路径！</span></span><br><span class="line"><span class="number">00</span> <span class="number">7</span> * * * python /home/clock/VolControl.py</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="六-end总结"><a class="markdownIt-Anchor" href="#六-end总结"></a> 六、END&amp;总结</h2>
<p>这篇文章介绍了如何使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲，看起来顺风顺水，实际上遇到的坑真的数不过来。但我们一定要「<strong>善于思考，善于记录</strong>」，坚持每天输出一些内容，到最后就掌握越来越多技能。</p>
<p>下一篇文章，详细讲一下部署项目的部署问题。源代码也将整合。</p>
<br/>
<br/>
<h5 id="相关文章"><a class="markdownIt-Anchor" href="#相关文章"></a> 相关文章</h5>
<ol>
<li><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></li>
<li><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/#more">智能闹钟（四）-整合搭建</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/#more">智能闹钟（五）｜如何优雅地关闭闹钟？</a></li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气播报</title>
    <url>/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201221175630831.png" alt="image-20201221175630831" style="zoom:30%;" />
<a id="more"></a>
<br/>
<p><strong>每日天气提醒</strong>在我的生活中时非常有必要的，对我<strong>每日的出行</strong>会有巨大帮助。因此，智能闹钟项目要考虑加入天气播报功能。该功能可以使用免费的「和风天气」提供的api来实现。</p>
<hr />
<h2 id="一-需求分析"><a class="markdownIt-Anchor" href="#一-需求分析"></a> 一、需求分析</h2>
<p>首先我们得明白需求：</p>
<ol>
<li>
<p>实况天气：参考出门穿什么衣服、是否需要带伞</p>
<p>对应「实况天气」开发版接口：<a href="https://devapi.qweather.com/v7/weather/now">https://devapi.qweather.com/v7/weather/now</a>?</p>
<p>需要获得的数据如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221165538314.png" alt="image-20201221165538314" style="zoom:30%;" />
<br/>
</li>
<li>
<p>每天最低、最高温度：参考整体温度</p>
</li>
<li>
<p>日落时间：希望每天都可以看到好看的晚霞</p>
<p>2、3需求对应「3天预报」开发版接口：<a href="https://devapi.qweather.com/v7/weather/3d">https://devapi.qweather.com/v7/weather/3d</a>?</p>
<p>需要获得的数据如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221165738406.png" alt="image-20201221165738406" style="zoom:33%;" />
</li>
</ol>
<blockquote>
<p>⚠️注意：日落时间可以用「天气预报」、「太阳和月亮」两个接口获得，但使用前者非常简单。</p>
</blockquote>
<h2 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h2>
<h3 id="1-获取实况温度与实况状态"><a class="markdownIt-Anchor" href="#1-获取实况温度与实况状态"></a> 1. 获取实况温度与实况状态</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNowWeather</span>():</span></span><br><span class="line">    <span class="comment"># 开发版接口地址</span></span><br><span class="line">    url = <span class="string">&#x27;https://devapi.qweather.com/v7/weather/now?&#x27;</span></span><br><span class="line">    <span class="comment"># 接口参数</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="comment"># 你的城市id</span></span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="comment"># 和风天气key</span></span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="comment"># 使用gzip可较少延迟</span></span><br><span class="line">        <span class="string">&#x27;gzip&#x27;</span>: <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    html = requests.get(url, params)</span><br><span class="line">    content = html.json()</span><br><span class="line">    now_temp = content[<span class="string">&#x27;now&#x27;</span>][<span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line">    now_text = content[<span class="string">&#x27;now&#x27;</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> now_temp, now_text</span><br></pre></td></tr></table></figure>
<h3 id="2-最低-最高温度-日落时间"><a class="markdownIt-Anchor" href="#2-最低-最高温度-日落时间"></a> 2. 最低、最高温度、日落时间</h3>
<p>我们使用postman对调用接口，对response分析，可以获得第一天的数据</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221171749567.png" alt="image-20201221171749567" style="zoom:40%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get3d</span>():</span></span><br><span class="line">    url = <span class="string">&#x27;https://devapi.qweather.com/v7/weather/3d?&#x27;</span></span><br><span class="line">    <span class="comment"># params与getNowWeather()的一样</span></span><br><span class="line">    html = requests.get(url, params)</span><br><span class="line">    html_content = html.json()</span><br><span class="line">    tempMax = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;tempMax&#x27;</span>]</span><br><span class="line">    tempMin = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;tempMin&#x27;</span>]</span><br><span class="line">    sunsetTime = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;sunset&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tempMax, tempMin, sunsetTime</span><br></pre></td></tr></table></figure>
<h2 id="三-语音合成播报天气"><a class="markdownIt-Anchor" href="#三-语音合成播报天气"></a> 三、语音合成播报天气</h2>
<p><a href="https://ai.baidu.com/tech/speech/tts">点击这里</a>，先注册百度TTS。然后创建一个应用，获得三条信息</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201224110716260.png" alt="image-20201224110716260" style="zoom:50%;" />
<br/>
<p>结合上面的天气模块，直接合成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipSpeech</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> getWeather <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百度TTS信息</span></span><br><span class="line">APP_ID = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">API_KEY = <span class="string">&#x27;xxxxxxxxxx&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipSpeech(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取天气模块的信息</span></span><br><span class="line">now_temp, now_text = getNowWeather()</span><br><span class="line">tempMax, tempMin, sunsetTime = get3d()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常天气</span></span><br><span class="line">text_normal = <span class="string">&#x27;xxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;最高温度为：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">              + <span class="string">&#x27;看好温度穿衣哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;，祝您傍晚能看到美丽的日落！拜拜～&#x27;</span></span><br><span class="line"><span class="comment"># 最高温度小于14度时</span></span><br><span class="line">text_lowtemp = <span class="string">&#x27;xxxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度！&#x27;</span> + <span class="string">&#x27;最高温度也才：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">               + <span class="string">&#x27;，也是好冷的呢！要多穿衣服哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;祝xxxx傍晚能看到美丽的日落！拜拜～&#x27;</span></span><br><span class="line"><span class="comment"># 下雨</span></span><br><span class="line">text_rain = <span class="string">&#x27;xxxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;外边正在下雨呢，记得带伞～&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;最高温度为：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">            + <span class="string">&#x27;看好温度穿衣哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;祝xxxx傍晚能看到美丽的日落！拜拜～&#x27;</span> + <span class="string">&#x27;对了，记得带伞哦！再见&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># per: 3是性感大叔 4是妹妹；spd: 是语速，vol是: 音量</span></span><br><span class="line"><span class="keyword">if</span> int(tempMax) &lt; <span class="number">14</span>:</span><br><span class="line">    result = client.synthesis(text_lowtemp, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spd&#x27;</span>: <span class="number">5</span>&#125;)</span><br><span class="line"><span class="keyword">elif</span> now_text <span class="keyword">is</span> <span class="string">&#x27;雨&#x27;</span>:</span><br><span class="line">    result = client.synthesis(text_rain, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = client.synthesis(text_normal, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spd&#x27;</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 播放模块</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(result, dict):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/home/clock/weather.mp3&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br><span class="line">os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % <span class="string">&#x27;/home/clock/weather.mp3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a class="markdownIt-Anchor" href="#三-总结"></a> 三、总结</h2>
<p>在开始做一个项目模块前，一定要做好需求分析，认真阅读开发者文档，了解清楚需求都要用到哪些接口/工具，不然用错接口就会浪费很多很多时间。就像API文档里面的「天气预报」和「太阳和月亮」接口都可以获得日落时间，但是用前者可以简单上十倍！</p>
<p>一开始的我直冲太阳和月亮，还写了一大堆格式化时间的函数，多此一举。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221180450233.png" alt="image-20201221180450233" style="zoom:30%;" />
<br/>
<h2 id="四-相关文章"><a class="markdownIt-Anchor" href="#四-相关文章"></a> 四、相关文章</h2>
<ol>
<li><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></li>
<li><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（三）| 使用「网易云音乐 NodeJS 版 API 接口」播放每日推荐歌曲</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/#more">智能闹钟（四）-整合搭建</a></li>
<li><a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/#more">智能闹钟（五）｜如何优雅地关闭闹钟？</a></li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（五）｜如何优雅地关闭闹钟？</title>
    <url>/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201223222003013.png" alt="image-20201223222003013" style="zoom:45%;" />
<p>网上相关项目基本都是只有播放功能，没有写关闭音乐，这明显不符合我们真实的使用场景。而日常生活中我们最容易接触的工具是手机，那如何通过手机优雅地关闭闹钟呢？</p>
<a id="more"></a>
<h2 id="一-目录结构"><a class="markdownIt-Anchor" href="#一-目录结构"></a> 一、目录结构</h2>
<p>在<code>clock</code>project内包含有5个脚本，<code>Netease.py</code>是主程序，<code>TextToVoice.py</code>用于文字转语音，<code>VolControl.py</code>实现渐入功能，<code>getWeather.py</code>用于获得每日天气，<code>shtudown.py</code>用于关闭闹钟。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223184351927.png" alt="image-20201223184351927" style="zoom:50%;" />
<h2 id="二-关闭闹钟思路"><a class="markdownIt-Anchor" href="#二-关闭闹钟思路"></a> 二、关闭闹钟思路</h2>
<p>有人说关闭闹钟不就直接使用<code>pkill</code>命令结束掉mplayer进程不就可以了吗？但是，程序默认是循环播放32首歌曲+2次天气播报的，所以mplayer一共会执行34次。</p>
<p>由此，我们也很容易可以得出解决方案：<code>pkill</code>34次mplayer即可。</p>
<p>shutdown.py如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">    os.system(<span class="string">&#x27;pkill -f mplayer&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可是难道我们每次关闭都要经过：打开电脑，进入<code>ssh</code>，然后<code>sudo -i</code>，然后执行<code>python xxx/xxx/shutdown.py</code>？要是这样，我就根本不想用这个闹钟了！</p>
<p>突然想起之前刷B站时看到一个up主大概介绍了iOS的<strong>快捷指令</strong>！是可以运行脚本的！</p>
<h2 id="三-ios快捷指令关闭"><a class="markdownIt-Anchor" href="#三-ios快捷指令关闭"></a> 三、iOS快捷指令关闭</h2>
<p>设置路径：快捷指令主页右上角<code>+</code> – 添加操作 – 脚本 – 通过SSH运行脚本（一直往下拉） – 然后填好信息 – 保存指令<code>sudo python /home/clock/shutdown.py</code>。详细操作可查看下方图片。</p>
<p>这样我们就可以每天通过快捷指令，直接关闭闹钟了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173454629.png" alt="image-20201231173454629" style="zoom:33%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173544692.png" alt="image-20201231173544692" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173749629.png" alt="image-20201231173749629" style="zoom:50%;" />
<h2 id="四-安卓怎么办"><a class="markdownIt-Anchor" href="#四-安卓怎么办"></a> 四、安卓怎么办？</h2>
<p>我在酷安搜索<code>ssh</code>软件，一个都没有？但无意中发现有一个软件用于PC电脑的远程开关机，查看了一下简介，是通过<code>ssh</code>连接到电脑，然后执行关机指令的。那么同样的，也能用于执行我的<code>shutdown.py</code>！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223225208634.png" alt="image-20201223225208634" style="zoom:33%;" />
<br/>
<p>填写好信息后，点击第三个按钮保存配置，然后点击第二个按钮就可以关闭闹钟了！</p>
<p>还可以把关闭按钮添加在通知栏中，就可以更快速关闭闹钟了！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223225549628.png" alt="image-20201223225549628" style="zoom:33%;" />
<h2 id="五-相关文章"><a class="markdownIt-Anchor" href="#五-相关文章"></a> 五、相关文章</h2>
<ol>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></p>
</li>
<li>
<p><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></p>
</li>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89%7C%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/#more">智能闹钟（三）| 使用「网易云音乐 NodeJS 版 API 接口」播放每日推荐歌曲</a></p>
</li>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/#more">智能闹钟（四）-整合搭建</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（四）| 整合搭建</title>
    <url>/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这是一个可以播放「网易云每日推荐歌曲」的闹钟，还可以给女朋友播报天气🌞☁️☔️</p>
<img src="https://picbed.tangspoon.cn/uPic/WechatIMG1204.jpeg" alt="WechatIMG1204" style="zoom:50%;" />
<a id="more"></a>
<hr />
<p>Linux部署项目肯定会有大大小小的问题出现，不会与我下面提供的步骤完全一致。遇到问题多网络搜索，大部分问题都会有解决方案。搜索结果没有的，就耐下心来多看原始文档，多尝试，多尝试，多尝试！</p>
<h2 id="一-目录结构"><a class="markdownIt-Anchor" href="#一-目录结构"></a> 一、目录结构</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223184351927.png" alt="image-20201223184351927" style="zoom: 50%;" />
<h2 id="二-材料准备"><a class="markdownIt-Anchor" href="#二-材料准备"></a> 二、材料准备</h2>
<ol>
<li>树莓派 / 其他可以运行python脚本的开发板</li>
<li>音响：pdd 8.8包邮</li>
</ol>
<h2 id="三-环境准备"><a class="markdownIt-Anchor" href="#三-环境准备"></a> 三、环境准备</h2>
<h3 id="1-系统版本"><a class="markdownIt-Anchor" href="#1-系统版本"></a> 1. 系统版本</h3>
<p>树莓派我用的是Linux raspberrypi 5.4.79-v7+ ，其他版本大同小异。</p>
<h3 id="2-mplayer"><a class="markdownIt-Anchor" href="#2-mplayer"></a> 2. mplayer</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install mplayer</span><br></pre></td></tr></table></figure>
<h3 id="3-baidu-api"><a class="markdownIt-Anchor" href="#3-baidu-api"></a> 3. baidu-api</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install baidu-aip</span><br></pre></td></tr></table></figure>
<h2 id="四-账号准备"><a class="markdownIt-Anchor" href="#四-账号准备"></a> 四、账号准备</h2>
<ol>
<li><a href="https://ai.baidu.com/tech/speech/tts">百度TTS</a>：获取<code>APP_ID</code>， <code>API_KEY</code>， <code>SECRET_KEY</code></li>
<li><a href="https://www.qweather.com/">和风天气</a>：获取城市<code>id</code>，<code>key</code></li>
</ol>
<h2 id="五-开始搭建"><a class="markdownIt-Anchor" href="#五-开始搭建"></a> 五、开始搭建</h2>
<h3 id="1-下载脚本"><a class="markdownIt-Anchor" href="#1-下载脚本"></a> 1. 下载脚本</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">mkdir &#x2F;home&#x2F;clock &amp;&amp; cd &#x2F;home&#x2F;clock</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tangspoon66&#x2F;NeteaseCloud-Clock.git</span><br></pre></td></tr></table></figure>
<h3 id="2-修改参数"><a class="markdownIt-Anchor" href="#2-修改参数"></a> 2. 修改参数</h3>
<p>脚本内有详细的参数说明，下面只列出需要需要修改的参数，如何修改请参考注释。</p>
<h4 id="neteasepy"><a class="markdownIt-Anchor" href="#neteasepy"></a> <a href="http://Netease.py">Netease.py</a></h4>
<ul>
<li>url</li>
<li>phone</li>
<li>pwd</li>
</ul>
<h4 id="getweatherpy"><a class="markdownIt-Anchor" href="#getweatherpy"></a> <a href="http://getWeather.py">getWeather.py</a></h4>
<ul>
<li>location</li>
<li>key</li>
</ul>
<h4 id="texttovoicepy"><a class="markdownIt-Anchor" href="#texttovoicepy"></a> <a href="http://TextToVoice.py">TextToVoice.py</a></h4>
<ul>
<li>APP_ID</li>
<li>APP_KEY</li>
<li>SECRET_KEY</li>
<li>text_normal、text_lowtemp、text_rain</li>
</ul>
<h3 id="3-定时执行"><a class="markdownIt-Anchor" href="#3-定时执行"></a> 3. 定时执行</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>定时每天<code>7:00</code>的闹钟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一定要填写绝对路径！</span><br><span class="line">00 7 * * * python &#x2F;home&#x2F;clock&#x2F;Netease.py &amp;&gt;&gt; &#x2F;home&#x2F;clock&#x2F;log.log</span><br><span class="line">00 7 * * * python &#x2F;home&#x2F;clock&#x2F;VolControl.py</span><br></pre></td></tr></table></figure>
<h2 id="六-相关文章"><a class="markdownIt-Anchor" href="#六-相关文章"></a> 六、相关文章</h2>
<ol>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></p>
</li>
<li>
<p><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></p>
</li>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89%7C%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/#more">智能闹钟（三）| 使用「网易云音乐 NodeJS 版 API 接口」播放每日推荐歌曲</a></p>
</li>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/#more">智能闹钟（五）｜如何优雅地关闭闹钟？</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式-01</title>
    <url>/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/</url>
    <content><![CDATA[<h3 id="简单"><a class="markdownIt-Anchor" href="#简单"></a> 简单</h3>
<ul>
<li><code>\d</code> 匹配数字</li>
<li><code>\w</code> 匹配字母</li>
<li><code>.</code> 匹配所有</li>
</ul>
<p>例如：<code>00\d</code> 可以匹配000～009，<code>00\w</code> 可以匹配00a～00z，<code>\w\w</code> 可以匹配 aa，<code>\w.</code> 可以匹配 js、j1、j! 等</p>
<ul>
<li><code>*</code>表示任意个字符（包括0个）</li>
<li><code>+</code>表示至少一个字符</li>
<li><code>?</code>表示0个或1个字符</li>
<li><code>&#123;n&#125;</code>表示n个字符</li>
<li><code>&#123;n,m&#125;</code>表示n-m个字符：</li>
</ul>
<a id="more"></a>
<p>复杂例子：<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code>。</p>
<p>我们来从左到右解读一下：</p>
<ol>
<li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>'010'</code>；</li>
<li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code>，<code>'\t\t'</code>等；</li>
<li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>'1234567'</code>。</li>
</ol>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配<code>'010-12345'</code>这样的号码呢？由于<code>'-'</code>是特殊字符，在正则表达式中，要用<code>'\'</code>转义，所以，上面的正则是<code>\d&#123;3&#125;\-\d&#123;3,8&#125;</code>。</p>
<h3 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h3>
<p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线与$组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'js2015'</code>等等；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>'JavaScript'</code>、<code>'Javascript'</code>、<code>'javaScript'</code>或者<code>'javascript'</code>。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>你可能注意到了，<code>js</code>也可以匹配<code>'jsp'</code>，但是加上<code>^js$</code>就变成了整行匹配，就只能匹配<code>'js'</code>了。</p>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1=<span class="regexp">/ABC\-001/</span></span><br><span class="line"><span class="keyword">var</span> re2=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>)  <span class="comment">//字符串的转义问题，字符串的两个\\实际上是一个\。</span></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure>
<h3 id="切分字符串"><a class="markdownIt-Anchor" href="#切分字符串"></a> 切分字符串</h3>
<p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure>
<p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>
<p>再加入<code>;</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3>
<p>用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line">re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line">re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;19:05:30&#x27;</span>); <span class="comment">// [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure>
<p>对于<code>'2-30'</code>，<code>'4-31'</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h3 id="贪婪匹配"><a class="markdownIt-Anchor" href="#贪婪匹配"></a> 贪婪匹配</h3>
<p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="全局搜索"><a class="markdownIt-Anchor" href="#全局搜索"></a> 全局搜索</h3>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure>
<p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>测试功能点总结</title>
    <url>/2020/11/17/%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。</p>
<a id="more"></a>
<h1 id="功能点列表"><a class="markdownIt-Anchor" href="#功能点列表"></a> 功能点列表</h1>
<blockquote>
<p>所有xmind文件都可以在blog的「<a href="https://file.tangspoon.cn">文件</a>」中下载，但目前使用的是Gcore的俄罗斯的vps搭建的OLAINDEX，所以访问与下载可能会有些慢，日后会进行优化。</p>
</blockquote>
<ol>
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%9C%8B%E5%8F%8B%E5%9C%88%E8%AF%84%E8%AE%BA-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">朋友圈点赞-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162135625.png" alt="image-20201117162135625" style="zoom:50%;" />
<hr />
<ol start="2">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">微信红包-测试点.xmind</a></li>
</ol>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201117162237889.png" alt="image-20201117162237889" /></p>
<hr />
<ol start="3">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%90%9C%E7%B4%A2%E6%A1%86-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">搜索框-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162335854.png" alt="image-20201117162335854" style="zoom:50%;" />
<hr />
<ol start="4">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%9C%8B%E5%8F%8B%E5%9C%88%E8%AF%84%E8%AE%BA-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">朋友圈评论-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162433886.png" alt="image-20201117162433886" style="zoom:50%;" />
<hr />
<ol start="5">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">视频播放器-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162512012.png" alt="image-20201117162512012" style="zoom:50%;" />
<hr />
<ol start="6">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E8%B4%AD%E7%89%A9%E8%BD%A6-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">购物车-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162604959.png" alt="image-20201117162604959" style="zoom:50%;" />
<hr />
<blockquote>
<p>欢迎在下方评论区补充</p>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>测试点</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派开启crontab日志</title>
    <url>/2020/12/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201223205438951.png" alt="image-20201223205438951" style="zoom:40%;" />
<a id="more"></a>
<p>今天的树莓派闹钟情况有点问题，想查看一下crontab任务完成情况，结果找了半天找不到log。原来是树莓派系统默认禁止了生成日志文件。解决办法也很简单。</p>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;rsyslog.conf</span><br></pre></td></tr></table></figure>
<p>在文件中找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cron.*                     &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure>
<p>把<code>#</code>去掉，然后’esc’，输入<code>:wq</code></p>
<p>输入一下代码重新启动日志服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rsyslog restart</span><br></pre></td></tr></table></figure>
<p>执行一个crontab任务，再到<code>/var/log/cron.log</code>就可以查看到执行情况</p>
<hr />
<p>参考资料：</p>
<p><a href="https://my.oschina.net/u/4341499/blog/4280350">https://my.oschina.net/u/4341499/blog/4280350</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用例-基础知识</title>
    <url>/2020/11/16/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。</p>
<a id="more"></a>
<h2 id="测试用例-误区"><a class="markdownIt-Anchor" href="#测试用例-误区"></a> 测试用例-误区</h2>
<blockquote>
<p>首先，我们深刻理解测试用例的基本概念，打牢根基对日后cases的编写应该很有帮助。</p>
</blockquote>
<ol>
<li>
<p>测试用例是什么？</p>
<p>测试用例是“一组输入、执行条件、预期结果”</p>
</li>
<li>
<p>什么是一个好的测试用例？</p>
<p>“能发现当前未发现的缺陷的用例就是一个好的用例。”当然是这样的，但是我们要注意，不要盲目片面地去设计出“难以发现的缺陷”，忘了测试的存在。测试用例实际上是个集合，所以对它的评价也只能对cases的集合来进行。作为测试依据的测试用例，必须要能完整覆盖「测试需求」，而不应该针对单个的测试用例去评判好坏。</p>
</li>
<li>
<p>测试用例的预期结果不需要验证吗？</p>
<p>比如我们测试一个论坛的更改昵称的功能，我们的预期结果不应该仅仅只有“昵称更改成功”，还应该包含着对预期结果的验证：在数据库中执行查询语句，看查询结果是否与预期一致。</p>
</li>
</ol>
<h2 id="测试用例-作用"><a class="markdownIt-Anchor" href="#测试用例-作用"></a> 测试用例-作用</h2>
<ol>
<li>
<p>指导测试的「实施」</p>
<p>整个整个测试过程分成好几个阶段，每个阶段都有不同优先级与重要级的cases。</p>
</li>
<li>
<p>「规划」测试数据</p>
<p>在实践中，数据和用例是分开的。按照测试用例配备一组或若干组测试「原始数据」，以及标准测试结果。除正常数据之外，还必须根据测试用例设计大量的「边缘数据」和「错误数据」。</p>
</li>
<li>
<p>评估测试结果的度量基准</p>
<p>在测试执行阶段完成后，我们得进行测试结果的评估，然后编写测试报告。做大部分的判断都是需要量化的结果的，测试也不例外。我们怎么判断一个软件的质量如何呢？测试用例就能给我们提供帮助。我们可以用测试用例中统计出测试覆盖率、测试合格率、重要测试合格率等等。</p>
</li>
</ol>
<h2 id="测试用例-设计方法"><a class="markdownIt-Anchor" href="#测试用例-设计方法"></a> 测试用例-设计方法</h2>
<h3 id="等价类划分"><a class="markdownIt-Anchor" href="#等价类划分"></a> 等价类划分</h3>
<h4 id="输入数据的划分方式可以从哪几个方面划分"><a class="markdownIt-Anchor" href="#输入数据的划分方式可以从哪几个方面划分"></a> 输入数据的划分方式（可以从哪几个方面划分？）</h4>
<p>输入数据的「个数、集合、规则、取值范围、布尔值」。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116115530110.png" alt="image-20201116115530110" style="zoom:50%;" />
<h4 id="设计测试用例的步骤"><a class="markdownIt-Anchor" href="#设计测试用例的步骤"></a> 设计测试用例的步骤</h4>
<ol>
<li>
<p>分析需求，确定「输入」「数据类型」。</p>
<p>例如，固定电话号码的测试，固话号码的输入为：区号+电话号，前者的数据类型为：3/4位的数字，后者的类型为：7/8位的电话号。</p>
<p><strong>所以，分析需求，得从输入与数据类型两个维度来看。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116122413990.png" alt="image-20201116122413990" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201116123007606.png" alt="image-20201116123007606" style="zoom:50%;" />
</li>
<li>
<p>根据「输入规则」，使用上面的划分方式效&amp;无效等价类</p>
<p>1）规则列表（可以从长度，集合，规则，取之范围……来看）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116140515364.png" alt="image-20201116140515364" style="zoom:50%;" />
<p>2）「划分」有效等价类与无效等价类</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116140757649.png" alt="image-20201116140757649" style="zoom:50%;" />
</li>
<li>
<p>设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类）</p>
</li>
<li>
<p>设计用例，覆盖无效等价类（一条用例只能覆盖一条无效等价类）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116141015502.png" alt="image-20201116141015502" style="zoom:50%;" />
</li>
</ol>
<hr />
<h3 id="边界值"><a class="markdownIt-Anchor" href="#边界值"></a> 边界值</h3>
<blockquote>
<p>边界值分析法一般是搭配「等价类划分」使用来设计测试用例</p>
</blockquote>
<h4 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h4>
<p>首先，得明白上点、离点、内点的概念。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116142302992.png" alt="image-20201116142302992" style="zoom:50%;" />
<h4 id="什么时候用边界值"><a class="markdownIt-Anchor" href="#什么时候用边界值"></a> 什么时候用边界值？</h4>
<p>在使用「等价类划分」时，划分有效&amp;无效等价类这一步时，要结合边界值来设计测试用例。</p>
<p>还是以固话号码为例。区号长度3/4位，上点：3、4，离点：2、5，内点：3/4（与上点重复）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116144337242.png" alt="image-20201116144337242" style="zoom:50%;" />
<p>所以，在设计测试用例时，“3. 以0开头的小于3位的数字（离点：2位）”设计成“01（2位，而不是1位） 1234567”。</p>
<hr />
<h3 id="判定表法"><a class="markdownIt-Anchor" href="#判定表法"></a> 判定表法</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116145508305.png" alt="image-20201116145508305" style="zoom:50%;" />
<hr />
<h3 id="因果图"><a class="markdownIt-Anchor" href="#因果图"></a> 因果图</h3>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201116150217436.png" alt="image-20201116150217436" /></p>
<hr />
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201116150700289.png" alt="image-20201116150700289" /></p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1QJ411g7nR?p=8">https://www.bilibili.com/video/BV1QJ411g7nR?p=8</a></li>
<li><a href="https://www.cnblogs.com/kuihua/p/5925092.html">https://www.cnblogs.com/kuihua/p/5925092.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化时间</title>
    <url>/2020/12/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>在和风天气API获取日落时间时，没仔细看清楚官方文档，绕了一个大圈。但是也学到了时间格式化的一些操作，在这里继续记录下来。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201221193040002.png" alt="image-20201221193040002" /></p>
<a id="more"></a>
<hr />
<h2 id="一-获取系统日期并格式化"><a class="markdownIt-Anchor" href="#一-获取系统日期并格式化"></a> 一、获取系统日期并格式化</h2>
<p>因为使用sunmoon接口<code>https://devapi.qweather.com/v7/astronomy/sunmoon?</code>需要使用当天日期，格式例如<code>20201218</code>，Linux的时间显示格式为<code>Mon 21 Dec 18:39:36 CST 2020</code>，因此我们需要把系统格式化。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221191037433.png" alt="image-20201221191037433" style="zoom:70%;" />
<p>可以使用Python的<code>datetime</code>模块，使用方式如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatTime</span>():</span></span><br><span class="line">	<span class="comment"># 实例化对象</span></span><br><span class="line">    dt = datetime.now()</span><br><span class="line">    year = dt.year</span><br><span class="line">    month = dt.month</span><br><span class="line">    day = dt.day</span><br><span class="line">    <span class="comment"># 组合时间</span></span><br><span class="line">    today = str(year) + str(month) + str(day)</span><br><span class="line">    <span class="comment"># print(&#x27;today: &#x27;,today)</span></span><br><span class="line">    <span class="keyword">return</span> today</span><br></pre></td></tr></table></figure>
<h2 id="二-发送日落请求"><a class="markdownIt-Anchor" href="#二-发送日落请求"></a> 二、发送日落请求</h2>
<p>获取了格式化的<code>date</code>之后，我们就可以获取日落时间了。过程如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSunsetTime</span>():</span></span><br><span class="line">    sunset_url = <span class="string">&#x27;https://devapi.qweather.com/v7/astronomy/sunmoon?&#x27;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;101280101&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;6dee7771746148fbbee9cedeb9c1ffc4&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;date&#x27;</span>: date,</span><br><span class="line">        <span class="string">&#x27;gzip&#x27;</span>: <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    sun_html = requests.get(sunset_url, params)</span><br><span class="line">    sun_content = sun_html.json()</span><br><span class="line">    sunset_time = sun_content[<span class="string">&#x27;sunset&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;sunset_time:&#x27;</span>, sunset_time)</span><br><span class="line">    print(<span class="string">&#x27;sunset_time is: &#x27;</span>, type(sunset_time))</span><br><span class="line">    <span class="keyword">return</span> sunset_time</span><br></pre></td></tr></table></figure>
<br/>
<p>以下红框是我们需要的时间，在使用<code>type()</code>验证了日落时间是<code>str</code>类型后，我们可以通过<strong>正则表达式</strong>来提取我们需要的<code>17:47</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221192116078.png" alt="image-20201221192116078" style="zoom:50%;" />
<h2 id="三-正则表达式提取做需要的字符串"><a class="markdownIt-Anchor" href="#三-正则表达式提取做需要的字符串"></a> 三、正则表达式提取做需要的字符串</h2>
<p>使用<code>re</code>模块下的<code>findall</code>配合正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分离日落时间，获得几点几分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSunsetHM</span>():</span></span><br><span class="line">    <span class="comment"># 使用正则表达式</span></span><br><span class="line">    sunsetime = getSunsetTime()</span><br><span class="line">    sunsetHM = (re.findall(<span class="string">r&quot;T(.+?)\+&quot;</span>, sunsetime))</span><br><span class="line">    print(sunsetHM)</span><br><span class="line">    <span class="keyword">return</span> sunsetHM</span><br></pre></td></tr></table></figure>
<br/>
<p>提取结果显示</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221192820537.png" alt="image-20201221192820537" style="zoom:50%;" />
<hr />
<p>完整代码已上传到Github：</p>
<p><a href="https://github.com/tangspoon66/MyPythonCode/blob/master/formatTime.py">https://github.com/tangspoon66/MyPythonCode/blob/master/formatTime.py</a></p>
<br/>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/liao392781/article/details/80181088">https://blog.csdn.net/liao392781/article/details/80181088</a></p>
<p><a href="https://blog.csdn.net/shomy_liu/article/details/44141483">https://blog.csdn.net/shomy_liu/article/details/44141483</a></p>
]]></content>
      <categories>
        <category>正则表达式</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的“用户登陆”用例设计真的简单吗？</title>
    <url>/2020/11/01/%E7%AE%80%E5%8D%95%E7%9A%84%E2%80%9C%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E2%80%9D%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。</p>
<a id="more"></a>
<h3 id="一-基础用例"><a class="markdownIt-Anchor" href="#一-基础用例"></a> 一、基础用例</h3>
<ol>
<li>输入正确的账号密码，验证是否登陆成功；</li>
<li>输入正确的账号错误的密码，验证是否登陆失败，并且提示信息正确；（“提示信息正确”指的是每个项目的提示都不一样，这里统称提示信息正确，往下所有均为此意）</li>
<li>输入未注册的账号和任意密码，验证是否登陆失败，并提示信息正确；</li>
<li>用户名和密码两者为空，验证是否登陆失败，并提示信息正确；</li>
<li>用户名和密码两者之一为空，验证是否登陆失败，并提示信息正确；</li>
<li>如果登陆功能启用了「验证码功能」，在用户名与密码正确的前提下，输入正确的验证码，验证是否登陆成功；</li>
<li>如果登陆功能启用了「验证码功能」，用户名与密码输入正确的前提下，输入错误的验证码，验证是否登陆失败，并提示信息正确；</li>
<li>用户民密码是否支持特殊字符和中文；</li>
<li>前端校验格式长度等，后端是否也校验</li>
</ol>
<h3 id="二-中阶用例"><a class="markdownIt-Anchor" href="#二-中阶用例"></a> 二、中阶用例</h3>
<ol>
<li>用户名和密码是否大小写敏感；</li>
<li>页面上的密码框是否加密显示；</li>
<li>忘记用户名和忘记密码的功能是否可用；</li>
<li>前端页面是否根据设计要求限制用户名和密码的长度；</li>
<li>如果登陆功能需要验证码，点击验证图片是否可以更换验证码，更换后的验证码是否可用；</li>
<li>刷新页面是否会刷新验证码；</li>
<li>如果验证码具有时效性，需要分别验证时效内和时效外的验证码的有效性；</li>
<li>不同级别的用户，比如管理员和普通用户，登陆系统后的权限是否正确；</li>
<li>后台系统创建的用户第一次登陆成功时，是否提示修改密码；</li>
<li>用户登陆成功直到会话超时后，继续操作是否会重定向到用户登陆界面；</li>
<li>页面默认焦点是否定位在用户名的输入框中；</li>
<li>快捷键tab和enter等，是否可以正常使用。</li>
</ol>
<blockquote>
<p>1-4可归纳为「用户名密码的大小与长度」细分类，5-7是验证码类，9-12是用户体验类</p>
</blockquote>
<hr />
<p><strong>一个质量过硬的软件系统，除了显式功能性需求以外，其他的「非功能性需求」即隐式功能性需求也是极其关键的</strong></p>
<p>非功能性需求主要涉及：安全、性能、兼容三大方面。</p>
<hr />
<h3 id="三-安全测试用例"><a class="markdownIt-Anchor" href="#三-安全测试用例"></a> 三、安全测试用例</h3>
<ol>
<li>用户名密码后台存储是否加密；</li>
<li>用户名在网络传输过程中是否加密；</li>
<li>密码是否具有有效期，密码有效期到期后，是否提示需要修改密码；</li>
<li>不登陆的情况下，在浏览器中直接输入登陆后的URL地址，验证是否会重定向到用户已登陆的界面；</li>
<li>密码输入框是否不支持复制和粘贴；</li>
<li>密码输入框框内输入密码是否都可以在页面源代码模式下被查看；</li>
<li>用户名和密码的输入框分别输入典型的“SQL 注入攻击”字符串，验证系统的返回页面；</li>
<li>用户名和密码的输入框中分别输入典型的“XSS 跨站脚本攻击”字符串，验证系统行为是否被篡改；</li>
<li>连续多次登陆失败的情况下，系统是否会阻止后续的尝试以应对暴力破解；</li>
<li>同一用户在同一终端的多种浏览器上登陆，验证登陆功能的互斥性是否符合设计预期；</li>
<li>同一用户先后在多台终端的浏览器上登陆，验证登陆是否具有互斥性。</li>
</ol>
<h3 id="四-性能压力测试用例"><a class="markdownIt-Anchor" href="#四-性能压力测试用例"></a> 四、性能压力测试用例</h3>
<ol>
<li>
<p>单用户登陆的响应时间是否小于3秒；</p>
</li>
<li>
<p>单用户登陆时，后台请求数量是否过多；</p>
</li>
<li>
<p>高并发场景下用户登陆的响应时间是否小于5秒；</p>
</li>
<li>
<p>高并发场景下「服务端的监控指标」是否符合预期；</p>
</li>
<li>
<p>高集合点并发场景下，是否存在资源思索和不不合理的资源等待；</p>
</li>
<li>
<p>长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏。</p>
</li>
</ol>
<h3 id="五-兼容性测试用例"><a class="markdownIt-Anchor" href="#五-兼容性测试用例"></a> 五、兼容性测试用例</h3>
<ol>
<li>不同浏览器下，验证登陆页面的现实以及功能的正确性；</li>
<li>相同浏览器的不同版本下，验证登录页面的现实以及功能的正确性；</li>
<li>不同移动设备终端的不同浏览器下，验证登录页面的现实以及功能的正确性；</li>
<li>不同分辨率的界面下，验证登录页面的现实以及功能正确性。</li>
</ol>
<h3 id="六-其他网友补充"><a class="markdownIt-Anchor" href="#六-其他网友补充"></a> 六、其他网友补充</h3>
<ol>
<li>
<p>是否支持第三方登录；</p>
</li>
<li>
<p>是否可记住密码，记住密码保存是否加密，记住密码是否有有效期，过期后是否会清空密码；</p>
</li>
<li>
<p>是否可以用抓包工具抓到的请求包直接登录；</p>
</li>
<li>
<p>截取到的token等信息，是否可以直接在其他终端上使用，绕开登陆。token过期时间教研；</p>
</li>
<li>
<p>修改密码后</p>
<p>（1）修改完密码后是否重定向到登录界面<br />
（2）修改完密码后，分别使用原密码和新密码登录<br />
（3）在其他终端修改密码后，本终端是否自动下线？下线后，使用原密码能否继续登录？</p>
</li>
<li>
<p>密码错误限制次数<br />
（1）密码输入错误是否有最大次数限制？分别测试最大值-1、最大值、最大值+1时的输错密码情况<br />
（2）超过最大次数限制后，是否采取强制手段限制登录或对账号暂时冻结处理<br />
（3）超过最大次数限制后，分别输入正确的密码和错误的密码再次登录</p>
</li>
<li>
<p>登录用户限制：比如同时支持10个用户登录，同时9个或者11个用户登录是否正常或者提示信息正确</p>
</li>
<li>
<p>用户名和密码是否对空格敏感</p>
</li>
<li>
<p>密码是否有明文和暗文显示两种模式(有时候只有暗文显示真的不知道自己的密码是否输入正确)</p>
</li>
<li>
<p>更改密码后是否还能用之前的密码登录</p>
</li>
<li>
<p>一个用户是否具备多种登录方式(用户名，手机号，邮箱…)</p>
</li>
<li>
<p>若支持手机号+验证码登录，验证码是否有时间限制？移动端设备是否可以直接获取验证码？</p>
</li>
</ol>
<blockquote>
<p>一个优秀的测试工程师必须具有很宽广的知识面，如果你不能对被测系统的设计有深入的理解、不明白安全攻击的基本原理、没有掌握性能测试的基本设计方法，很难设计出“有的放矢”的测试用例。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>解决｜UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe8 in position 0: ordinal not in range(128)</title>
    <url>/2021/12/18/%E8%A7%A3%E5%86%B3%EF%BD%9CUnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-0-ordinal-not-in-range-128/</url>
    <content><![CDATA[<p>换成python3即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除&#x2F;usr&#x2F;bin目录下的python link文件</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line"># 删除后再建立新的链接关系：</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>解决badboy出现“页面的脚本发生素错误”</title>
    <url>/2020/10/29/%E8%A7%A3%E5%86%B3badboy%E5%87%BA%E7%8E%B0%E2%80%9C%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%84%9A%E6%9C%AC%E5%8F%91%E7%94%9F%E7%B4%A0%E9%94%99%E8%AF%AF%E2%80%9D/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。</p>
<a id="more"></a>
<hr />
<img src="https://picbed.tangspoon.cn/uPic/image-20201102195628553.png" alt="image-20201102195628553" style="zoom:50%;" />
<p>网上正常的几种方法都尝试过了，但无效。后来看到了<a href="https://blog.csdn.net/weixin_38470851/article/details/80687911">这篇CSDN的文章</a>，果然有用。记录一下。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-11-02_19-45-07.jpg" alt="Xnip2020-11-02_19-45-07" style="zoom:50%;" />
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>面试宝典-01</title>
    <url>/2020/10/27/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-01/</url>
    <content><![CDATA[<h2 id="一-软件工程"><a class="markdownIt-Anchor" href="#一-软件工程"></a> 一、软件工程</h2>
<h4 id="1-软件生命周期有哪些阶段常见的软件生命周期模型有哪些"><a class="markdownIt-Anchor" href="#1-软件生命周期有哪些阶段常见的软件生命周期模型有哪些"></a> 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？</h4>
<p>软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。</p>
<p>常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。</p>
<a id="more"></a>
<h4 id="2-什么是版本控制常用的系统有哪些"><a class="markdownIt-Anchor" href="#2-什么是版本控制常用的系统有哪些"></a> 2. 什么是版本控制，常用的系统有哪些？</h4>
<p>是一种软体工程技巧，确保不同的人编辑的统一文档都能得到更新。</p>
<p>1）Git：分布式的版本控制系统。</p>
<p>2）SVN：subversion，分支管理系统。</p>
<h2 id="二-测试模型"><a class="markdownIt-Anchor" href="#二-测试模型"></a> 二、测试模型</h2>
<h4 id="1-常见的测试模型"><a class="markdownIt-Anchor" href="#1-常见的测试模型"></a> 1. 常见的测试模型</h4>
<p>1）V字型：这是一种古老的瀑布模型，反映了实际和测试之间的关系。局限:仅仅把测试过程作为编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，如果前面设计错误， 得一直到后期的验收测试才被发现，耗时耗力。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123616102.png" alt="image-20201108123616102" style="zoom:50%;" />
<p>2）W型：测试与开发同时进行，在 V 模型的基础上，增加了在开发阶段的同步测试。局限：仍然不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123631829.png" alt="image-20201108123631829" style="zoom:50%;" />
<h4 id="2-请根据v模型分别概述测试人员在软件的需求定义阶段-设计阶段-编码阶段-系统集成阶段的工作任务及其相应生成的文档"><a class="markdownIt-Anchor" href="#2-请根据v模型分别概述测试人员在软件的需求定义阶段-设计阶段-编码阶段-系统集成阶段的工作任务及其相应生成的文档"></a> 2. 请根据”V”模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的「工作任务」及其相应「生成的文档」?</h4>
<p>1）需求定义阶段：根据项目需求提取测试需求，形成「测试需求文档」；根据测试需求和项目计划生成「测试计划」。</p>
<p>2）设计阶段：根据测试需求拟定测试方案并形成「测试方案文档」；根据测试方案文档指定测试用例，并形成「测试用例文档」</p>
<p>3）编码阶段：执行测试并完善测试用例文档</p>
<p>4）系统集成阶段：测试总结报告，阶段问题统计报告，测试问题报告</p>
<h2 id="三-测试计划"><a class="markdownIt-Anchor" href="#三-测试计划"></a> 三、测试计划</h2>
<h4 id="1-编写测试计划的目的是"><a class="markdownIt-Anchor" href="#1-编写测试计划的目的是"></a> 1. 编写测试计划的目的是？</h4>
<p>使测试工作顺利进行；使项目参与人员沟通更顺畅；使测试工作更系统（人与系统）</p>
<h4 id="2-测试计划编写六要素"><a class="markdownIt-Anchor" href="#2-测试计划编写六要素"></a> 2. 测试计划编写六要素</h4>
<p>5W1H（谁、时间、地点、做了什么事、为什么、怎么做的H）</p>
<h4 id="3-测试人员在软件开发过程中的任务是什么"><a class="markdownIt-Anchor" href="#3-测试人员在软件开发过程中的任务是什么"></a> 3. 测试人员在软件开发过程中的任务是什么？</h4>
<p>寻找bug，衡量软件的品质，避免软件开发过程中的缺陷，关注用户体验。总的来说就是：确保软件质量。</p>
<h2 id="四-测试种类"><a class="markdownIt-Anchor" href="#四-测试种类"></a> 四、测试种类</h2>
<h4 id="1-请列出你所知道的软件测试种类至少五项"><a class="markdownIt-Anchor" href="#1-请列出你所知道的软件测试种类至少五项"></a> 1. 请列出你所知道的「软件测试种类」，至少五项。</h4>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123501083.png" alt="image-20201108123501083" style="zoom:50%;" />
<h4 id="2-黑盒测试和白盒测试的常用测试方法有举个例子"><a class="markdownIt-Anchor" href="#2-黑盒测试和白盒测试的常用测试方法有举个例子"></a> 2. 黑盒测试和白盒测试的常用测试方法有？举个例子？</h4>
<p>1）黑盒：等价类划分法、边界值法、因果图法和错误猜测法</p>
<p>2）白盒：逻辑覆盖法、循环测试路径选择、基本路径测试</p>
<p>例子：在一次输入多个条件的完整性查询中。利用等价类划分法和边界分析法，首先利用等价类划分法，制定一个或多个结果是OK的测试用例，然后确认多个NG的测试用例。然后再用边界值分析法，对结果分别是OK和NG的测试用例进行拓展和补充。</p>
<h4 id="3-简述黑盒测试和白盒测试的优缺点"><a class="markdownIt-Anchor" href="#3-简述黑盒测试和白盒测试的优缺点"></a> 3. 简述黑盒测试和白盒测试的优缺点？</h4>
<p>1）黑盒</p>
<ul>
<li>优点：a. 比较简单，不用了解内部代码的实现；b. 从用户的角度出发，很容易知道用户会用到哪些功能，会遇到什么问题；c. 与软件内部无关；d. 在做软件自动化测试时较方便。</li>
<li>缺点：代码覆盖率较低；自动化测试的复用性较低。</li>
</ul>
<p>2）白盒</p>
<ul>
<li>优点：代码覆盖率高，提高代码质量，发现隐藏的问题。</li>
<li>缺点：a. 测试基于代码，只能测试开发人员的对与不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；b. 系统庞大时，测试开销会很大；c. 测试有很多路径，不可能测试完所有的路径。</li>
</ul>
<h4 id="4-单元测试的策略有哪些主要内容有"><a class="markdownIt-Anchor" href="#4-单元测试的策略有哪些主要内容有"></a> 4. 单元测试的策略有哪些，主要内容有？</h4>
<p>逻辑覆盖，循环覆盖，代码走查，静态数据流分析，代码评审，桌前检查，同行评审</p>
<h4 id="5-白盒测试逻辑覆盖有哪几种覆盖标准覆盖率最高的是"><a class="markdownIt-Anchor" href="#5-白盒测试逻辑覆盖有哪几种覆盖标准覆盖率最高的是"></a> 5. 白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是？</h4>
<p>语句覆盖，分支覆盖，条件覆盖，路径覆盖，分支条件覆盖。最高的是路径覆盖。</p>
<h2 id="五-用例设计"><a class="markdownIt-Anchor" href="#五-用例设计"></a> 五、用例设计</h2>
<h4 id="1-什么是测试用例测试用例的基本要素"><a class="markdownIt-Anchor" href="#1-什么是测试用例测试用例的基本要素"></a> 1. 什么是测试用例，测试用例的基本要素？</h4>
<p>测试用例是为某个测试目标编写的一组输入、执行条件与预期结果，以便测试某个程序是否符合特定要求。</p>
<p>基本要素：测试索引，测试环境，测试输入，测试操作，预期结果，评价标准</p>
<h4 id="2-描述测试用例设计的完整过程"><a class="markdownIt-Anchor" href="#2-描述测试用例设计的完整过程"></a> 2. 描述测试用例设计的完整过程</h4>
<p>1）根据概要设计、需求文档、测试计划、测试方案细分出测试项</p>
<p>2）根据测试项，按照详细设计与测试方案中测试的覆盖率细分出测试子项</p>
<p>3）用测试设计方法（等价类划分，边界值，因果图等）编写测试用例</p>
<p>注意：用例一定要及时更新（补充与删除），要全面（考虑功能、性能、兼容性等）</p>
<h4 id="3-有个广告的纸杯子请设计测试用例"><a class="markdownIt-Anchor" href="#3-有个广告的纸杯子请设计测试用例"></a> 3. 有个广告的纸杯子，请设计测试用例</h4>
<p>基本功能测试（逻辑功能测试）。</p>
<p>1）硬度：是否达到设计标准。 装载能力:在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。 装载种类:开水(是否产生异味)、温水、冷水、冰水、咖啡。。</p>
<p>2）界面测试(UI 测试)。</p>
<p>看其形状、大小设计是否适合人方便拿起。</p>
<p>外观是否吸引人(广告嘛)，赏心悦目。</p>
<p>带广告的图案沾水受是否掉色、模糊。</p>
<p>3）易用性测试。</p>
<p>看其形状、大小设计是否适合人方便拿起。</p>
<p>残疾人士用此杯去喝水的容程度。 杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。</p>
<p>4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。</p>
<p>5）安全性测试。杯子所用的材料(包括纸基、涂层和广告颜料)是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。</p>
<p>6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。</p>
<p>7）对设计的改进建议。“如果是一次性杯子，能否标示已使用(比如变色)”和“杯子是否有使用者标贴(多人使用时防止混淆)”。</p>
<h4 id="4-一个身份证号码输入框怎么设计用例"><a class="markdownIt-Anchor" href="#4-一个身份证号码输入框怎么设计用例"></a> 4. 一个身份证号码输入框，怎么设计用例?</h4>
<p>校验身份证号的规则有效性（地址码、生日编码、顺序码、校验码）</p>
<p>检验15位身份证和18位身份正好可用</p>
<p>校验末尾是x的情况</p>
<p>校验不足15位、16-17位和18位的情况</p>
<p>如果是必输项，空白时是否有提示与流程是否正常进行</p>
<p>如果不是必输项，校验不输入时流程能否正常进行</p>
<p>检验非数字的情况，是否会有正确提示信息（包括大小写字母，汉字，特殊字符与标点符号）</p>
<h4 id="5-登陆功能怎么设计测试用例"><a class="markdownIt-Anchor" href="#5-登陆功能怎么设计测试用例"></a> 5. 登陆功能怎么设计测试用例？</h4>
<p>具体需求:有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。</p>
<p>此题的考察目的：1. 了解需求(测什么都是从了解需求开始)；2. 是否有设计 Test Case 的能力；3. 是否熟悉各种测试方法； 4. 是否有丰富的 Web 测试经验;；5. 是否了解 Web 开发。</p>
<p>了解需求：1. 登陆界面是弹出窗口式的，还是直接在网页里面；2. 账号长度和密码的强度要求（比如需要多少位、大小写敏感、特殊字符混搭）；3. 界面美观是否有特殊要求（是否要进行UI测试）</p>
<p>用例设计：</p>
<h5 id="1功能测试function-test"><a class="markdownIt-Anchor" href="#1功能测试function-test"></a> 1）功能测试：Function Test</h5>
<ol>
<li>
<p>输入正确的账号密码，点击提交按钮，验证是否能正确登陆（正常输入）</p>
</li>
<li>
<p>输入错误的账号密码，验证登陆会失败，与给出相应的错误提示（错误输入）</p>
</li>
<li>
<p>登陆成功后能否正确跳转到正确界面</p>
</li>
<li>
<p>账号和密码如果太长或太短，应该怎么处理（安全性，密码太短都有提示）</p>
</li>
<li>
<p>账号和密码中，有特殊字符（比如空格）和其他非英文情况（是否做了顾虑）</p>
</li>
<li>
<p>账号和密码前后都有空格的处理</p>
</li>
<li>
<p>输入密码时，大写键盘有提示</p>
</li>
<li>
<p>密码是否加密显示</p>
</li>
<li>
<p>什么都不输，点击提交按钮，看提示信息</p>
</li>
<li>
<p>记住账号功能</p>
</li>
<li>
<p>登陆失败后，不能记录密码的功能</p>
</li>
<li>
<p>牵涉到验证码的，还要考虑验证难度是否过大，刷新或者换一个的按钮是否好用</p>
</li>
<li>
<p>登陆页面中的注册、忘记密码、登出、用另一账号等链接是否正确</p>
</li>
</ol>
<h5 id="2界面测试ui-test"><a class="markdownIt-Anchor" href="#2界面测试ui-test"></a> 2）界面测试：UI Test</h5>
<ol>
<li>布局是否合理，2个Testbox和1个按钮是否对其</li>
<li>Testbox和按钮的长度，高度是否符合要求</li>
<li>界面的设计风格是否与UI的设计风格统一</li>
<li>界面的文字简洁易懂，没有错别字</li>
</ol>
<h5 id="3性能测试-performance-test"><a class="markdownIt-Anchor" href="#3性能测试-performance-test"></a> 3）性能测试 Performance Test</h5>
<ol>
<li>打开登陆页面，需要几秒</li>
<li>输入正确的账号密码后，登陆成功跳转到新页面，不超过5秒</li>
</ol>
<h5 id="4安全性测试-security-test"><a class="markdownIt-Anchor" href="#4安全性测试-security-test"></a> 4）安全性测试 Security Test</h5>
<ol>
<li>登陆成功后生成的 Cookie 是否有 HttpOnly（降低脚本盗取风险）</li>
<li>账号密码是否通过加密的方式，发送到Web服务器</li>
<li>账号和密码的验证，应该是用服务器端验证，而不只是用客户端的JS分析</li>
<li>账号和密码的输入框，应该屏蔽SQL注入攻击</li>
<li>账号和密码的输入框，要禁止输入脚本（防止XSS攻击）</li>
<li>错误登陆的次数使用限制（防止暴力破解）</li>
<li>考虑是否支持多用户在同一机器上登陆</li>
<li>考虑一用户在多台机器登陆</li>
</ol>
<h5 id="5可用性测试-usability-test"><a class="markdownIt-Anchor" href="#5可用性测试-usability-test"></a> 5）可用性测试 Usability Test</h5>
<ol>
<li>是否可以用全键盘操作，是否有快捷键</li>
<li>输入账号，密码后回车，是否可以登陆</li>
<li>输入框是否可以用Tab切换</li>
</ol>
<h5 id="6兼容性测试-compatibility-test"><a class="markdownIt-Anchor" href="#6兼容性测试-compatibility-test"></a> 6）兼容性测试 Compatibility Test</h5>
<ol>
<li>主流浏览器功能是否正常</li>
<li>不同系统平台是否工作正常（Macos pc）</li>
<li>移动设备是否工作正常</li>
<li>不同分辨率</li>
</ol>
<h5 id="7本地化测试-localization-test"><a class="markdownIt-Anchor" href="#7本地化测试-localization-test"></a> 7）本地化测试 Localization Test</h5>
<p>不同语言环境，页面显示是否正确</p>
<h5 id="8辅助性测试"><a class="markdownIt-Anchor" href="#8辅助性测试"></a> 8）辅助性测试</h5>
<p>高对比度下是否显示正常（视力不好的人）</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试基础理论</title>
    <url>/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/</url>
    <content><![CDATA[<h3 id="软件测试的分类"><a class="markdownIt-Anchor" href="#软件测试的分类"></a> 软件测试的分类</h3>
<h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4>
<ul>
<li>
<p>黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「<strong><a href="https://www.omegaxyz.com/2019/07/23/software-specification/">需求规格说明书</a></strong>」，检查程序的功能是否符合它的功能说明。</p>
<p>方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等</p>
<ul>
<li>错误推测法：基于<strong>经验和直觉</strong>，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格……</li>
<li>因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的<strong>联系、组合情况</strong>。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。<strong>因果图最终产生的是判定表</strong>。</li>
</ul>
</li>
<li>
<p>白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。</p>
<p>主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等</p>
<a id="more"></a>
</li>
</ul>
<hr />
<h4 id="阶段"><a class="markdownIt-Anchor" href="#阶段"></a> 阶段</h4>
<ul>
<li>
<p>单元测试：</p>
<ul>
<li>重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「<strong>最小可测试单元</strong>」进行检查和验证，所以全局测试不算是单元测试。</li>
<li>单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态数据流分析</li>
<li>单元测试方法：控制流测试、数据流测试、排错测试、分域测试</li>
</ul>
</li>
<li>
<p>集成测试：重点测试「接口」</p>
<ul>
<li>
<p>策略：自顶向下和自底向上</p>
</li>
<li>
<p>应关注：</p>
<img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/jicheng-test.png" alt="jicheng-test" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>系统测试</p>
<p>测试方法有：功能、安全、性能、兼容性、易用性、稳定性……</p>
</li>
<li>
<p>验收测试</p>
<p>Alpha：用户在<strong>开发者的场所</strong>进行，并且在开发者对用户的“指导”下进行测试。总是，A测试是在<strong>受控的环境</strong>下进行的。</p>
<p>Beta：与上相对。</p>
</li>
</ul>
<hr />
<h4 id="方向"><a class="markdownIt-Anchor" href="#方向"></a> 方向</h4>
<ul>
<li>
<p>功能测试：看功能是否正常。</p>
<blockquote>
<p>黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做）</p>
</blockquote>
</li>
<li>
<p>性能测试：判断程序能做多好（与时间挂钩）</p>
<ul>
<li>
<p>压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。</p>
</li>
<li>
<p>负载测试：</p>
<p>定义：数据在超负荷环境下运行，测试软件系统是否能够承担。这种超负荷主要指多并发用户。</p>
<p>理解：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟）</p>
<p>方法：认为生成大量数据，并利用工具模拟频繁并发访问</p>
<blockquote>
<p>以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。</p>
</blockquote>
</li>
<li>
<p>并发测试：一瞬间同一个程序在做同一件事情</p>
</li>
</ul>
<p>从用户角度看性能：软件对用户操作的响应时间</p>
<p>系统管理员角度看：</p>
<ul>
<li>系统的响应时间</li>
<li>系统运行服务器的状态，如cpu利用情况、内润使用情况等</li>
<li>系统是否能够实现拓展</li>
<li>系统支持多少用户访问</li>
<li>系统性能的瓶颈在哪里</li>
<li>系统是否支持7*24小时的业务访问</li>
</ul>
</li>
<li>
<p>安全测试（了解）：防止攻击，例如ddos等</p>
</li>
<li>
<p>兼容性</p>
</li>
</ul>
<h4 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h4>
<p>根据软件的状态划分的</p>
<ul>
<li>静态：不会运行的软件，通过白盒测试看代码</li>
<li>动态：把软件运行起来测试</li>
</ul>
<h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4>
<ul>
<li>冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试），仅对基本功能测试，保证软件跑得起来。</li>
<li>回归测试：回归bug，bug修改了，有没有检查。</li>
</ul>
<hr />
<h3 id="测试流程"><a class="markdownIt-Anchor" href="#测试流程"></a> 测试流程</h3>
<p>4个阶段：测试需求分析阶段、测试计划阶段、执行测试阶段、测试评估阶段。</p>
<h4 id="需求分析阶段"><a class="markdownIt-Anchor" href="#需求分析阶段"></a> 需求分析阶段</h4>
<p>主要是学习业务流程，提取功能点，把小功能提取出来，做成树状图。</p>
<ul>
<li>阅读需求文档：产品经理用文档描述</li>
<li>查看产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。）</li>
</ul>
<h4 id="测试设计阶段"><a class="markdownIt-Anchor" href="#测试设计阶段"></a> 测试设计阶段</h4>
<blockquote>
<p>前三个由产品经理或者组长写，方法是：5W1H</p>
</blockquote>
<ul>
<li>
<p>测试计划：时间、人、资源的分配</p>
</li>
<li>
<p>测试方案</p>
<ul>
<li>每个测试内容如何展开</li>
<li>采用什么测试计划</li>
<li>哪些内容先测</li>
</ul>
</li>
<li>
<p>测试策略</p>
<ul>
<li>哪些内容先测后测（先测功能还是兼容？）</li>
<li>开始和结束的标准是什么？</li>
</ul>
</li>
<li>
<p><strong>测试用例（重点！重中之重！）</strong></p>
<p>包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。</p>
<ul>
<li>
<p>用例编号：唯一的</p>
</li>
<li>
<p>用例名称：言简意赅</p>
</li>
<li>
<p>前置条件：在执行用例前，软件必须要满足的条件</p>
</li>
<li>
<p>优先级：执行用例的时间要求紧急的等级</p>
</li>
<li>
<p>重要级：被测功能在软件中的重要等级</p>
</li>
</ul>
<p>要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ）</p>
</li>
</ul>
<blockquote>
<p>测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方</p>
</blockquote>
<h4 id="测试执行阶段"><a class="markdownIt-Anchor" href="#测试执行阶段"></a> 测试执行阶段</h4>
<p>搭建环境，执行冒烟测试，然后正式测试。</p>
<h4 id="测试评估阶段"><a class="markdownIt-Anchor" href="#测试评估阶段"></a> 测试评估阶段</h4>
<p>出测试报告，确认是否可以上线。</p>
<hr />
<h3 id="测试方法"><a class="markdownIt-Anchor" href="#测试方法"></a> 测试方法</h3>
<h4 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h4>
<p>通过少部分的值，代表大部分的情况。</p>
<ul>
<li>
<p>有效等价类</p>
<p>满足条件的：0.01，0.02，200，199.99</p>
</li>
<li>
<p>无效等价类</p>
<p>不满足条件的：0，200.01</p>
</li>
</ul>
<h4 id="边界法"><a class="markdownIt-Anchor" href="#边界法"></a> 边界法</h4>
<p>0，负数，+1，-1，本身，整数，非整数，字符</p>
<hr />
<h3 id="研发管理模型"><a class="markdownIt-Anchor" href="#研发管理模型"></a> 研发管理模型</h3>
<blockquote>
<p>作用：在开发中会经历很多过程，模型可以知道不同的工作流程。</p>
</blockquote>
<h4 id="瀑布流"><a class="markdownIt-Anchor" href="#瀑布流"></a> 瀑布流</h4>
<p>从上往下，不可逆不可返回的流程。</p>
<h4 id="v字型"><a class="markdownIt-Anchor" href="#v字型"></a> V字型</h4>
<p>左边是开发做的，右边是测试做的，二者一一对照。</p>
<h4 id="w字型"><a class="markdownIt-Anchor" href="#w字型"></a> w字型</h4>
<p>测试与开发同步了。</p>
<hr />
<h3 id="软件的生命周期"><a class="markdownIt-Anchor" href="#软件的生命周期"></a> 软件的生命周期</h3>
<p>是指软件的产生到报废的整个过程。包括可行性分析与项目计划，需求分析，概要设计和详细设计，编码，调试，维护七个阶段。</p>
<h3 id="软件测试的生命周期"><a class="markdownIt-Anchor" href="#软件测试的生命周期"></a> 软件测试的生命周期</h3>
<p>是指从测试项目计划建立到BUG提交的整个「测试过程」，包括测试计划，测试需求分析，测试用例编写，测试用例执行，BUG提交。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
</search>
