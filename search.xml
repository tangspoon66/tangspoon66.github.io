<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About POM</title>
    <url>/2020/12/04/About-POM/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201204165031981.png" alt="image-20201204165031981" style="zoom:50%;" />
<a id="more"></a>
<h2 id="一-什么是pom"><a class="markdownIt-Anchor" href="#一-什么是pom"></a> 一、什么是POM</h2>
<p>POM：Page Object Model——页面对象模型。是一种思想，是一种设计模式，相对应的还有关键字设计模式。</p>
<h2 id="二-为什么要用pom"><a class="markdownIt-Anchor" href="#二-为什么要用pom"></a> 二、为什么要用POM</h2>
<p>在自动化测试的代码编写中，采用普通模式，会产生很多代码冗余。例如元素定位模块，每一个元素都得写<code>find_element_by_xxx</code>，在大型项目中这么写效率显然非常低下。</p>
<p>另外，在UI测试中，前端元素会经常发生改变。普通模式把元素定位、元素操作逻辑、测试脚本等模块揉杂在一个文件内，其一，这种操作看起来非常混乱；其二，如果前端页面发生变化，首先要修改页面元素定位，还要修改测试代码。</p>
<p>而POM模型，把元素定位、业务逻辑分开编写，每个模块独立。每一个页面对应一个页面类，页面的元素写到这个页面类中。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201204162211182.png" alt="image-20201204162211182" style="zoom:50%;" />
<h2 id="三-在哪一阶段要用到pom"><a class="markdownIt-Anchor" href="#三-在哪一阶段要用到pom"></a> 三、在哪一阶段要用到POM</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201205163712845.png" alt="image-20201205163712845" style="zoom:50%;" />
<h2 id="四-怎么用"><a class="markdownIt-Anchor" href="#四-怎么用"></a> 四、怎么用</h2>
<h3 id="1-bagepy如下"><a class="markdownIt-Anchor" href="#1-bagepy如下"></a> 1. bage.py如下：</h3>
<p>base.py主要写复用率高的函数，比如打开页面、元素定位、退出等等。该页面中不应该含有固定参数，应该全用变量，所有变量都应该在测试用例中定义的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="comment"># init</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, driver, url</span>):</span></span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="comment"># open</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># locator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">locator</span>(<span class="params">self, loc</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.driver.find_element(*loc)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># quit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quit</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.driver.quit()</span><br></pre></td></tr></table></figure>
<h3 id="2-login_pagepy如下"><a class="markdownIt-Anchor" href="#2-login_pagepy如下"></a> 2. login_page.py如下：</h3>
<p>对象页面其实也就只需写两个内容，获取元素，然后封装元素的每一个操作：先定位，然后再用selenium的元素操作send_keys、click等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> base_page.base <span class="keyword">import</span> BasePage</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在这里主要写登陆页面，思路如下：</span></span><br><span class="line"><span class="string">    1、找到元素</span></span><br><span class="line"><span class="string">    2、然后元素操作封装</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span>(<span class="params">BasePage</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;http://39.98.138.157/shopxo/index.php?s=/index/user/logininfo.html&#x27;</span></span><br><span class="line"></span><br><span class="line">    username = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[1]/input&#x27;</span>)</span><br><span class="line">    password = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[2]/input&#x27;</span>)</span><br><span class="line">    login_btn = (By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[3]/button&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_username</span>(<span class="params">self, un</span>):</span></span><br><span class="line">        self.locator(self.username).send_keys(un)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">input_password</span>(<span class="params">self, pwd</span>):</span></span><br><span class="line">        self.locator(self.password).send_keys(pwd)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click_login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.locator(self.login_btn).click()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-testunitpy如下"><a class="markdownIt-Anchor" href="#3-testunitpy如下"></a> 3. TestUnit.py如下：</h3>
<p>在测试模块中，可以用unittest进行测试。并生成相应的测试报告。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> page_object.login_page <span class="keyword">import</span> LoginPage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestUnit</span>(<span class="params">LoginPage</span>):</span></span><br><span class="line">    <span class="comment"># 写测试流程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.open()</span><br><span class="line">        self.input_username(un)</span><br><span class="line">        self.input_password(pwd)</span><br><span class="line">        self.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    un = <span class="string">&#x27;carslan&#x27;</span></span><br><span class="line">    pwd = <span class="string">&#x27;666666&#x27;</span></span><br><span class="line">    driver = webdriver.Chrome()</span><br><span class="line">    lp = TestUnit(driver, LoginPage.url)</span><br><span class="line">    lp.login()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-todo-list"><a class="markdownIt-Anchor" href="#四-todo-list"></a> 四、Todo List</h2>
<ol>
<li>
<p>使用unittest重新整合TestUnit部分</p>
</li>
<li>
<p>加入流程异常捕捉断言测试。</p>
<p>在测试当中，正常流程的实现当然重要，但在编写脚本时，应该注意异常情况的捕捉反馈。</p>
</li>
<li>
<p>对自己的宠物论坛的注册、登陆、发帖编写自动化测试脚本，并生成相应的测试报告。</p>
</li>
</ol>
<h2 id="五-项目源代码下载"><a class="markdownIt-Anchor" href="#五-项目源代码下载"></a> 五、项目源代码下载</h2>
<p>进入<a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/AutoTest">AutoTest</a>文件夹下载POM_Get.zip文件。完成上面的todo后，整个项目将上传到<br />
Github中。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>About unittest</title>
    <url>/2020/12/04/About-unittest/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201204184242525.png" alt="image-20201204184242525" style="zoom:50%;" />
<a id="more"></a>
<h2 id="一-testfixture"><a class="markdownIt-Anchor" href="#一-testfixture"></a> 一、TestFixture</h2>
<p>该部分内容极为简单，不再赘述。</p>
<h2 id="二-testsuite"><a class="markdownIt-Anchor" href="#二-testsuite"></a> 二、TestSuite</h2>
<ul>
<li>作用：把测试用例组合到一起</li>
<li>TestSuite()是一个类，需要实例化使用。</li>
</ul>
<h3 id="1-addtest-逐个加载用例"><a class="markdownIt-Anchor" href="#1-addtest-逐个加载用例"></a> 1. addTest() 「逐个」加载用例</h3>
<p>格式：addTest(测试类名(‘测试用例’))</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllTest</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 测试用例1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试用例2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.assertEqual(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	<span class="comment"># 实例化TestSuite()</span></span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    suite.addTest(AllTest(<span class="string">&#x27;test_1&#x27;</span>))</span><br><span class="line">    suite.addTest(AllTest(<span class="string">&#x27;test_2&#x27;</span>))</span><br><span class="line">    unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(suite)</span><br></pre></td></tr></table></figure>
<h3 id="2-loadtestsformtestcase测试类名-loadtestsfrommodule模块名py"><a class="markdownIt-Anchor" href="#2-loadtestsformtestcase测试类名-loadtestsfrommodule模块名py"></a> 2. loadTestsFormTestCase(测试类名)、loadTestsFromModule(‘<a href="http://xn--eqr79ejvx.py">模块名.py</a>’)</h3>
<p>两个都是是继承<code>Testloader()</code>，只是前面是加载一个测试类，后者是加载模块名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suite=unittest.TestLoader().loadTestsFromTestCase(BaiduTest)</span><br><span class="line">suite=unittest.TestLoader().loadTestsFromModule(<span class="string">&#x27;unittest1.py&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-discover-批量加载用例"><a class="markdownIt-Anchor" href="#3-discover-批量加载用例"></a> 3. discover() 「批量」加载用例</h3>
<p>使用discover()，其实和使用addTest()是类似的，都是要实例化才能使用。</p>
<p>我们来看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suite = unittest.TestSuite().addTest(xxxx)</span><br><span class="line">discover = unittest.defaultTestLoader.discover(test_dir,pattern=<span class="string">&#x27;xxx&#x27;</span>,top_level_dir=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>其实<code>addTest</code>()是<code>unittest</code> 的<code>TestSuite()</code>类下面的一个子类而已，同样的，<code>discover()</code>是<code>unitest</code>的<code>defaultTestLoder()</code>类下的字类，所以都是需要实例化的。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201204231834582.png" alt="image-20201204231834582" /></p>
<ul>
<li>start_dir ：要测试的模块名或测试用例目录。</li>
<li>pattern=‘test*.py’ ：表示用例文件名的匹配原则。星号“*”表示任意多个字符。</li>
<li>top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录中），默认为 None。</li>
</ul>
<h2 id="三-测试断言"><a class="markdownIt-Anchor" href="#三-测试断言"></a> 三、测试断言</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201204233159773.png" alt="image-20201204233159773" style="zoom:50%;" />
<p>一个测试用例只有两种结果，要么 Pass，要么 Fail（代码错误也显示 Fail）。因此，在自动化测试的测试用例中，切记不要使用 if else 这类判 断代码来代替断言。</p>
<p>另外，在自动化测试中尽量不要应用打印结果来判断测试 用例的情况，用例如，果在代码错误或者功能有 Bug 的情况下就让用例报错或 者失败，而不是结果显示 Pass，只有功能正常的测试用例结果才是 Pass 的。</p>
<h2 id="四-生成测试报告"><a class="markdownIt-Anchor" href="#四-生成测试报告"></a> 四、生成测试报告</h2>
<p>此处建议使用unittestreport，项目介绍：<a href="http://testingpai.com/article/1595507317340">http://testingpai.com/article/1595507317340</a></p>
<p>需要注意的是，使用pip install的方式安装后，要在PyCharm的Interpreter中添加。使用使用更佳方便，效果也更加美观。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207161245421.png" alt="image-20201207161245421" style="zoom:50%;" />
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask 学习笔记 - Hello</title>
    <url>/2020/12/26/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Hello/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201226170026026.png" alt="image-20201226170026026" style="zoom:50%;" />
<p>如何优雅地在<a href="https://github.com/tangspoon66/NeteaseCloud-Clock">智能闹钟</a>上设定闹钟呢？使用命令行谈和优雅。想着能不能做个内网简单网页，通过web界面控制（增加与删除）<code>crontab</code>呢？了解到python相关的前端框架<code>flask</code>似乎有点意思，先学习看看。</p>
<a id="more"></a>
<blockquote>
<p>书名：<a href="https://read.helloflask.com">Flask 入门教程</a></p>
<p>作者：<a href="http://greyli.com/">李辉</a></p>
</blockquote>
<h2 id="一-虚拟环境的使用"><a class="markdownIt-Anchor" href="#一-虚拟环境的使用"></a> 一、虚拟环境的使用</h2>
<h3 id="1-创建虚拟环境"><a class="markdownIt-Anchor" href="#1-创建虚拟环境"></a> 1. 创建虚拟环境</h3>
<ul>
<li>保持全局环境的干净</li>
<li>指定不同的依赖版本</li>
<li>方便记录和管理依赖</li>
</ul>
<p>macOS创建虚拟环境方法：到你想要的文件夹，然后打开<code>terminal</code>，输入以下代码。然后在该文件夹会新生成一个<code>env</code>的文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m venv env</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>venv</code>是python中内置的模块，使用该模块来创建虚拟环境；<code>env</code>是虚拟环境的名字</p>
</blockquote>
<h3 id="2-激活虚拟环境"><a class="markdownIt-Anchor" href="#2-激活虚拟环境"></a> 2. 激活虚拟环境</h3>
<p>网上大部分激活教程都是直接给出<code>. env/bin/activate</code>。但对新手来说似乎有点摸不着头脑：前面的<code>.</code>是啥？</p>
<p>我们不妨直接打开activate文件试试。原来里面有说明具体用法！我们必须通过<code>source bin/activate</code>的方式激活，不能直接运行<code>activate</code>文件。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201225174954727.png" alt="image-20201225174954727" /></p>
<p>而且，我们要激活<code>env</code>，当然先要进入到<code>env</code>环境当中，所以可得激活方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd env &amp;&amp; source bin&#x2F;activate</span><br></pre></td></tr></table></figure>
<p>激活成功后，会变成下面这样：</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201225175417095.png" alt="image-20201225175417095" /></p>
<h3 id="3-退出虚拟环境"><a class="markdownIt-Anchor" href="#3-退出虚拟环境"></a> 3. 退出虚拟环境</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<h2 id="二-安装flask"><a class="markdownIt-Anchor" href="#二-安装flask"></a> 二、安装flask</h2>
<p><strong>激活虚拟环境后</strong>，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install falsk</span><br></pre></td></tr></table></figure>
<h2 id="三-搭建最简单的flask项目"><a class="markdownIt-Anchor" href="#三-搭建最简单的flask项目"></a> 三、搭建最简单的flask项目</h2>
<p>因为是最简单的项目，所以我们都在<code>terminal</code>内进行吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在env内新建一个app文件夹，同时新建app.py</span><br><span class="line">mkdir app &amp;&amp; touch app.py</span><br><span class="line"># 编辑app.py</span><br><span class="line">vim app.py</span><br></pre></td></tr></table></figure>
<p>然后粘贴以下内容后，退出并保存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> flask </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;你好！&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="四-运行"><a class="markdownIt-Anchor" href="#四-运行"></a> 四、运行</h2>
<p>然后在<code>app</code>文件夹内，运行项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201225180401088.png" alt="image-20201225180401088" /></p>
<p>然后在浏览器访问：<code>http://localhost:5000</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201225180658962.png" alt="image-20201225180658962" style="zoom: 50%;" />
<h2 id="五-细节注意"><a class="markdownIt-Anchor" href="#五-细节注意"></a> 五、细节注意</h2>
<h3 id="1-主程序更换名字"><a class="markdownIt-Anchor" href="#1-主程序更换名字"></a> 1. 主程序更换名字</h3>
<p>如果把<code>app.py</code>保存为<code>hello.py</code>，尝试运行后会报错。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201226112334472.png" alt="image-20201226112334472" style="zoom:50%;" />
<p>原因是flask默认识别启动的是<code>app.py</code>或者<code>wsgi.py</code>。如果要识别其他名字，可以设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FLASK_APP&#x3D;hello.py</span><br></pre></td></tr></table></figure>
<h3 id="2-打开调试模式"><a class="markdownIt-Anchor" href="#2-打开调试模式"></a> 2. 打开调试模式</h3>
<blockquote>
<p>现在在启动 Flask 程序的时候，我们通常要和两个环境变量打交道：<code>FLASK_APP</code> 和 <code>FLASK_ENV</code>。因为我们的程序现在的名字是 <a href="http://app.py">app.py</a>，暂时不需要设置 <code>FLASK_APP</code>；<code>FLASK_ENV</code> 用来设置程序运行的环境，默认为 <code>production</code>。在开发时，我们需要开启调试模式（debug mode）。调试模式可以通过将系统环境变量 <code>FLASK_ENV</code> 设为 <code>development</code> 来开启。调试模式开启后，当程序出错，浏览器页面上会显示错误信息；代码出现变动后，程序会自动重载。</p>
</blockquote>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201226113224956.png" alt="image-20201226113224956" /></p>
<h3 id="1-手动打开"><a class="markdownIt-Anchor" href="#1-手动打开"></a> 1. 手动打开</h3>
<p>每次进入虚拟环境<code>env</code>后手动打开 <code>Debug mode</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FLASK_ENV&#x3D;development</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201226113621763.png" alt="image-20201226113621763" style="zoom:50%;" />
<h3 id="2-自动打开"><a class="markdownIt-Anchor" href="#2-自动打开"></a> 2. 自动打开</h3>
<p>可是每次激活了虚拟环境都需要手动打开就很麻烦，我们来个一劳永逸的方法。</p>
<p>进入到虚拟环境<code>env</code>中，然后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建文件</span><br><span class="line">touch .flaskenv</span><br></pre></td></tr></table></figure>
<p>然后在文件内添加入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLASK_ENV&#x3D;development</span><br></pre></td></tr></table></figure>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201226114955265.png" alt="image-20201226114955265" /></p>
<p>然后尝试重启一下<code>env</code>，就会自动打开<code>Debug mode</code>了。</p>
<h2 id="六-一些解释"><a class="markdownIt-Anchor" href="#六-一些解释"></a> 六、一些解释</h2>
<h3 id="1-项目根目录指的是"><a class="markdownIt-Anchor" href="#1-项目根目录指的是"></a> 1. 项目根目录指的是？</h3>
<p><code>app</code>这个文件夹。（<code>env</code>文件夹是虚拟环境）</p>
<h3 id="2-我们的程序指的是"><a class="markdownIt-Anchor" href="#2-我们的程序指的是"></a> 2. “我们的程序”指的是？</h3>
<p>我们的程序指的是<code>app.py</code>里面的代码</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-01</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</url>
    <content><![CDATA[<p>基础的语法不再赘述，只强调以前未接触过的。</p>
<h3 id="一-数据类型和变量"><a class="markdownIt-Anchor" href="#一-数据类型和变量"></a> 一、数据类型和变量</h3>
<h5 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h5>
<p>键值对组成</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="code">    name: &#x27;Bob&#x27;,</span></span><br><span class="line"><span class="code">    age: 20,</span></span><br><span class="line"><span class="code">    tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;],</span></span><br><span class="line"><span class="code">    city: &#x27;Beijing&#x27;,</span></span><br><span class="line"><span class="code">    hasCar: true,</span></span><br><span class="line"><span class="code">    zipcode: null</span></span><br><span class="line"><span class="code">&#125;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Person为<code>对象</code>，name、age为<code>键</code>，‘Bob’、20为<code>值</code></li>
<li>获取对象的属性（怎么用对象的数据）：<a href="http://person.name">person.name</a></li>
</ul>
<a id="more"></a>
<h5 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h5>
<p>只能用<code>var</code>申明一次。没用<code>var</code>申明的变量：全局变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>
<h5 id="strict模式"><a class="markdownIt-Anchor" href="#strict模式"></a> strict模式</h5>
<p><code>'use strict';</code>强制通过<code>var</code>申明</p>
<h3 id="二-字符串"><a class="markdownIt-Anchor" href="#二-字符串"></a> 二、字符串</h3>
<ol>
<li>
<h5 id="多行字符串"><a class="markdownIt-Anchor" href="#多行字符串"></a> 多行字符串</h5>
<p>由于多行字符串用<code>\n</code>写起来费事，最新的ES6标准新增了如下方式表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;这是一个</span><br><span class="line">多行</span><br><span class="line">字符串&#96;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="模板字符串"><a class="markdownIt-Anchor" href="#模板字符串"></a> 模板字符串</h5>
<p>很多变量连接时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;小明&#39;;</span><br><span class="line">var age &#x3D; 20;</span><br><span class="line">var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三-数组"><a class="markdownIt-Anchor" href="#三-数组"></a> 三、数组</h3>
<ol>
<li>
<h5 id="indexof"><a class="markdownIt-Anchor" href="#indexof"></a> indexOf()</h5>
<p>搜索指定元素的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];</span><br><span class="line">arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0</span><br><span class="line">arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1</span><br><span class="line">arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="slice"><a class="markdownIt-Anchor" href="#slice"></a> slice()</h5>
<p>截取Array的部分元素，返回一个新的Array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>slice()</code>的起止参数包括开始索引，不包括结束索引</li>
<li>如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">var aCopy &#x3D; arr.slice();</span><br><span class="line">aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br><span class="line">aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="push-和-pop"><a class="markdownIt-Anchor" href="#push-和-pop"></a> push() 和 pop()</h5>
<ul>
<li><code>push()</code>插入数组尾部</li>
<li><code>pop()</code>删除～</li>
</ul>
</li>
<li>
<h5 id="unshift-和-shift"><a class="markdownIt-Anchor" href="#unshift-和-shift"></a> unshift() 和 shift()</h5>
<ul>
<li><code>unshift()</code>插入 头部第一</li>
<li><code>shift()</code>删除头部第一</li>
</ul>
</li>
<li>
<h5 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse()</h5>
<p>数组的反转</p>
</li>
<li>
<h5 id="splice"><a class="markdownIt-Anchor" href="#splice"></a> splice()</h5>
<p><em><strong>修改数组的万能方法</strong></em>，格式为：从哪里开始，删除多少个，添加什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure>
</li>
<li>
<h5 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat()</h5>
<p>连接两个数组。没有修改原数组，只是生成新数组</p>
</li>
<li>
<h5 id="join"><a class="markdownIt-Anchor" href="#join"></a> join()</h5>
<p>把<code>array</code>里面的元素，用指定的字符连起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];</span><br><span class="line">arr.join(&#39;-&#39;);</span><br><span class="line">arr;返回的就是&#39;a-b&#39;</span><br></pre></td></tr></table></figure>
<p>ps：如果Array的元素不是字符串，则自动转化再拼接</p>
</li>
</ol>
<h3 id="三-对象"><a class="markdownIt-Anchor" href="#三-对象"></a> 三、对象</h3>
<ol>
<li>
<p>用[‘x’]访问（少用）</p>
<p>属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用<code>.</code>访问</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaohong &#x3D; &#123;</span><br><span class="line">    name: &#39;小红&#39;,</span><br><span class="line">    &#39;middle-school&#39;: &#39;No.1 Middle School&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;</span><br><span class="line">xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;</span><br><span class="line">xiaohong.name; &#x2F;&#x2F; &#39;小红&#39;</span><br></pre></td></tr></table></figure>
<p><strong>ps：写代码尽量规范，尽量用<code>.</code>访问</strong></p>
<ol start="2">
<li>
<p>由于对象是动态类型，因此可以随便给对象添加或修改属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming&#x3D;&#123;</span><br><span class="line">		name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F;undefined</span><br><span class="line">xiaoming.age&#x3D;18;  &#x2F;&#x2F;添加了age属性</span><br><span class="line">delete xiaoming.age;  &#x2F;&#x2F;删除name属性</span><br><span class="line">xiaoming.age;  &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.name; &#x2F;&#x2F;删除name</span><br><span class="line">xiaoming.name; &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>检测属性存在性</p>
<ul>
<li>用<code>in</code>操作符，返回布尔值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用<code>hasOwnProperty()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  	name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-02</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</url>
    <content><![CDATA[<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3>
<h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4>
<p><code>for</code>循环三个条件可省略，但如果无退出条件，则死循环。退出：break</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="forin"><a class="markdownIt-Anchor" href="#forin"></a> for…in</h4>
<p>用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//&#x27;name&#x27;  &#x27;age&#x27;  &#x27;school&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//‘0’，‘1’，‘2‘</span></span><br><span class="line">  <span class="comment">/*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/</span></span><br><span class="line">  <span class="comment">/*请注意，for ... in对Array的循环得到的是String而不是Number。*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例三</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">//&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要过滤继承属性，使用day01学的<code>hasOwnProperty()</code>方法实现。例如：</p>
<p>ps：或者使用<code>for...of</code>，这也是为什么设计<code>for...of</code>的原因之一。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="keyword">if</span>(o.hasOwnProperty(key))&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">//不然会输出toString属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性<code>key</code>」</li>
</ul>
</blockquote>
<h4 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h4>
<p>请利用循环遍历数组中的每个名字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>];</span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">var</span> i=arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forof"><a class="markdownIt-Anchor" href="#forof"></a> for…of</h3>
<blockquote>
<ul>
<li>
<p>for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。</p>
</li>
<li>
<p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p>
</li>
</ul>
</blockquote>
<p>参考 <a href="https://www.zhangxinxu.com/wordpress/2018/08/for-in-es6-for-of/">张鑫旭大佬的文章</a></p>
<h3 id="map和set"><a class="markdownIt-Anchor" href="#map和set"></a> Map和Set</h3>
<blockquote>
<p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
</blockquote>
<h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4>
<p><code>Map</code>是一组「键值对」的结构，具有极快的查找速度。例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="string">&#x27;Micheal&#x27;</span>,<span class="number">95</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">88</span>],[<span class="string">&#x27;Tracy&#x27;</span>,<span class="number">93</span>])</span><br><span class="line">m.get(<span class="string">&#x27;Micheal&#x27;</span>); <span class="comment">//返回的是95！</span></span><br><span class="line"><span class="comment">//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字</span></span><br></pre></td></tr></table></figure>
<p>其他操作如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m= <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//新建空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">100</span>);  <span class="comment">//添加新 key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">1</span>);  <span class="comment">//覆盖上面的100，返回1</span></span><br><span class="line">m.has(<span class="string">&#x27;tang&#x27;</span>);  <span class="comment">//返回true</span></span><br><span class="line">m.delete(<span class="string">&#x27;tang&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4>
<p>与<code>Map</code>不同，Set只存「key」，不存「value」。key不能重复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>'3'</code>是不同的元素。</p>
<p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterable-forof"><a class="markdownIt-Anchor" href="#iterable-forof"></a> iterable &amp; for…of</h3>
<blockquote>
<p><code>Array</code>可以下标循环，但遍历<code>Map</code> 和<code>Set</code>就无法使用下标。为了统一集合类型，ES6引入了<code>iterable</code>类型，<code>Array</code> 、<code>Map</code>和<code>Set</code> 都属于<code>iterable</code>类型。</p>
</blockquote>
<p>具有<code>iterable</code>类型的「集合」，可以通过<code>for...of</code>循环来遍历</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS学习笔记-03</title>
    <url>/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/</url>
    <content><![CDATA[<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<h4 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4>
<p>调用函数时，按顺序传入参数。</p>
<blockquote>
<p>JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br><span class="line">abs(); <span class="comment">// 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免</span></span><br></pre></td></tr></table></figure>
<h4 id="arguments"><a class="markdownIt-Anchor" href="#arguments"></a> arguments</h4>
<ul>
<li>获得调用者的所有参数，但不是一个<code>Array</code></li>
<li>是一个关键字</li>
<li>只在函数内部起作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 308</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>要善于利用<code>arguments</code>判断传入参数多少的作用</p>
</blockquote>
<h4 id="rest参数"><a class="markdownIt-Anchor" href="#rest参数"></a> rest参数</h4>
<blockquote>
<p>是ES6新增的特性，形式为：…变量名</p>
</blockquote>
<p>作用：获取函数多余的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取a，b之外的参数例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined 因为b在参数中被定义了，要直接输出</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure>
<h3 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h3>
<ol>
<li>
<p>用<code>rest</code>参数编写一个<code>add()</code>函数，用于接收任意个参数并返回她们的和。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line">    rest.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elemnt</span>)</span>&#123;</span><br><span class="line">      sum += element;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义一个计算圆面积的函数<code>area_of_circle()</code>，它有两个参数：</p>
<ul>
<li>r: 表示圆的半径；</li>
<li>pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r,pi</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.14</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.1416</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r, pi</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span>[r,pi=<span class="number">3.14</span>]=<span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> pi*r*r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域和解构赋值"><a class="markdownIt-Anchor" href="#变量作用域和解构赋值"></a> 变量作用域和解构赋值</h3>
<h4 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h4>
<p>js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。</p>
<blockquote>
<p>注意：只是变量的声明，并不是赋值。</p>
</blockquote>
<h4 id="块级作用域"><a class="markdownIt-Anchor" href="#块级作用域"></a> 块级作用域</h4>
<p>ES6引入了新关键字 <code>let</code>，用<code>let</code>代替<code>var</code>可以声明一个块级作用域的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4>
<p>ES6引入了一个<code>const</code>关键字来定义常量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure>
<h4 id="解构赋值"><a class="markdownIt-Anchor" href="#解构赋值"></a> 解构赋值</h4>
<blockquote>
<p>此知识点小点比较多，详细请看<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808">廖雪峰的官网</a></p>
</blockquote>
<ul>
<li>在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>如果数组本身还有嵌套，只需要嵌套和层次对齐即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[x,[y,z]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br></pre></td></tr></table></figure>
<ul>
<li>从对象中取出其中几个属性的值，也可以用解构赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  name: <span class="string">&#x27;tang&#x27;</span>,</span><br><span class="line">  tel: <span class="string">&#x27;12345&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  password: <span class="string">&#x27;S-12345&#x27;</span>,</span><br><span class="line">  address:&#123;</span><br><span class="line">  	city:<span class="string">&#x27;beijing&#x27;</span>,</span><br><span class="line">  	street:No<span class="number">.1</span> Road,</span><br><span class="line">  	zipcode:<span class="string">&#x27;10000&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把person的name和tel取出给var定义的name,tel</span></span><br><span class="line"><span class="keyword">var</span> &#123;name,tel&#125;=person;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name=&#x27;</span>+name+<span class="string">&#x27;,&#x27;</span>+<span class="string">&#x27;tel=&#x27;</span>+tel);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name=tang</span></span><br><span class="line"><span class="comment">tel=12345</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果要对嵌套对象address里面的值进行赋值，也能用解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">address</span>:&#123;city,street&#125;&#125;=person;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果要使用的变量名和属性名不一致，可以用下面的语法获取：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">password</span>:id&#125;=person;</span><br><span class="line"><span class="comment">//这里就是把password「属性」赋值给了变量id</span></span><br><span class="line"><span class="comment">//注意：是把password这个属性赋值给了id，所以password不是一个变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把<code>&#123;</code>开头的语句做块处理，<code>=</code> 不再合法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line">&#123;x,y&#125;=&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">300</span>&#125;;</span><br><span class="line"><span class="comment">//解决办法，用()括起来</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<h4 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h4>
<p><code>this</code>是一个特殊变量，始终指向当前对象。下面的例子就是<code>this</code>指向的对象是小明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y-<span class="built_in">this</span>.birth; <span class="comment">//当前对象为xiaoming</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但想要把age方法里面的内容拆开写，要怎么办呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写一个getAge()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写小明对象</span></span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  ame:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况一：</span></span><br><span class="line">xiaoming.age();<span class="comment">//正常返回25</span></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line">getAge; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么情况二返回的是<code>NaN</code>？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。</p>
</blockquote>
<p>想要指向正确，<strong>必须用<code>obj.xxx()</code>的形式调用</strong>，也就是「对象.方法名」</p>
<h4 id="that"><a class="markdownIt-Anchor" href="#that"></a> that</h4>
<p>我们先看看下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<p>line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，<code>this</code>指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。</p>
<p><strong>修复方法：使用<code>that</code>变量，在方法内部一开始就首先捕获<code>this</code>：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age();<span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
</blockquote>
<h4 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h4>
<p>可以指定函数的<code>this</code>指向哪个对象，apply(this要指定的对象 , <code>Array</code>函数本身的参数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.getAge();<span class="comment">//25</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br></pre></td></tr></table></figure>
<p><code>apply()</code>把参数打包成Array再传入；<code>call()</code>把参数按顺序传入。二者功能类似。</p>
<p>例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3>
<p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。</p>
<blockquote>
<p>所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;  <span class="comment">//add函数的参数为x,y,f，而参数f是一个函数</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = add(<span class="number">-5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs); </span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p><strong>高阶函数将在下一篇博文详解</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本操作</title>
    <url>/2020/10/29/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。</p>
<p>这篇博文开个Linux栏目吧。</p>
<a id="more"></a>
<h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2>
<ul>
<li>新建文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch test1.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>新建文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir test_dir</span><br></pre></td></tr></table></figure>
<ul>
<li>复制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp 源路径 （空格）目标路径 </span><br></pre></td></tr></table></figure>
<ul>
<li>移动/剪切/重命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 移动&#x2F;剪切</span><br><span class="line">mv test.txt 文件夹路径</span><br><span class="line"></span><br><span class="line"># 移动+重命名</span><br><span class="line">mv test.txt test_dir&#x2F;test2.txt #test_dir为文件夹</span><br></pre></td></tr></table></figure>
<ul>
<li>查看当前所在路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>
<ul>
<li>权限修改</li>
</ul>
<p>这个参数较多，比较复杂，详细的后面再出一篇博文专门讲这一点。这里只讲常用的几点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file  # 所有人可读写</span><br><span class="line">chmod 600 file  # 拥有者可读写</span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm  # 删除文件</span><br><span class="line">rm -f  # 强制删除文件</span><br><span class="line">rm -r  # 删除文件夹</span><br><span class="line">rm -rf  # 强制删除文件夹</span><br><span class="line">注意尽量少用 rm -rf！很危险！</span><br></pre></td></tr></table></figure>
<ul>
<li>读取文档内容</li>
</ul>
<blockquote>
<p>常用语查看Linux的log日志文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat  # 一次全部读取</span><br><span class="line">more  # 逐步读取</span><br><span class="line">tail -f  # 一直读取最新内容</span><br><span class="line">tail -n 行数 文件名  # 从第几行开始读</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm远程连接树莓派同步编辑py文件</title>
    <url>/2020/12/20/PyCharm%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E5%90%8C%E6%AD%A5%E7%BC%96%E8%BE%91py%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201220115218956.png" alt="image-20201220115218956" style="zoom:30%;" />
<p>直接在树莓派上面调试python脚本非常麻烦，作出一次修改就得删除然后上传重新覆盖，效率太低了。其实大部分编译器都会有远程连接服务器编辑代码的功能，PyCharm也不例外。</p>
<p>网上大多数都是在创建project时添加remote，这里我们说更实用的场景：直接在project创建好后，再添加remote。</p>
<a id="more"></a>
<hr />
<p>我们打开project的Preferences（macOS的快捷键是<code>commond</code>+<code>,</code>），然后在左上角的搜索框输入interpreter（解释器），然后如下图，点击Add。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219233324749.png" alt="image-20201219233324749" style="zoom:30%;" />
<br/>
<p>然后左侧栏选择SSH Interpreter，在右方填写好树莓派的ip、用户名，然后点击next。然后填写密码，<strong>记得Save password</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220113238699.png" alt="image-20201220113238699" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201219233510656.png" alt="image-20201219233510656" style="zoom:33%;" />
<br/>
<p>接下来，Interpreter处要选择好树莓派的python版本，默认选择路径是<code>/usr/bin/python</code>，这个路径其实就是我们执行<code>python</code>这个命令时使用的python，此路径默认2.7。2020年了我们当然要使用py3啦，所以我们要提前把<code>/usr/bin/pyhton</code>这个路径的python版本改为python3的。</p>
<p>剩下的我们就按照下图操作，然后点击Finish即可。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220114155921.png" alt="image-20201220114155921" style="zoom:50%;" />
<p>然后我们在项目中新建一个<code>test.py</code>文件，里面输入<code>print('test')</code>测试一下。可以看到，是已经自动上传到树莓派中了。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201220114703381.png" alt="image-20201220114703381" /></p>
<p>然后我们直接在FinalShell的的文件查看器中查看是否有<code>test.py</code>文件</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201220114834281.png" alt="image-20201220114834281" style="zoom:40%;" />
<p>Done！</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的init()到底怎么理解？</title>
    <url>/2020/11/24/Python%E4%B8%AD%E7%9A%84init-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201119103811421.png" alt="image-20201119103811421" style="zoom:50%;" />
<p>在<code>Person</code>类里面有一个<code>__init__(self,name,age)</code>，这里我们分成<code>__init__()</code>和<code>self</code>，和<code>age</code> <code>name</code>三个部分来看。</p>
<a id="more"></a>
<p><code>__init__()</code>是初始化函数。为什么需要初始化呢？简单来说，我们在创建<code>Person</code>这个对象的时候，我们仅仅只是创建了一个<strong>模具</strong>，这个模具什么都没有，没有作为一个person应该有的name和age。这显然是不合理的。</p>
<p>所以我们在实例化对象<code>p=Person()</code>的时候，<code>Person</code>类马上开始初始化，创造出一个拥有<strong>属性</strong>的person。</p>
<p>那么<code>self</code>又是什么东西？</p>
<p><code>self</code>是必须的，缺少了会报错。在很多博客上都有说：“<code>self</code><strong>外部对象在类内部的表示</strong>”。这里我们说人话，注意听“<strong><em>谁调用，就表示谁</em></strong>”。这里我们把<code>Person</code>实例化给了<code>p</code>，所以就是<code>p</code>调用，简单理解就是这个<code>self</code>就是表示<code>p</code>。我们必须得把<code>p</code>传入到类里面，然后才能通过点<code>.</code>的方式去访问类的属性和方法呀。</p>
<hr />
<blockquote>
<p>参考资料</p>
<p>知乎回答： <a href="https://www.zhihu.com/question/46973549/answer/293788116">https://www.zhihu.com/question/46973549/answer/293788116</a></p>
<p>最良心的Python教程：</p>
<p><a href="https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md">https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<a id="more"></a>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>个人理解TCP/IP</title>
    <url>/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/</url>
    <content><![CDATA[<blockquote>
<p>本文学习参考文章：<a href="https://www.odaily.com/post/5133541">https://www.odaily.com/post/5133541</a></p>
</blockquote>
<h2 id="tcpip是什么"><a class="markdownIt-Anchor" href="#tcpip是什么"></a> TCP/IP是什么？</h2>
<p>TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP……</p>
<a id="more"></a>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108121828480.png" alt="image-20201108121828480" style="zoom:50%;" />
<blockquote>
<p>不同的协议层对数据包有不同的称谓，在传输层叫做段 (segment)，在网络层叫做数据报 (datagram)，在链路层叫做帧 (frame)。</p>
</blockquote>
<h2 id="tcpip的分层管理"><a class="markdownIt-Anchor" href="#tcpip的分层管理"></a> TCP/IP的分层管理</h2>
<p>TCP/IP参考模型：网络接口层、网络层、传输层和应用层。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108121428320.png" alt="image-20201108121428320" style="zoom:50%;" />
<p>网络上很多会从下往上理解，但从上往下会更符合普通用户的理解。</p>
<ul>
<li>
<p>应用层：这一层的任务是：将接收到的数据包按照「协议」解读成各种类型的数据，然后把这些数据打包传到下一层：传输层。协议有：HTTP、FTP、SMTP、Telnet、NFS、RIP等。</p>
<p>例如：我要发一封邮件，就要用SMTP协议把数据包解读，传给传输层帮我传输。</p>
</li>
<li>
<p>传输层（TCP层）：这层的任务是：确保分割的单元在另一端正确地到达，它建立端口到端口的连接。用TCP/UDP协议，把应用层传来的数据进行分割成以数据报文段为单位的数据包交给下一层（网络层）。（这是在「网络」中两台机器互相传数据。）</p>
</li>
<li>
<p>网络层（IP层）：这层的任务是把传输层的数据，在众多的路由器中「找到路」，传给下一层。</p>
<p>该层常见的协议有：IP，ICMP，ARP，RARP</p>
</li>
<li>
<p>网络接口层（数据连接+物理层）：负责传输「局域网」的数据。这层使用什么协议取决于所使用的无力网络：如果物理网是LAN，那么通常使用的是以太网协议以及他的变体。</p>
<p>两台主机之间是通过网卡进行发送和接受数据的，**以太网在「子网」内以广播的形式发送数据。**光靠MAC地址并不能让两台主机通信，因为如果两台主机不在同一子网，以太网协议就不能用了。这时需要通过网路层来区分每台主机所在的网络是哪个子网。</p>
</li>
</ul>
<p>上面的整个流程举个例子：我向我朋友发一封邮件，内容为“你好！”，这时候在「应用层」就使用SMTP协议对邮件内容进行打包整理，传给「传输层」，用TCP/UDP协议来切割数据（传输的过程都是在网络中进行的，不是局域网）。可是数据都要传去哪里呢？这件事交给「网络层」（IP），它会选择一条路径把交到离你最近的路由器上，再由光线传到我们家里的广猫中，这个时候就交给「网络接口层的协议」发挥作用了，在局域网中把广猫的数据通过网线或wifi发送到我们的电脑网卡中开始接收。</p>
<h2 id="tcp-udp与其他"><a class="markdownIt-Anchor" href="#tcp-udp与其他"></a> TCP、UDP与其他</h2>
<p>TCP协议：面向连接的、基于字节流的、可靠的传输层通信协议</p>
<ul>
<li>
<p>面向连接：需要经过三次握手后，client与servers端才会开始进行数据的传输（但我握手过程中传送的包不包含任何数据）</p>
</li>
<li>
<p>稳定可靠：能把数据准确可靠地传给对方，简单来说就是，它把数据切成一个个数据包，从第一只数据包开始传，传送成功就翻倍，发现失败就地爬起来，从绊倒的那只数据包重新开始，周而复始。</p>
</li>
<li>
<p>基于字节流服务：把大块数据分割成以报文段为单位的数据包进行管理。</p>
</li>
</ul>
<p>UDP、ARP、RARP概念相对简单，具体可以参考文章：<a href="https://www.odaily.com/post/5133541">一文看懂互联网TCP/UDP协议</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>原创 ｜ Hexo在generate后出现错误“LaTeX-incompatible input and strict mode is set to &#39;warn&#39;: Unicode text character 开 used in math mode [unicodeTextInMathMode]”</title>
    <url>/2020/11/19/%E5%8E%9F%E5%88%9B-%20%7C%20-Hexo%E5%9C%A8generate%E5%90%8E%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E2%80%9CLaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-%E5%BC%80-used-in-math-mode-unicodeTextInMathMode-%E2%80%9D/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201119113956277.png" alt="image-20201119113956277" style="zoom: 33%;" />
<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<blockquote>
<p>完美主义不允许。</p>
</blockquote>
<p>这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。</p>
<a id="more"></a>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119114327053.png" alt="image-20201119114327053" style="zoom:50%;" />
<h1 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h1>
<p>在逐篇blog排查过没有拼写错误后，然后逐渐采取了一个很蠢的方式：逐篇删除文章，查找问题所在的博文（还好这个新站点博文数量还不多）。</p>
<p>在删除了《正则表达式-01》这篇文章，执行<code>sudo hexo s</code>后，报错消失。</p>
<p>打开文章，从头开始逐段删除，终于定位到具体的段落</p>
<p>然后在这个段落中再逐渐删除找报错点。终于定位到了！是$这个符号搞的鬼。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119115329340.png" alt="image-20201119115329340" style="zoom:50%;" />
<p><strong>基于直觉，加了一个转义字符<code>\</code>，报错消失～</strong></p>
<h2 id="出错原因"><a class="markdownIt-Anchor" href="#出错原因"></a> 出错原因</h2>
<p>可以看到下图，是有两个$的，而在Markdown语法中，<strong>两个$符号是数学符号和公式</strong>的使用。要想使用单个$，要加个转义字符<code>\</code>。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201119115616169.png" alt="image-20201119115616169" style="zoom:50%;" />
<h1 id="总结体会"><a class="markdownIt-Anchor" href="#总结体会"></a> 总结体会</h1>
<ul>
<li>遇到问题要及早解决。如果我第一次遇到了这片文章的故障，就想办法解决，相比现在才去用蠢办法解决时间会节省太多了（起码不用特地写一篇blog～）。</li>
<li>要努力做一个完美主义的人。完美主义我觉得是一个程序员/IT从业者必须具备的一个特质。如果没有完美主义，就很难会深究一个问题。遇到问题就想“能用就行，随便啦”，这个程序员的大忌啊。要“尽量”把每一件事情都做得完美，日后才能安安稳稳过日子嘛。</li>
<li>问题要深究。解决了问题之后，还要知道为什么，日后才不会重复犯错误。就像这次加了转义字符解决了问题，还继续深究为什么会这样，才知道了在markdown中$的用法。</li>
</ul>
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>原创 ｜ macOS 使用HTMLTestRunner与unittestreport失败解决过程</title>
    <url>/2020/12/07/%E5%8E%9F%E5%88%9B-%EF%BD%9C-macOS-%E4%BD%BF%E7%94%A8HTMLTestRunner%E4%B8%8Eunittestreport%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20201207170003712.png" alt="image-20201207170003712" /></p>
<h3 id="一-背景"><a class="markdownIt-Anchor" href="#一-背景"></a> 一、背景</h3>
<p>在《Python自动化测试实战》中，使用的是HTMLTestRunner，但教程使用的是windows系统，本人使用的macOS与其有点出入。Baidu和Google的帖子全都是在手动下载py文件，然后手动放到Python的lib文件夹中，但本macOS无效。</p>
<a id="more"></a>
<h3 id="二-解决过程"><a class="markdownIt-Anchor" href="#二-解决过程"></a> 二、解决过程</h3>
<p>然后尝试换个思路，自动化测试报告中肯定不止只有老旧的HTMLTestRunner这个库呀，会不会有功能更加丰富、使用更方便、美观的第三方库呢？果然，有一个<a href="https://pypi.org/project/unittestreport/">unittestreport</a> 让人极为惊喜。</p>
<p>安装过程显示是非常简单的，直接使用pip安装。但我install之后import还是没反应。疑惑。这时，突然想起Pycharm中的Interpreter的配置，是可以直接安装第三方库的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207160205161.png" alt="image-20201207160205161" style="zoom:50%;" />
<p>在Install Package后，就可以成功使用unittestreport了。</p>
<h3 id="三-如何使用"><a class="markdownIt-Anchor" href="#三-如何使用"></a> 三、如何使用</h3>
<p>在<a href="http://testingpai.com/article/1595507317340">此文章</a>中有提示。我自己写了个简单的demo，可直接运行，<a href="https://file.tangspoon.cn/t/qbXL4C">点此下载</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> unittestteport <span class="keyword">import</span> TestRunner,HTMLTestRunner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步：加载测试套件</span></span><br><span class="line">suite1 = unittest.defaultTestLoader.discover(<span class="string">r&quot;xxx\xxx\cases&quot;</span>)</span><br><span class="line"><span class="comment"># 第二步：创建运行对象，传入测试套件</span></span><br><span class="line">runner = HTMLTestRunner(stream=open(<span class="string">&quot;report.html&quot;</span>,<span class="string">&#x27;wb&#x27;</span>), title=<span class="string">&#x27;木森的测试报告&#x27;</span>,)</span><br><span class="line"><span class="comment"># 第三步：执行测试</span></span><br><span class="line">runner.run()</span><br></pre></td></tr></table></figure>
<h3 id="四-advanced"><a class="markdownIt-Anchor" href="#四-advanced"></a> 四、advanced</h3>
<h4 id="1-为什么pip安装不能直接使用而直接在pycharm-interpreter安装就可以使用呢"><a class="markdownIt-Anchor" href="#1-为什么pip安装不能直接使用而直接在pycharm-interpreter安装就可以使用呢"></a> 1. 为什么pip安装不能直接使用，而直接在Pycharm Interpreter安装就可以使用呢？</h4>
<p>打开Pycharm Interpreter的Avaliable Packages界面，仔细查看，会发现其实会有一个钩子选项。从这里可以得到提示，可能与一个叫site packages的文件夹有关。可以从这里入手。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207161245421.png" alt="image-20201207161245421" style="zoom:50%;" />
<p>我们看看Project中的External Libraries都有哪些，打开一看，有了site-packes！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207162437233.png" alt="image-20201207162437233" style="zoom:45%;" />
<p>在里面可以找到我们刚刚导入的unittestreport，还有之前折腾失败的HTMLTestRunner。</p>
<p>pip安装失败，难道是pip安装的路径有问题？那我们查一下通过pip安装的unittestreport是在哪里。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201207163426073.png" alt="image-20201207163426073" /></p>
<p>在上述路径中删除一个库，PyCharm的External Libraries中的site-packages中就少了被删除的库，由此可证明其实<code>pip install unittestreport</code>已经成功了，只是我们还未在项目的解释器（PyCharm的Interpreter）中添加而已。其实这就像和我们使用selenium一样，每次新建一个project，<strong>就需要在解释器中添加相应的包才能使用的。</strong></p>
<h4 id="2-为什么网上手动引入htmltestrunnerpy的方法行不通呢"><a class="markdownIt-Anchor" href="#2-为什么网上手动引入htmltestrunnerpy的方法行不通呢"></a> 2. 为什么网上手动引入HTMLTestRunner.py的方法行不通呢？</h4>
<p>我们研究了上面的问题后，其实可以发现：我们是要在/Users/换成自己的用户名/opt/anaconda3/lib/python3.7/site-packages/中，创建一个HTMLTestRunner文件夹，然后把py文件放进即可。而不是放入什么bin目录或者lib目录。</p>
<p><strong>手动引入其他第三方库类似。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201207165459498.png" alt="image-20201207165459498" style="zoom:50%;" />
<p><strong>或者更简单的，我们可以直接通过PyCharm的解释器在线添加packages。</strong></p>
]]></content>
      <categories>
        <category>troubleshooting</category>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>后盾人MySQL-基本操作</title>
    <url>/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>感谢<a href="https://houdunren.gitee.io/note/mysql/">后盾人</a>的MySQL教程</p>
</blockquote>
<a id="more"></a>
<h2 id="查询数据"><a class="markdownIt-Anchor" href="#查询数据"></a> 查询数据</h2>
<p>用的两张表：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108122852734.png" alt="image-20201108122852734" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201108122922049.png" alt="image-20201108122922049" style="zoom:50%;" />
<h4 id="字段处理"><a class="markdownIt-Anchor" href="#字段处理"></a> 字段处理</h4>
<ul>
<li>查询制定字段，并排序字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select description,cname from class;</span><br></pre></td></tr></table></figure>
<h4 id="条件筛选"><a class="markdownIt-Anchor" href="#条件筛选"></a> 条件筛选</h4>
<ul>
<li>根据条件查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where cname&#x3D;&#39;php&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询包含关键词的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where description like &#39;%p%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>合并「列」返回查询结果</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select concat(id,cname) as &#39;class_info&#39; from class;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123002633.png" alt="image-20201108123002633" style="zoom:50%;" />
<ul>
<li>介绍中不包含php的班级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from class where description not like &#39;%php%&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询学生所在班级编号，并去除重复值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct class_id from stu;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询年龄在20~35岁的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from stu where age between 20 and 35;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找2、3班的所有同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id in(2,3);</span><br></pre></td></tr></table></figure>
<ul>
<li>查找除了1、3班的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id not in(1,3);</span><br></pre></td></tr></table></figure>
<h4 id="null"><a class="markdownIt-Anchor" href="#null"></a> NULL</h4>
<ul>
<li>查询没有非配班级的学生姓名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname from stu where class_id is null;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123032831.png" alt="image-20201108123032831" style="zoom:50%;" />
<ul>
<li>查询结果中对没分配班级的学生显示未分配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sname,ifnull(class_id,&#39;未分配&#39;) from stu;</span><br></pre></td></tr></table></figure>
<h4 id="排序结果"><a class="markdownIt-Anchor" href="#排序结果"></a> 排序结果</h4>
<ul>
<li>按学生年龄从大到小排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by age desc;</span><br></pre></td></tr></table></figure>
<ul>
<li>班级从大到小排序，相同班级的同学年龄从小到大排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by class_id desc,age asc;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是多个条件的罗列。</p>
</blockquote>
<ul>
<li>随机获得一名同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by rand() limit 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后报名的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by id desc limit 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二和第三报名的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu order by id asc limit 1,2;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找2班年龄最小的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select *from stu where class_id&#x3D;2 and age is not null order by age asc limit 1;</span><br><span class="line"># 注意不要忘了order by age中的age</span><br></pre></td></tr></table></figure>
<blockquote>
<p>综上：排序中选择某个特定对象，可以用limit来限制。但一定要先排好序再使用。</p>
</blockquote>
<h2 id="删除记录"><a class="markdownIt-Anchor" href="#删除记录"></a> 删除记录</h2>
<ul>
<li>删除所有年龄小于20的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from stu where age&lt;20;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除所有年龄小在30并没有班级的同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from stu where age&#x3D;30 and class_id is null;</span><br></pre></td></tr></table></figure>
<h2 id="添加记录"><a class="markdownIt-Anchor" href="#添加记录"></a> 添加记录</h2>
<ul>
<li>添加一条记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into stu SET sname&#x3D;&#39;小明&#39;,age&#x3D;22,class_id&#x3D;1;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加多条件记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into stu(sname,class_id,age) values(&#39;小明&#39;,2,32),(&#39;小张&#39;,3,45);</span><br><span class="line"># 注意不要忘了values</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>后盾人MySQL-多表操作</title>
    <url>/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<blockquote>
<p>MySQL 表的操作还是有很多需要理解的地方，在此感谢<a href="https://houdunren.gitee.io/note/mysql/8%20%E5%A4%9A%E8%A1%A8%E6%94%BB%E7%95%A5.html#%E5%A4%9A%E8%A1%A8%E6%94%BB%E7%95%A5">后盾人</a>的文章。</p>
</blockquote>
<a id="more"></a>
<h2 id="join"><a class="markdownIt-Anchor" href="#join"></a> JOIN</h2>
<h4 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> inner join</h4>
<ul>
<li>查询一班的所有同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select s.id,sname,cname from stu s join class c on s.class_id&#x3D;c.id where c.id&#x3D;1; </span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级发表的文章数量，来操作多张表的关联操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 班级：class</span><br><span class="line"># 文章：article</span><br><span class="line"># 但class与article未设置直接连接，还需用stu联合起来（stu作为桥梁：用stu的class_id把class的id联合，然后再用stu的id把article的stu_id联合）</span><br><span class="line">select c.id,count(*) from stu as s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id;</span><br><span class="line"># 1. 计算数量用count(*)；2. 为什么用group by后面的是c.id呢？因为题目要求是「每个班级发表的文章数量」，所以肯定是用class的id来排的。</span><br></pre></td></tr></table></figure>
<ul>
<li>一班的所有女生发表的文章</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一班：class</span><br><span class="line"># 女生：stu</span><br><span class="line"># 文章：article</span><br><span class="line">select c.id,a.title from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">where sex&#x3D;&#39;女&#39;;</span><br></pre></td></tr></table></figure>
<ul>
<li>哪个班级发表的文章超过两篇</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.id,count(*) as total from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id</span><br><span class="line">having total &gt;&#x3D;2;</span><br><span class="line"># 注意total是在count(*)设置的</span><br><span class="line"># having total也就是拥有count（*）这个数&gt;&#x3D;2的</span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级文章的总点击数与平均点击数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select c.id,sum(a.click) as class_sum,avg(a.click) from stu s</span><br><span class="line">join class c</span><br><span class="line">join article a</span><br><span class="line">on s.class_id&#x3D;c.id and s.id&#x3D;a.stu_id</span><br><span class="line">group by c.id</span><br><span class="line">order by class_sum asc;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个班级有多少同学</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 班级：class</span><br><span class="line"># 学生：stu</span><br><span class="line">select c.id,count(*) from stu s join class c on s.class_id&#x3D;c.id group by c.id;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201028233614831.png" alt="image-20201028233614831" style="zoom:50%;" />
<p>上面是两张表连立后的新表，可以看到直接通过cname来统计每个班有多少人（有两个cname就证明有两个人）</p>
<ul>
<li>学生人数大于两个的班级名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as c</span><br><span class="line">ON s.class_id &#x3D; c.id</span><br><span class="line">GROUP BY c.cname</span><br><span class="line">HAVING total&gt;&#x3D;2;</span><br></pre></td></tr></table></figure>
<h4 id="outer-join"><a class="markdownIt-Anchor" href="#outer-join"></a> outer join</h4>
<p>外链接包括<code>left join</code>与<code>right join</code>，可以简单理解为 <code>LEFT JOIN</code>会包含<strong>左侧所有表记录</strong>，<code>RIGHT JOIN</code> 会包含右侧表全部记录。</p>
<p>获取没有设置QQ的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT s.sname FROM stu AS s LEFT JOIN stu_info as i</span><br><span class="line">ON s.id &#x3D; i.stu_id</span><br><span class="line">WHERE i.qq is null;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>吐血原创整理｜怎么把java web项目部署到centos7中？</title>
    <url>/2020/12/12/%E5%90%90%E8%A1%80%E5%8E%9F%E5%88%9B%E6%95%B4%E7%90%86%EF%BD%9C%E6%80%8E%E4%B9%88%E6%8A%8Ajava-web%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0centos7%E4%B8%AD%EF%BC%9F/</url>
    <content><![CDATA[<p>今天打开FinalShell，在vps列表最底下发现了一个叫“pr”的备注，瞬间想起6美元上的一个灵车pacificrack。双击后，震惊，链接居然绿了！连接速度居然还变快了……想不到近一年过去了还没翻车。既然这样，那就用来干点“正事”吧，把失败了的宠物论坛重新搭建起来，折腾一下。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_16-53-56.jpg" alt="Xnip2020-12-11_16-53-56" style="zoom:50%;" />
<a id="more"></a>
<p>在linux环境上部署javaweb项目比想象中的要简单太多，<strong>只需要java环境、mysql、tomcat三样</strong>。</p>
<p>我们先查看一下VPS是否自带有以上环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep java</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line">rpm -qa|grep tomcat</span><br></pre></td></tr></table></figure>
<p>还好，都没有（不然我还得卸载）。所以，第一步是装好java环境。</p>
<h2 id="一-安装java环境"><a class="markdownIt-Anchor" href="#一-安装java环境"></a> 一、安装java环境</h2>
<h3 id="1-使用wget高效率下载jdk8安装java环境"><a class="markdownIt-Anchor" href="#1-使用wget高效率下载jdk8安装java环境"></a> 1. 使用wget高效率下载jdk8，安装java环境</h3>
<p>进入<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">jdk8</a>下载页面，点击下载链接。（注意到链接左上角是有一把锁🔒的，<strong>证明点击后还有验证项目</strong>，所以不是直接wget这条url。）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211183815811.png" alt="image-20201211183815811" style="zoom:50%;" />
<p>点入链接，打勾后，直接在Download下右键（不是左键！），复制下载链接，这条链接才是可以直接在VPS下wget的。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211184247551.png" alt="image-20201211184247551" style="zoom:50%;" />
<p>然后我们连上VPS，输入wget，然后粘贴上面的下载链接。有了VPS后，我们要利用好VPS优秀的远程网络，不要再傻傻的下载到本地电脑，然后再手动上传到VPS中，简直多此一举。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_17-03-50.jpg" alt="Xnip2020-12-11_17-03-50" style="zoom:50%;" />
<blockquote>
<p>注意，我为什么不直接把下载链接分享出来呢？因为每条下载链接的有效性只能保持一段时间，过后就会失效。具体多久没有探究。oracle公司考虑得真的非常完美，感觉这样其中一个好处就是：可以大幅提高官网的访问率和官方方式下载率，不用一条链接用万年。</p>
</blockquote>
<h3 id="2-解压包"><a class="markdownIt-Anchor" href="#2-解压包"></a> 2. 解压包</h3>
<p>然后我们再/usr/local目录下创建一个名叫java的目录，把刚下载的jdk tar.gz包解压到这里，详细命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新建java目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line"># 解压jdk包到java目录</span><br><span class="line">tar -zxvf 包名 -C &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line"># 查看解压包名</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;java</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211190147742.png" alt="image-20201211190147742" style="zoom: 50%;" />
<p><strong>注意！<code>ls</code>后就像上图一样，java文件夹内只能有一个jdk的包，不要放置其他内容</strong></p>
<h3 id="3-配置环境变量"><a class="markdownIt-Anchor" href="#3-配置环境变量"></a> 3. 配置环境变量</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<p>然后如图添加以下内容，然后保存，退出。（注意红框的内容自行更换为自己下载的包名，也就是上面<code>ls</code>查看出来的）</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-11_17-36-34.jpg" alt="Xnip2020-12-11_17-36-34" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># java</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_271</span><br><span class="line">export CLASSPATH&#x3D;$CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F;</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>
<p>然后更新文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h3 id="4-验证"><a class="markdownIt-Anchor" href="#4-验证"></a> 4. 验证</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211191148413.png" alt="image-20201211191148413" style="zoom:50%;" />
<p>出现上图，java环境安装成功！</p>
<p>如果出现了什么幺蛾子的话，就看error提示吧。linux问题很多，很难一一说明。死活有问题的话，就重装系统，换个系统吧，这是最最最没办法中的办法。</p>
<hr />
<h2 id="二-安装mysql-57"><a class="markdownIt-Anchor" href="#二-安装mysql-57"></a> 二、安装MySQL 5.7</h2>
<h3 id="1-检查是否有冲突的mariadb-lib然后卸载"><a class="markdownIt-Anchor" href="#1-检查是否有冲突的mariadb-lib然后卸载"></a> 1. 检查是否有冲突的mariadb-lib，然后卸载</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211195150651.png" alt="image-20201211195150651" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看是否存在mariadb</span><br><span class="line">rpm -qa|grep mariadb</span><br><span class="line"># 卸载</span><br><span class="line">rpm -e --nodes mariadb-libs-5.5.64-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<h3 id="2-下载mysql安装包"><a class="markdownIt-Anchor" href="#2-下载mysql安装包"></a> 2. 下载MySQL安装包</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载rpm</span><br><span class="line">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line"># 安装</span><br><span class="line">yum localinstall mysql57-community-release-el7-11.noarch.rpm</span><br></pre></td></tr></table></figure>
<h3 id="3-安装"><a class="markdownIt-Anchor" href="#3-安装"></a> 3. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-community-server</span><br></pre></td></tr></table></figure>
<p>安装完毕后，启动mysql服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p>查看mysql服务是否启动成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef|grep mysql</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211203901096.png" alt="image-20201211203901096" style="zoom:50%;" />
<h3 id="4-修改密码"><a class="markdownIt-Anchor" href="#4-修改密码"></a> 4. 修改密码</h3>
<p>查询MySQL的临时密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201211205414107.png" alt="image-20201211205414107" style="zoom:50%;" />
<p>复制临时密码，使用临时登录MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<p>修改密码，然后刷新权限</p>
<blockquote>
<p>把下面的xxx修改成自己的密码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;xxxx&#39;;</span><br><span class="line"># 刷新权限！一定要！</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>最后尝试使用新修改的密码重新登陆。</p>
<hr />
<h2 id="三-安装tomcat-8"><a class="markdownIt-Anchor" href="#三-安装tomcat-8"></a> 三、安装tomcat 8</h2>
<h3 id="1-使用wegt下载targz包"><a class="markdownIt-Anchor" href="#1-使用wegt下载targz包"></a> 1. 使用wegt下载tar.gz包</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212093710258.png" alt="image-20201212093710258" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201212093839753.png" alt="image-20201212093839753" style="zoom:50%;" />
<h3 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建tomcat文件夹</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line"># 解压</span><br><span class="line">tar -zvxf xxx(你的tomcat包名) -C &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line"># 重命名</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat</span><br><span class="line">mv  xxx(你的tomcat包名) tomcat8</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212094351216.png" alt="image-20201212094351216" style="zoom:50%;" />
<h3 id="3-防火墙开放端口"><a class="markdownIt-Anchor" href="#3-防火墙开放端口"></a> 3. 防火墙开放端口</h3>
<p>查看防火墙开放情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212094507455.png" alt="image-20201212094507455" style="zoom:50%;" />
<p>如果显示<code>-bash: firewall-cmd: 未找到命令</code>,证明没有防火墙。下方是防火墙的相关操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装防火墙</span><br><span class="line">yum install firewalld</span><br><span class="line"># 开启防火墙</span><br><span class="line">systemtcl start firewalld</span><br><span class="line"># 开放8080与3306端口，然后重启防火墙</span><br><span class="line">firewalld-cmd --add-port&#x3D;8080&#x2F;tcp --permanent</span><br><span class="line">firewalld-cmd --add-port&#x3D;3306&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 重新查看开放端口列表</span><br><span class="line">firewalld-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p>如图显示，则端口开启成功</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212095454503.png" alt="image-20201212095454503" style="zoom:50%;" />
<h3 id="4-开启tomcat尝试外部访问"><a class="markdownIt-Anchor" href="#4-开启tomcat尝试外部访问"></a> 4. 开启tomcat，尝试外部访问</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 有关tomcat的脚本都在bin目录下，bat后缀为windows用户的脚本</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;tomcat8&#x2F;bin &amp;&amp; ls</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212095835339.png" alt="image-20201212095835339" style="zoom:50%;" />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 运行tomcat</span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure>
<p>尝试外部访问：在浏览器中输入VPS的ip:8080。如图，tomcat部署成功！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212100051835.png" alt="image-20201212100051835" style="zoom:50%;" />
<h3 id="5-配置开机启动"><a class="markdownIt-Anchor" href="#5-配置开机启动"></a> 5. 配置开机启动</h3>
<p>创建tomcat8系统服务文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tomcat8.service</span><br></pre></td></tr></table></figure>
<p>然后在文件中粘贴如下内容，保存后退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Tomcat8</span><br><span class="line">After&#x3D;syslog.target network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line"></span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.sh</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;shutdown.sh</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>最后启用tomcat8系统配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable tomcat8</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212100604097.png" alt="image-20201212100604097" style="zoom:50%;" />
<hr />
<h2 id="四-导入javaweb项目的sql文件到vps的数据库中"><a class="markdownIt-Anchor" href="#四-导入javaweb项目的sql文件到vps的数据库中"></a> 四、导入javaweb项目的sql文件到VPS的数据库中</h2>
<p><strong>注意：以下命令一行一行逐渐执行，不是直接复制粘贴</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装上传下载工具</span><br><span class="line">cd ~ &amp;&amp; yum install lrzsz</span><br><span class="line"># 上传</span><br><span class="line">rz</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入mysql</span><br><span class="line">mysql -uroot -p</span><br><span class="line"># 查看数据库</span><br><span class="line">show databases;</span><br><span class="line"># 新建数据库</span><br><span class="line">creat database xxx(你的数据库名) default charater set utf8 collate utf8_general_ci;</span><br><span class="line"># 使用数据库</span><br><span class="line">use xxx(你的数据库名)</span><br><span class="line"># 导入你的sql文件，路径为你sql文件的路径</span><br><span class="line">source &#x2F;xxx&#x2F;xxx&#x2F;xxx.sql;</span><br><span class="line"># 查看sql文件的table，是否导入成功</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212103535073.png" alt="image-20201212103535073" style="zoom:50%;" />
<p>导入sql成功！现在VPS数据库中已经有我们的数据表了！</p>
<hr />
<h2 id="五-上传war包到vps中"><a class="markdownIt-Anchor" href="#五-上传war包到vps中"></a> 五、上传war包到VPS中</h2>
<p>先在IDEA打包好war包，打包方法参考：<a href="https://blog.csdn.net/qq_1290259791/article/details/78619353">intellij idea打包war包</a>。</p>
<p>我们使用<code>rz</code>命令把war包上传到tomcat8里的wabapps文件夹下。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212104332240.png" alt="image-20201212104332240" style="zoom:50%;" />
<p>稍等一下，我们再查看一下webapps有什么变化。可以看到上传pet.war后还多了一个pet文件，原因是tomcat帮我们把war项目自动解析了。这个pet就是我们运行中的pet项目。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212104528197.png" alt="image-20201212104528197" style="zoom:50%;" />
<p>此时我们访问尝试访问 <strong>ip:8080/项目路径</strong>，如无意外，项目访问成功。但我部署项目中就很少没有意外的，这次我就404了……</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212145923339.png" alt="image-20201212145923339" style="zoom:50%;" />
<hr />
<h2 id="六-故障解决"><a class="markdownIt-Anchor" href="#六-故障解决"></a> 六、故障解决</h2>
<h3 id="1-访问出现404"><a class="markdownIt-Anchor" href="#1-访问出现404"></a> 1. 访问出现404</h3>
<p>javaweb部署导致404出现的原因有挺多种的，当然我们可以选择Google、Baidu，但其实最快、最稳妥的办法就是<strong>查看tomcat的日志</strong>。访问不了tomcat会给出针对性的报错原因的。</p>
<p>tomcat的日志在/xxx(tomcat安装目录)/logs/catalina.out</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212150457465.png" alt="image-20201212150457465" style="zoom:50%;" />
<p>查看日志最后100行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -n 100 catalina.out</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-12_14-56-28.jpg" alt="Xnip2020-12-12_14-56-28" style="zoom:50%;" />
<p>一眼就看出是MySQL的问题！导致这个原因一般只有两个：首先是jdbc文件mysql配置信息错误，不然就是数据库版本不对。</p>
<p>打开idea，查看项目的jdbc配置文件，果然这里的password忘记更改成VPS数据库的密码了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212151256298.png" alt="image-20201212151256298" style="zoom:50%;" />
<p>重新编译，打包war包。</p>
<p>删除VPS中tomcat/webapps中的项目war包 和 自动解析生成的项目文件夹</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212151758556.png" alt="image-20201212151758556" style="zoom:50%;" />
<p>然后重新上传新打包的war包，然后等待大概两分钟（tomcat要重新部署新的war包），过后我们再尝试尝试访问 ip:8080/项目文件。</p>
<p>然后然后……总是如此曲折</p>
<h3 id="2-样式不见了"><a class="markdownIt-Anchor" href="#2-样式不见了"></a> 2. 样式不见了……</h3>
<p>真是天秀～，查看log也没有报错。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201212152345134.png" alt="image-20201212152345134" style="zoom:40%;" />
<p>那就F12，看看Console，所有的何css、js资源都无法获取，</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-12_15-58-19.jpg" alt="Xnip2020-12-12_15-58-19" style="zoom:50%;" />
<p>网络搜索了一下，在这里<a href="https://www.geek-share.com/detail/2744094259.html">这篇文章</a>里获取到了一点点思路，是获取的路径有问题。那么我们在本地idea上编译然后F12，对比看看</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-13_15-01-19.jpg" alt="Xnip2020-12-13_15-01-19" style="zoom: 40%;" />
<p>从上图我们可以看到，我们的资源多了一个项目名称的目录，index自然获取不到在外部的resources里的css、js文件。可是当时为这个问题已经折腾了一整天了，完完整整的一天，思路已经被局限，没有想到在webapps下的ROOT目录。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213150725829.png" alt="image-20201213150725829" style="zoom:50%;" />
<p>在晚上9点折腾无果后，决定加Roothub项目作者交流一下，看看能否获得提示。第二天交流后有一句话给了我提示：“可以设置根路径访问的。”一句惊醒梦中人～</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-12-13_14-30-10.jpg" alt="Xnip2020-12-13_14-30-10" style="zoom:50%;" />
<p>想到我们直接输入ip访问的Apache Tomcat的首页是部署在ROOT目录下的，这个就是tomcat的根目录呀。那我直接把ROOT下的文件替换成我的<strong>项目下的所有文件</strong>能不能直接访问呢？</p>
<p>但不知道为何，使用命令行无法操作ROOT这个目录，想要cp备份不行，cd进入也不行，rm也不行。只好使用FinalShell的图形界面操作了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213153848470.png" alt="image-20201213153848470" style="zoom:50%;" />
<p>在替换操作之后，VPS监控到CPU占用率马上提高，可能是tomcat已经在部署项目了。等CPU占比下来后，访问 ip:8080，成功访问。</p>
<p>其实这种做法是一种折中的解决办法吧，那假如我还有其他要部署的项目呢？还是直接覆盖ROOT目录？这样就在一台VPS下只能存在一个javaweb项目了。这显然是不合理的。</p>
<p>综合搜索资料后分析，出现这种情况大概是原项目作者在开发时使用的是绝对路径。但具体怎么回事目前还未有足够时间去深究，以后有机会再研究。</p>
<hr />
<h2 id="七-域名访问项目"><a class="markdownIt-Anchor" href="#七-域名访问项目"></a> 七、域名访问项目</h2>
<p>这里重点讲述tomcat的配置，域名解析什么的就略过吧。相关配置在tomcat/conf/server.xml。</p>
<h3 id="1-修改成80端口访问"><a class="markdownIt-Anchor" href="#1-修改成80端口访问"></a> 1. 修改成80端口访问</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213161121091.png" alt="image-20201213161121091" style="zoom:50%;" />
<h3 id="3-改域名"><a class="markdownIt-Anchor" href="#3-改域名"></a> 3. 改域名</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi server.xml</span><br></pre></td></tr></table></figure>
<p>需要修改两个地方：进入vi后，键入<code>esc</code>，直接键入<code>/</code> ，然后输入Engine，回车。把localhost修改成自己的域名。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201213162200088.png" alt="image-20201213162200088" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201213162403247.png" alt="image-20201213162403247" style="zoom:50%;" />
<p>最后重启tomcat即可！</p>
<blockquote>
<p>MySQL参考：<a href="https://www.jianshu.com/p/1dab9a4d0d5f">https://www.jianshu.com/p/1dab9a4d0d5f</a></p>
<p>tomcat部署参考：<a href="https://ken.io/note/centos7-tomcat-setup">https://ken.io/note/centos7-tomcat-setup</a></p>
<p>部署到根目录参考：<a href="https://www.cnblogs.com/xdot/p/8418655.html">https://www.cnblogs.com/xdot/p/8418655.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>linux</category>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>troubleshooting</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（一）｜macOS入门使用树莓派3B+</title>
    <url>/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>最近，苹果手机坏了，暂时用回一加6古董机。iOS的捷径可以实现每日闹钟停止后可以自动播放网易云音乐的每日推荐歌曲，这个功能真的太喜欢了。但是会有10%的几率播放失败，而且安卓系统并没有类似功能。可能你会想到目前的智能音箱调闹钟不就可以了吗？首先，智能音箱对网络依赖极强，网络故障啥都干不了。其次，智能音箱并没有对接到网易云的每日推荐歌单，闹钟播放的歌曲都是随机的。</p>
<p>因此，作为一个geek，还是自己亲手打造一个可以播放网易云每日推荐歌曲的闹钟吧！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219132040671.png" alt="image-20201219132040671" style="zoom:50%;" />
<a id="more"></a>
<hr />
<h2 id="一-烧录镜像"><a class="markdownIt-Anchor" href="#一-烧录镜像"></a> 一、烧录镜像</h2>
<h3 id="1-格式化内存卡"><a class="markdownIt-Anchor" href="#1-格式化内存卡"></a> 1. 格式化内存卡</h3>
<p>macOS使用SD Memory Card Formatter格式化内存卡，<a href="https://www.sdcard.org/downloads/formatter/eula_mac/index.html">点击此处</a>进入官网下载。（拉到最下面点击accept）</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201219113330224.png" alt="image-20201219113330224" /></p>
<p>打开SD Card Formatter，按照下图操作。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219105251370.png" alt="image-20201219105251370" style="zoom:50%;" />
<p>如下，证明格式化成功</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219105330442.png" alt="image-20201219105330442" style="zoom:50%;" />
<h3 id="2-下载树莓派镜像文件"><a class="markdownIt-Anchor" href="#2-下载树莓派镜像文件"></a> 2. 下载树莓派镜像文件</h3>
<p><a href="https://www.raspberrypi.org/software/operating-systems/">点击此处</a>进入下载页面，我这里下载Lite版的，下载完后<strong>不用解压</strong>。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219110531165.png" alt="image-20201219110531165" style="zoom:25%;" />
<h3 id="3-下载烧录工具"><a class="markdownIt-Anchor" href="#3-下载烧录工具"></a> 3. 下载烧录工具</h3>
<p>macOS可以使用 Etcher烧录树莓派，戳这里进入官网：<a href="https://etcher.io/">https://etcher.io</a></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219110853874.png" alt="image-20201219110853874" style="zoom: 33%;" />
<p>选择你刚才下载的镜像（zip 格式），然后选择你的储存卡，点 Flash！即可烧录系统。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219111417310.png" alt="image-20201219111417310" style="zoom:33%;" />
<p>耐心等待一段时间，大概需要5分钟就可烧录成功。</p>
<p><strong>注意：烧录后TF卡名字会变为：<code>boot</code>。</strong></p>
<h3 id="4-编写ssh连接与wifi配置文件"><a class="markdownIt-Anchor" href="#4-编写ssh连接与wifi配置文件"></a> 4. 编写ssh连接与wifi配置文件</h3>
<p>新建两个<code>txt</code>文件，分别命名为：<code>ssh</code>、<code>wpa_supplicant.conf</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219112541652.png" alt="image-20201219112541652" style="zoom:50%;" />
<ul>
<li>
<p><code>ssh</code>文件是没有后缀的</p>
</li>
<li>
<p><code>wpa_supplicant.conf</code>写入下面信息：</p>
<blockquote>
<ol>
<li>SSID名字中不能有符号<code>.</code></li>
<li>优先级范围为1-10</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country&#x3D;CN</span><br><span class="line">ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant Group&#x3D;netdev</span><br><span class="line">update_config&#x3D;1</span><br><span class="line"></span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;Wifi1的名字&quot;</span><br><span class="line">	psk&#x3D;&quot;密码&quot;</span><br><span class="line">	priority&#x3D;优先级，越大越优先</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;Wifi2的名字&quot;</span><br><span class="line">	psk&#x3D;&quot;密码&quot;</span><br><span class="line">	priority&#x3D;优先级</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>然后将这两个文件移动至烧录系统镜像后TF卡的根目录。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219113232972.png" alt="image-20201219113232972" style="zoom:50%;" />
</li>
</ul>
<blockquote>
<p><strong>在Finder中推出TF卡！！！</strong> 要养成好习惯！不然容易烧卡！</p>
<p><strong>在Finder中推出TF卡！！！</strong> 要养成好习惯！不然容易烧卡！</p>
</blockquote>
<hr />
<h2 id="二-准备开机"><a class="markdownIt-Anchor" href="#二-准备开机"></a> 二、准备开机</h2>
<blockquote>
<p>树莓派3B+的电源要求是5V 2.5A的，最好不要太低，否则会损坏机器。（近300块啊）</p>
</blockquote>
<h3 id="1-ssh连接"><a class="markdownIt-Anchor" href="#1-ssh连接"></a> 1. ssh连接</h3>
<p>进入到我们的路由器中，然后查看树莓派的IP地址。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219115812140.png" alt="image-20201219115812140" style="zoom:50%;" />
<p>ssh工具推荐使用FinalShell，按下图填写</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219120353131.png" alt="image-20201219120353131" style="zoom: 33%;" />
<p>连接成功。可以看到会提示让我们修改ssh密码，但是因为我日常忘记各种密码，我就直接用默认的吧。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219123856310.png" alt="image-20201219123856310" style="zoom:33%;" />
<h2 id="三-系统设置"><a class="markdownIt-Anchor" href="#三-系统设置"></a> 三、系统设置</h2>
<h3 id="1-软件源更改"><a class="markdownIt-Anchor" href="#1-软件源更改"></a> 1. 软件源更改</h3>
<p>一定要更改源，不然下载程序会非常慢。这里改成清华源。</p>
<p>（1）先安装vim（你可以使用nano或者vi，我个人喜欢vim）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>（2）修改<code>source.list</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<p>先把里面的<strong>所有内容都注释掉</strong>，然后增加下面两行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib</span><br></pre></td></tr></table></figure>
<p>（3）再修改<code>raspi.list</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list</span><br></pre></td></tr></table></figure>
<p>同样，先把里面的<strong>所有内容都注释掉</strong>，然后增加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure>
<p>（4）最后，进行更新</p>
<blockquote>
<p><strong>第二条命令执行时间会比较长。</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h3 id="2-更改时区"><a class="markdownIt-Anchor" href="#2-更改时区"></a> 2. 更改时区</h3>
<p>查看时区是否为你的当地时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>
<p>如果不是，执行命令更改成Asia-Shanghai</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure tzdata</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219134431642.png" alt="image-20201219134431642" style="zoom:50%;" />
<p>基本设置done！</p>
<hr />
<h2 id="四-关闭派不能直接拔出电源"><a class="markdownIt-Anchor" href="#四-关闭派不能直接拔出电源"></a> 四、关闭派不能直接拔出电源！！</h2>
<p>注意⚠️：</p>
<p><strong>关闭树莓派不能直接拔出电源！！！</strong></p>
<p>正确关闭树莓派方法是：先执行<code>sudo halt</code>，然后等待只有电源指示灯亮的时候（或者等待20s），再拔电源。</p>
<hr />
<p>下一篇我们利用Node.js版本的网易云api<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/">NeteaseCloudMusicApi</a>，写一个py脚本，实现定时播放网易云音乐每日推荐歌曲。</p>
<p>参考资料：</p>
<p><a href="https://stepneverstop.github.io/burn-system2raspberry-in-macos.html">https://stepneverstop.github.io/burn-system2raspberry-in-macos.html</a></p>
<p><a href="https://sspai.com/post/37356">https://sspai.com/post/37356</a></p>
<p><a href="https://www.icxbk.com/article/detail/1077.html">https://www.icxbk.com/article/detail/1077.html</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（三）| 使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲</title>
    <url>/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89%7C%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201222151927493.png" alt="image-20201222151927493" style="zoom:50%;" />
<a id="more"></a>
<hr />
<h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2>
<ol>
<li>
<p>使用前请仔细查看里面的<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%b0%83%e7%94%a8%e5%89%8d%e9%a1%bb%e7%9f%a5">调用前须知</a></p>
</li>
<li>
<p>进行简单的需求分析：</p>
</li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222153644738.png" alt="image-20201222153644738" style="zoom:45%;" />
<br/>
<h2 id="一-搭建api"><a class="markdownIt-Anchor" href="#一-搭建api"></a> 一、搭建API</h2>
<p>我个人选择了把接口搭建在<strong>VPS</strong>中，7x24x365在线，等调试好语音识别模块后再部署到树莓派上。但如果你的是是国外的服务器，请仔细阅读一下文档内的「<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%b0%83%e7%94%a8%e5%89%8d%e9%a1%bb%e7%9f%a5">调用前须知</a>」，里面有提示相关的注意事项。当然，如果仅仅学习API的调用的话，我们可以搭建在本机电脑中。</p>
<blockquote>
<p>注意⚠️：<strong>以下所有步骤均默认在管理员（root）用户下进行</strong></p>
</blockquote>
<br/>
<h3 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Binaryify&#x2F;NeteaseCloudMusicApi.git</span><br><span class="line"># 进入到项目文件内</span><br><span class="line">cd xxx&#x2F;xxx&#x2F;NeteaseCloudMusicApi  </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-运行"><a class="markdownIt-Anchor" href="#2-运行"></a> 2. 运行</h3>
<h4 id="1在vps运行"><a class="markdownIt-Anchor" href="#1在vps运行"></a> （1）在「VPS」运行</h4>
<p>要想API 7x24x365 在线，让项目保持后台运行就可以。我这里运用了比较简单的方法：<code>screen</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd NeteaseCloudMusicApi</span><br><span class="line"># 新建一个名为NeteaseCloud的screen</span><br><span class="line">screen -S NeteaseCloud</span><br><span class="line"># 在新生成的窗口中运行API</span><br><span class="line">node app.js</span><br><span class="line"># 然后就可以放心把窗口关掉了</span><br></pre></td></tr></table></figure>
<br/>
<p><strong>在开放<code>3000</code>端口后</strong>，我们尝试访问<code>http://VPS的ip:3000</code>。如无意外，我们会看到：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222160756839.png" alt="image-20201222160756839" style="zoom:33%;" />
<p><br/>那么我们如何恢复<code>screen</code>呢？</p>
<blockquote>
<p>注意⚠️：恢复<code>screen</code>一定要在新建<code>screen</code>的用户下进行。我上面是进入到了<code>root</code>中</p>
</blockquote>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line"># 查看所有screen</span><br><span class="line">screen -ls </span><br><span class="line"># 找到我们的NeteaseCloud</span><br><span class="line">screen -r screen的id</span><br></pre></td></tr></table></figure>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222161602742.png" alt="image-20201222161602742" style="zoom: 50%;" />
<p>想要关闭<code>screen</code>，我们可以看到上图有提示：<code>1 Socket in /var/run/screen/S-root</code>，我们进入到这个文件夹删除相应的文件，就可以关闭<code>screen</code>了。</p>
<br/>
<h4 id="2在本地电脑运行"><a class="markdownIt-Anchor" href="#2在本地电脑运行"></a> （2）在「本地电脑」运行</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 想要运行项目，仍然要进入项目文件夹中</span><br><span class="line">cd NeteaseCloudMusicApi</span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<br/>
<h4 id="3修改端口运行"><a class="markdownIt-Anchor" href="#3修改端口运行"></a> （3）「修改端口」运行</h4>
<p>服务器启动默认端口为 3000，若想使用其他端口，请先将你的端口放行，然后使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mac&#x2F;Linux</span><br><span class="line">PORT&#x3D;4000 node app.js</span><br><span class="line"># windows</span><br><span class="line">set PORT&#x3D;4000 &amp;&amp; node app.js</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="二-登陆"><a class="markdownIt-Anchor" href="#二-登陆"></a> 二、登陆</h2>
<blockquote>
<p>文档里面提供了手机、邮箱两种登陆方式，但<strong>使用邮箱登陆会返回<code>402</code>错误码</strong>，我们直接使用手机登陆。</p>
</blockquote>
<p>接口地址 : <code>/login/cellphone</code></p>
<p>调用例子 : <code>/login/cellphone?phone=xxx&amp;password=yyy</code></p>
<p>要注意：下面的大部分接口都要登陆成功后才能使用，而登陆接口<code>response</code>信息中会有带有<code>cookie</code>，所以我们要使用<code>session()</code>来保持登陆状态。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="line">phone = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">pwd = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    login_url = url + <span class="string">&#x27;/login/cellphone&#x27;</span></span><br><span class="line">    login = s.get(login_url, data=&#123;<span class="string">&#x27;phone&#x27;</span>: phone, </span><br><span class="line">                                   <span class="string">&#x27;password&#x27;</span>: pwd&#125;)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> login.status_code <span class="keyword">is</span> <span class="number">200</span>:</span><br><span class="line">            print(<span class="string">&#x27;恭喜！登陆成功！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;Exception&#x27;</span>,e)</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="三-获取所有每日推荐歌曲信息"><a class="markdownIt-Anchor" href="#三-获取所有每日推荐歌曲信息"></a> 三、获取所有每日推荐歌曲信息</h2>
<p><strong>使用该接口需要完成「登陆」后才能使用。</strong></p>
<p>接口地址 : <code>/recommend/songs</code></p>
<p>调用例子 : <code>/recommend/songs</code></p>
<p>我们尝试使用<code>postman</code>请求接口，<code>response</code>信息如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222180112139.png" alt="image-20201222180112139" style="zoom: 33%;" />
<br/>
<p>仔细看会发现会发现，<code>response</code>中是没有歌曲播放<code>url</code>的！那怎么播放歌曲呢？</p>
<p>别急，我们仔细思考一下，唯一能识别出一首歌的标志只有<code>id</code>，那会不会有其他接口可以通过<code>id</code>获得可流媒体播放的<code>url</code>呢？</p>
<p>翻遍了文档终于找到<a href="https://binaryify.github.io/NeteaseCloudMusicApi/#/?id=%e8%8e%b7%e5%8f%96%e9%9f%b3%e4%b9%90-url">相关信息</a>。（我觉得作者应该把该接口放在更前面的位置）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201222180707359.png" alt="image-20201222180707359" style="zoom: 33%;" />
<br/>
<p>我们使用postman请求，观察<code>response</code>数据结构。然后开始编码通过<code>id</code>获取播放<code>url</code>，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取每日推荐歌曲id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSongs_id</span>():</span></span><br><span class="line">    <span class="comment"># 获取每日推荐歌曲字典</span></span><br><span class="line">    dailySongs_url = url + <span class="string">&#x27;/recommend/songs&#x27;</span></span><br><span class="line">    dailySongs_object = s.get(dailySongs_url)</span><br><span class="line">    songs_dict = dailySongs_object.json()  </span><br><span class="line">    <span class="comment"># 0~31首</span></span><br><span class="line">    <span class="keyword">for</span> list_index <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        song_id.append(songs_dict[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;dailySongs&#x27;</span>][list_index][<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> song_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取播放url</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSongs_url</span>():</span></span><br><span class="line">    getSongs_url = url + <span class="string">&#x27;/song/url&#x27;</span></span><br><span class="line">    <span class="comment"># 传入song_id[]作为data</span></span><br><span class="line">    song_id = getSongs_id()</span><br><span class="line">    song_url_object = s.post(getSongs_url, data=&#123;<span class="string">&#x27;id&#x27;</span>:song_id&#125;)</span><br><span class="line">    song_url_dict = song_url_object.json()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">        songs_url.append(song_url_dict[<span class="string">&#x27;data&#x27;</span>][i][<span class="string">&#x27;url&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> songs_url</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="四-播放音乐"><a class="markdownIt-Anchor" href="#四-播放音乐"></a> 四、播放音乐</h2>
<p>参考了网络资料，在Linux中播放音乐有几种选择，用得比较多的是<code>pygame</code>和<code>mplayer</code>。但不知什么原因我树莓派一直装不了<code>pygame</code>，所以最终选择了<code>mplayer</code>作为我的播放器。</p>
<h3 id="1-安装mplayer"><a class="markdownIt-Anchor" href="#1-安装mplayer"></a> 1. 安装mplayer</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mplayer</span><br></pre></td></tr></table></figure>
<h3 id="2-调整树莓派声音输出"><a class="markdownIt-Anchor" href="#2-调整树莓派声音输出"></a> 2. 调整树莓派声音输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入系统设置</span><br><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p>依次进入：<code>System Options</code> - <code>Audio</code> - <code>Headphones</code>，最后一定要选择<code>&lt;Finish&gt;</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201219181840492.png" alt="image-20201219181840492" style="zoom:50%;" />
<h3 id="3-重启"><a class="markdownIt-Anchor" href="#3-重启"></a> 3. 重启！！！</h3>
<p>设置完声卡之后，一定要重启系统！不然不会生效。在这里卡了挺久的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="4-基本使用方式"><a class="markdownIt-Anchor" href="#4-基本使用方式"></a> 4. 基本使用方式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mplayer file&#x2F;url</span><br></pre></td></tr></table></figure>
<p>但要如何在python脚本中调用<code>mplayer</code>呢？使用<code>os.system('cmd' %s)</code>或<code>Subprocess.Popen('cmd')</code>，具体区别可以参考<a href="https://blog.csdn.net/taohuaxinmu123/article/details/48828255">这篇文章</a>，一句话说完就是：前者比较老旧，但会显示<code>cmd</code>命令执行的信息；后者强大，支持多种参数和模式，但没有输出信息。</p>
<p>在整个项目中我们两个模块都会用到，在播放音乐部分我们使用前者，后面「渐入渐出部分」我们再使用后者。</p>
<br/>
<p>先尝试播放日推第一首歌。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从左到右解析一下代码：单引号<code>''</code>里的内容就是<code>os.system('cmd')</code>中的<code>cmd</code>，<code>&quot;%s&quot;</code>是<code>str</code>类型的参数，输出<code>&gt;</code>（重定向）到<code>/dev/null 2&gt;&amp;1</code>文件，该文件会像黑洞一样吞噬所有的输入，同时也不会获得任何输出，单引号<code>''</code>部分的代码意思是mplayer播放%s的url，且不输出信息。更详细的意思请看<a href="https://blog.csdn.net/ithomer/article/details/9288353">这里</a>。后面的<code>%</code> 和 <code>song_url[0]</code>中间是有个空格的，这个就是传到<code>&quot;%s&quot;</code>的参数。</p>
</blockquote>
<br/>
<p>要播放32首歌曲，可以写个<code>for</code>循环，重复执行mplayer的播放操作即可。</p>
<p>这部分代码整合到了下方的「优化播放流程」当中。</p>
<br/>
<p><strong>至此，文章一开头的需求分析全部模块已经基本完成，但仍有优化空间</strong></p>
<hr />
<h2 id="五-项目优化整合"><a class="markdownIt-Anchor" href="#五-项目优化整合"></a> 五、项目优化整合</h2>
<p><strong>我们做项目应该更贴近生活考虑，带给用户更好的体验</strong>，所以还得在细节中下点功夫。</p>
<h3 id="1-优化播放流程"><a class="markdownIt-Anchor" href="#1-优化播放流程"></a> 1. 优化播放流程</h3>
<p>早上醒来<strong>意识是不清醒</strong>的，第一时间播放「天气」肯定听不清楚，而且完全没让人有个好心情啊！所以「天气播报」应该往后捎捎。由此大概确定项目的完整播放流程为：先播放一到两首歌，然后「天气播报」，然后再播放剩下的歌曲。</p>
<p>同时，我们大概率会在第一次播放时听不清楚具体温度，所以我们应该做两次天气的播报。</p>
<blockquote>
<p>注意⚠️：下方代码<code>line</code> <code>12</code>播放天气文件的py脚本，要填写绝对路径！绝对路径！不然无法播放天气！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 播放模块</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playmusic</span>():</span></span><br><span class="line">    <span class="comment"># getSongs_url()函数在上面以实现</span></span><br><span class="line">    songs_url = getSongs_url()</span><br><span class="line">    print(<span class="string">&#x27;开始播放音乐&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&#x27;第一首歌&#x27;</span>)</span><br><span class="line">        <span class="comment"># 先播放第一首</span></span><br><span class="line">        os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 播放两次天气</span></span><br><span class="line">        print(<span class="string">&#x27;播放天气&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">        	os.system(<span class="string">&#x27;python /tmp/clock/TextToVoice.py&#x27;</span>)</span><br><span class="line">        <span class="comment"># 开始随机播放2～32首</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">            <span class="comment"># print(&#x27;播放第&#x27; + str(i) + &#x27;首&#x27;)</span></span><br><span class="line">            os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % songs_url[i])</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&#x27;Exception&#x27;</span>, e)</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="2-渐入播放"><a class="markdownIt-Anchor" href="#2-渐入播放"></a> 2. 渐入播放</h3>
<p>如果播放的音乐一开始非常大声，我们很容易受惊。</p>
<p>所以在播放第一首歌时，渐入。我们可以有两种设计方式，第一种是通过mplayer的<code>slave</code>模式修改，另一种通过<code>amixer</code>修改Linux系统的声音。这里我选择后者，相对来说会更简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amxier调音量基本使用</span></span><br><span class="line">amixer sset 声卡名字(str类型) volume音量(volume%)</span><br><span class="line"><span class="comment"># 例如：amixer sset Headphone 20%</span></span><br></pre></td></tr></table></figure>
<br/>
<p>思路：使用一个<code>for</code>循环，先从一个低音量开始，在<code>range()</code>里面每次递增%<code>1</code>，在每一次循环（递增）中，都会有0.3秒的延迟，这样就实现了较为顺滑的渐入操作。</p>
<p>在python里面控制<code>amixer</code>模块，这次我们尝试使用<code>subprocess.Popen(cmd)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slowUp</span>():</span></span><br><span class="line">    <span class="comment"># %0 and %100</span></span><br><span class="line">    volume = <span class="number">65</span></span><br><span class="line">    <span class="comment"># 每次增加%1，一直从 %65 ～ %90</span></span><br><span class="line">    <span class="keyword">for</span> volume <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 延迟 0.3 秒递增</span></span><br><span class="line">        time.sleep(<span class="number">0.3</span>)</span><br><span class="line">        command = [<span class="string">&quot;amixer&quot;</span>, <span class="string">&quot;sset&quot;</span>, <span class="string">&quot;Headphone&quot;</span>, <span class="string">&quot;&#123;&#125;%&quot;</span>.format(volume)]</span><br><span class="line">        subprocess.Popen(command)</span><br></pre></td></tr></table></figure>
<br/>
<p><strong>但有个很重要的问题</strong>：我们要怎么使用这个渐入函数呢？直接嵌入到播放第一首歌前面吗？肯定不对的，因为程序会先执行完<code>slowUp()</code>函数完成了音量的递增之后，再开始播放音乐。这样是毫无意义的。</p>
<p><strong>有两个解决办法。</strong></p>
<p>第一个是多线程，但对多线程不太熟悉，用不好可能很容易崩，以后详细学习后，再进行代码重构。</p>
<p>第二种就比较机灵点：设置<strong>两个时间一样</strong>的<code>crontab</code>任务，一个执行播放音乐的py脚本，另一个执行渐入渐入的脚本。也就是把多线程这件事交给了<code>crontab</code>！</p>
<p><strong>夸夸自己，真是太机智了！</strong></p>
<hr />
<h2 id="六-设置crontab定时执行脚本"><a class="markdownIt-Anchor" href="#六-设置crontab定时执行脚本"></a> 六、设置crontab定时执行脚本</h2>
<p>说好的是闹钟嘛，我们不能忘记自己最根本的需求。我们把这件事交给<code>crontab</code>就可以。</p>
<h3 id="1-更改树莓派时间"><a class="markdownIt-Anchor" href="#1-更改树莓派时间"></a> 1. 更改树莓派时间</h3>
<p>一般树莓派刷机完后，时间都不会是中国时区的时间，所以我们要先更改到中国上海的。如何更改时区请查看：<a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></p>
<h3 id="2-设置crontab任务"><a class="markdownIt-Anchor" href="#2-设置crontab任务"></a> 2. 设置crontab任务</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&amp;&gt;&gt; /home/clock/log.log</code>表示脚本输出内容到log.log中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分 小时 星期 月 年 command</span></span><br><span class="line"><span class="comment"># 执行主脚本Netease.py播放天气，注意要使用绝对路径！</span></span><br><span class="line"><span class="number">00</span> <span class="number">7</span> * * * python /home/clock/Netease.py &amp;&gt;&gt; /home/clock/log.log</span><br><span class="line"><span class="comment"># 执行VolControl.py渐入，注意要使用绝对路径！</span></span><br><span class="line"><span class="number">00</span> <span class="number">7</span> * * * python /home/clock/VolControl.py</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="六-end总结"><a class="markdownIt-Anchor" href="#六-end总结"></a> 六、END&amp;总结</h2>
<p>这篇文章介绍了如何使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲，看起来顺风顺水，实际上遇到的坑真的数不过来。但我们一定要「<strong>善于思考，善于记录</strong>」，坚持每天输出一些内容，到最后就掌握越来越多技能。</p>
<p>下一篇文章，详细讲一下部署项目的部署问题。源代码也将整合。</p>
<br/>
<br/>
<h5 id="相关文章"><a class="markdownIt-Anchor" href="#相关文章"></a> 相关文章</h5>
<ol>
<li><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></li>
<li><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气播报</title>
    <url>/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201221175630831.png" alt="image-20201221175630831" style="zoom:30%;" />
<a id="more"></a>
<br/>
<p><strong>每日天气提醒</strong>在我的生活中时非常有必要的，对我<strong>每日的出行</strong>会有巨大帮助。因此，智能闹钟项目要考虑加入天气播报功能。该功能可以使用免费的「和风天气」提供的api来实现。</p>
<hr />
<h2 id="一-需求分析"><a class="markdownIt-Anchor" href="#一-需求分析"></a> 一、需求分析</h2>
<p>首先我们得明白需求：</p>
<ol>
<li>
<p>实况天气：参考出门穿什么衣服、是否需要带伞</p>
<p>对应「实况天气」开发版接口：<a href="https://devapi.qweather.com/v7/weather/now">https://devapi.qweather.com/v7/weather/now</a>?</p>
<p>需要获得的数据如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221165538314.png" alt="image-20201221165538314" style="zoom:30%;" />
<br/>
</li>
<li>
<p>每天最低、最高温度：参考整体温度</p>
</li>
<li>
<p>日落时间：希望每天都可以看到好看的晚霞</p>
<p>2、3需求对应「3天预报」开发版接口：<a href="https://devapi.qweather.com/v7/weather/3d">https://devapi.qweather.com/v7/weather/3d</a>?</p>
<p>需要获得的数据如下：</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221165738406.png" alt="image-20201221165738406" style="zoom:33%;" />
</li>
</ol>
<blockquote>
<p>⚠️注意：日落时间可以用「天气预报」、「太阳和月亮」两个接口获得，但使用前者非常简单。</p>
</blockquote>
<h2 id="二-功能实现"><a class="markdownIt-Anchor" href="#二-功能实现"></a> 二、功能实现</h2>
<h3 id="1-获取实况温度与实况状态"><a class="markdownIt-Anchor" href="#1-获取实况温度与实况状态"></a> 1. 获取实况温度与实况状态</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNowWeather</span>():</span></span><br><span class="line">    <span class="comment"># 开发版接口地址</span></span><br><span class="line">    url = <span class="string">&#x27;https://devapi.qweather.com/v7/weather/now?&#x27;</span></span><br><span class="line">    <span class="comment"># 接口参数</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="comment"># 你的城市id</span></span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="comment"># 和风天气key</span></span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="comment"># 使用gzip可较少延迟</span></span><br><span class="line">        <span class="string">&#x27;gzip&#x27;</span>: <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    html = requests.get(url, params)</span><br><span class="line">    content = html.json()</span><br><span class="line">    now_temp = content[<span class="string">&#x27;now&#x27;</span>][<span class="string">&#x27;temp&#x27;</span>]</span><br><span class="line">    now_text = content[<span class="string">&#x27;now&#x27;</span>][<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> now_temp, now_text</span><br></pre></td></tr></table></figure>
<h3 id="2-最低-最高温度-日落时间"><a class="markdownIt-Anchor" href="#2-最低-最高温度-日落时间"></a> 2. 最低、最高温度、日落时间</h3>
<p>我们使用postman对调用接口，对response分析，可以获得第一天的数据</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221171749567.png" alt="image-20201221171749567" style="zoom:40%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get3d</span>():</span></span><br><span class="line">    url = <span class="string">&#x27;https://devapi.qweather.com/v7/weather/3d?&#x27;</span></span><br><span class="line">    <span class="comment"># params与getNowWeather()的一样</span></span><br><span class="line">    html = requests.get(url, params)</span><br><span class="line">    html_content = html.json()</span><br><span class="line">    tempMax = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;tempMax&#x27;</span>]</span><br><span class="line">    tempMin = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;tempMin&#x27;</span>]</span><br><span class="line">    sunsetTime = html_content[<span class="string">&#x27;daily&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;sunset&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tempMax, tempMin, sunsetTime</span><br></pre></td></tr></table></figure>
<h2 id="三-语音合成播报天气"><a class="markdownIt-Anchor" href="#三-语音合成播报天气"></a> 三、语音合成播报天气</h2>
<p><a href="https://ai.baidu.com/tech/speech/tts">点击这里</a>，先注册百度TTS。然后创建一个应用，获得三条信息</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201224110716260.png" alt="image-20201224110716260" style="zoom:50%;" />
<br/>
<p>结合上面的天气模块，直接合成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipSpeech</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> getWeather <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百度TTS信息</span></span><br><span class="line">APP_ID = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">API_KEY = <span class="string">&#x27;xxxxxxxxxx&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;xxxxxxxxxxxxxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipSpeech(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取天气模块的信息</span></span><br><span class="line">now_temp, now_text = getNowWeather()</span><br><span class="line">tempMax, tempMin, sunsetTime = get3d()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正常天气</span></span><br><span class="line">text_normal = <span class="string">&#x27;xxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;最高温度为：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">              + <span class="string">&#x27;看好温度穿衣哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;，祝您傍晚能看到美丽的日落！拜拜～&#x27;</span></span><br><span class="line"><span class="comment"># 最高温度小于14度时</span></span><br><span class="line">text_lowtemp = <span class="string">&#x27;xxxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度！&#x27;</span> + <span class="string">&#x27;最高温度也才：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">               + <span class="string">&#x27;，也是好冷的呢！要多穿衣服哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;祝xxxx傍晚能看到美丽的日落！拜拜～&#x27;</span></span><br><span class="line"><span class="comment"># 下雨</span></span><br><span class="line">text_rain = <span class="string">&#x27;xxxx早上好呀！现在外面&#x27;</span> + now_temp + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;外边正在下雨呢，记得带伞～&#x27;</span> + <span class="string">&#x27;今天最低温度为：&#x27;</span> + tempMin + <span class="string">&#x27;度，&#x27;</span> + <span class="string">&#x27;最高温度为：&#x27;</span> + tempMax + <span class="string">&#x27;度，&#x27;</span> \</span><br><span class="line">            + <span class="string">&#x27;看好温度穿衣哦！&#x27;</span> + <span class="string">&#x27;再提醒一下，今天的日落时间是，&#x27;</span> + sunsetTime + <span class="string">&#x27;祝xxxx傍晚能看到美丽的日落！拜拜～&#x27;</span> + <span class="string">&#x27;对了，记得带伞哦！再见&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># per: 3是性感大叔 4是妹妹；spd: 是语速，vol是: 音量</span></span><br><span class="line"><span class="keyword">if</span> int(tempMax) &lt; <span class="number">14</span>:</span><br><span class="line">    result = client.synthesis(text_lowtemp, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spd&#x27;</span>: <span class="number">5</span>&#125;)</span><br><span class="line"><span class="keyword">elif</span> now_text <span class="keyword">is</span> <span class="string">&#x27;雨&#x27;</span>:</span><br><span class="line">    result = client.synthesis(text_rain, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = client.synthesis(text_normal, <span class="string">&#x27;zh&#x27;</span>, <span class="number">1</span>, &#123;<span class="string">&#x27;vol&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;per&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spd&#x27;</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 播放模块</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(result, dict):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/home/clock/weather.mp3&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br><span class="line">os.system(<span class="string">&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27;</span> % <span class="string">&#x27;/home/clock/weather.mp3&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a class="markdownIt-Anchor" href="#三-总结"></a> 三、总结</h2>
<p>在开始做一个项目模块前，一定要做好需求分析，认真阅读开发者文档，了解清楚需求都要用到哪些接口/工具，不然用错接口就会浪费很多很多时间。就像API文档里面的「天气预报」和「太阳和月亮」接口都可以获得日落时间，但是用前者可以简单上十倍！</p>
<p>一开始的我直冲太阳和月亮，还写了一大堆格式化时间的函数，多此一举。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221180450233.png" alt="image-20201221180450233" style="zoom:30%;" />
<br/>
]]></content>
      <categories>
        <category>智能闹钟</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能闹钟</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（五）｜如何优雅地关闭闹钟？</title>
    <url>/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201223222003013.png" alt="image-20201223222003013" style="zoom:45%;" />
<p>网上相关项目基本都是只有播放功能，没有写关闭音乐，这明显不符合我们真实的使用场景。而日常生活中我们最容易接触的工具是手机，那如何通过手机优雅地关闭闹钟呢？</p>
<a id="more"></a>
<h2 id="一-目录结构"><a class="markdownIt-Anchor" href="#一-目录结构"></a> 一、目录结构</h2>
<p>在<code>clock</code>project内包含有5个脚本，<code>Netease.py</code>是主程序，<code>TextToVoice.py</code>用于文字转语音，<code>VolControl.py</code>实现渐入功能，<code>getWeather.py</code>用于获得每日天气，<code>shtudown.py</code>用于关闭闹钟。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223184351927.png" alt="image-20201223184351927" style="zoom:50%;" />
<h2 id="二-关闭闹钟思路"><a class="markdownIt-Anchor" href="#二-关闭闹钟思路"></a> 二、关闭闹钟思路</h2>
<p>有人说关闭闹钟不就直接使用<code>pkill</code>命令结束掉mplayer进程不就可以了吗？但是，程序默认是循环播放32首歌曲+2次天气播报的，所以mplayer一共会执行34次。</p>
<p>由此，我们也很容易可以得出解决方案：<code>pkill</code>34次mplayer即可。</p>
<p>shutdown.py如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">35</span>):</span><br><span class="line">    os.system(<span class="string">&#x27;pkill -f mplayer&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>可是难道我们每次关闭都要经过：打开电脑，进入<code>ssh</code>，然后<code>sudo -i</code>，然后执行<code>python xxx/xxx/shutdown.py</code>？要是这样，我就根本不想用这个闹钟了！</p>
<p>突然想起之前刷B站时看到一个up主大概介绍了iOS的<strong>快捷指令</strong>！是可以运行脚本的！</p>
<h2 id="三-ios快捷指令关闭"><a class="markdownIt-Anchor" href="#三-ios快捷指令关闭"></a> 三、iOS快捷指令关闭</h2>
<p>设置路径：快捷指令主页右上角<code>+</code> – 添加操作 – 脚本 – 通过SSH运行脚本（一直往下拉） – 然后填好信息 – 保存指令<code>sudo python /home/clock/shutdown.py</code>。详细操作可查看下方图片。</p>
<p>这样我们就可以每天通过快捷指令，直接关闭闹钟了。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173454629.png" alt="image-20201231173454629" style="zoom:33%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173544692.png" alt="image-20201231173544692" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201231173749629.png" alt="image-20201231173749629" style="zoom:50%;" />
<h2 id="四-安卓怎么办"><a class="markdownIt-Anchor" href="#四-安卓怎么办"></a> 四、安卓怎么办？</h2>
<p>我在酷安搜索<code>ssh</code>软件，一个都没有？但无意中发现有一个软件用于PC电脑的远程开关机，查看了一下简介，是通过<code>ssh</code>连接到电脑，然后执行关机指令的。那么同样的，也能用于执行我的<code>shutdown.py</code>！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223225208634.png" alt="image-20201223225208634" style="zoom:33%;" />
<br/>
<p>填写好信息后，点击第三个按钮保存配置，然后点击第二个按钮就可以关闭闹钟了！</p>
<p>还可以把关闭按钮添加在通知栏中，就可以更快速关闭闹钟了！</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223225549628.png" alt="image-20201223225549628" style="zoom:33%;" />
]]></content>
      <categories>
        <category>智能闹钟</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>智能闹钟</tag>
      </tags>
  </entry>
  <entry>
    <title>智能闹钟（四）| 整合搭建</title>
    <url>/2020/12/24/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%95%B4%E5%90%88%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这是一个可以播放「网易云每日推荐歌曲」的闹钟，还可以给女朋友播报天气🌞☁️☔️</p>
<img src="https://picbed.tangspoon.cn/uPic/WechatIMG1204.jpeg" alt="WechatIMG1204" style="zoom:50%;" />
<a id="more"></a>
<hr />
<p>Linux部署项目肯定会有大大小小的问题出现，不会与我下面提供的步骤完全一致。遇到问题多网络搜索，大部分问题都会有解决方案。搜索结果没有的，就耐下心来多看原始文档，多尝试，多尝试，多尝试！</p>
<h2 id="一-目录结构"><a class="markdownIt-Anchor" href="#一-目录结构"></a> 一、目录结构</h2>
<img src="https://picbed.tangspoon.cn/uPic/image-20201223184351927.png" alt="image-20201223184351927" style="zoom: 50%;" />
<h2 id="二-材料准备"><a class="markdownIt-Anchor" href="#二-材料准备"></a> 二、材料准备</h2>
<ol>
<li>树莓派 / 其他可以运行python脚本的开发板</li>
<li>音响：pdd 8.8包邮</li>
</ol>
<h2 id="三-环境准备"><a class="markdownIt-Anchor" href="#三-环境准备"></a> 三、环境准备</h2>
<h3 id="1-系统版本"><a class="markdownIt-Anchor" href="#1-系统版本"></a> 1. 系统版本</h3>
<p>树莓派我用的是Linux raspberrypi 5.4.79-v7+ ，其他版本大同小异。</p>
<h3 id="2-mplayer"><a class="markdownIt-Anchor" href="#2-mplayer"></a> 2. mplayer</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install mplayer</span><br></pre></td></tr></table></figure>
<h3 id="3-baidu-api"><a class="markdownIt-Anchor" href="#3-baidu-api"></a> 3. baidu-api</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install baidu-aip</span><br></pre></td></tr></table></figure>
<h2 id="四-账号准备"><a class="markdownIt-Anchor" href="#四-账号准备"></a> 四、账号准备</h2>
<ol>
<li><a href="https://ai.baidu.com/tech/speech/tts">百度TTS</a>：获取<code>APP_ID</code>， <code>API_KEY</code>， <code>SECRET_KEY</code></li>
<li><a href="https://www.qweather.com/">和风天气</a>：获取城市<code>id</code>，<code>key</code></li>
</ol>
<h2 id="五-开始搭建"><a class="markdownIt-Anchor" href="#五-开始搭建"></a> 五、开始搭建</h2>
<h3 id="1-下载脚本"><a class="markdownIt-Anchor" href="#1-下载脚本"></a> 1. 下载脚本</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i</span><br><span class="line">mkdir &#x2F;home&#x2F;clock &amp;&amp; cd &#x2F;home&#x2F;clock</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tangspoon66&#x2F;NeteaseCloud-Clock.git</span><br></pre></td></tr></table></figure>
<h3 id="2-修改参数"><a class="markdownIt-Anchor" href="#2-修改参数"></a> 2. 修改参数</h3>
<p>脚本内有详细的参数说明，下面只列出需要需要修改的参数，如何修改请参考注释。</p>
<h4 id="neteasepy"><a class="markdownIt-Anchor" href="#neteasepy"></a> <a href="http://Netease.py">Netease.py</a></h4>
<ul>
<li>url</li>
<li>phone</li>
<li>pwd</li>
</ul>
<h4 id="getweatherpy"><a class="markdownIt-Anchor" href="#getweatherpy"></a> <a href="http://getWeather.py">getWeather.py</a></h4>
<ul>
<li>location</li>
<li>key</li>
</ul>
<h4 id="texttovoicepy"><a class="markdownIt-Anchor" href="#texttovoicepy"></a> <a href="http://TextToVoice.py">TextToVoice.py</a></h4>
<ul>
<li>APP_ID</li>
<li>APP_KEY</li>
<li>SECRET_KEY</li>
<li>text_normal、text_lowtemp、text_rain</li>
</ul>
<h3 id="3-定时执行"><a class="markdownIt-Anchor" href="#3-定时执行"></a> 3. 定时执行</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>定时每天<code>7:00</code>的闹钟：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一定要填写绝对路径！</span><br><span class="line">00 7 * * * python &#x2F;home&#x2F;clock&#x2F;Netease.py &amp;&gt;&gt; &#x2F;home&#x2F;clock&#x2F;log.log</span><br><span class="line">00 7 * * * python &#x2F;home&#x2F;clock&#x2F;VolControl.py</span><br></pre></td></tr></table></figure>
<h2 id="六-相关文章"><a class="markdownIt-Anchor" href="#六-相关文章"></a> 六、相关文章</h2>
<ol>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/#more">智能闹钟（一）｜macOS 入门使用树莓派 3B+</a></p>
</li>
<li>
<p><a href="http://localhost:4000/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/#more">智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报</a></p>
</li>
<li>
<p><a href="https://blog.tangspoon.cn/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89%7C%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/#more">智能闹钟（三）| 使用「网易云音乐 NodeJS 版 API 接口」播放每日推荐歌曲</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派开启crontab日志</title>
    <url>/2020/12/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201223205438951.png" alt="image-20201223205438951" style="zoom:40%;" />
<a id="more"></a>
<p>今天的树莓派闹钟情况有点问题，想查看一下crontab任务完成情况，结果找了半天找不到log。原来是树莓派系统默认禁止了生成日志文件。解决办法也很简单。</p>
<br/>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;rsyslog.conf</span><br></pre></td></tr></table></figure>
<p>在文件中找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cron.*                     &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure>
<p>把<code>#</code>去掉，然后’esc’，输入<code>:wq</code></p>
<p>输入一下代码重新启动日志服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rsyslog restart</span><br></pre></td></tr></table></figure>
<p>执行一个crontab任务，再到<code>/var/log/cron.log</code>就可以查看到执行情况</p>
<hr />
<p>参考资料：</p>
<p><a href="https://my.oschina.net/u/4341499/blog/4280350">https://my.oschina.net/u/4341499/blog/4280350</a></p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>格式化时间</title>
    <url>/2020/12/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<p>在和风天气API获取日落时间时，没仔细看清楚官方文档，绕了一个大圈。但是也学到了时间格式化的一些操作，在这里继续记录下来。</p>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201221193040002.png" alt="image-20201221193040002" /></p>
<a id="more"></a>
<hr />
<h2 id="一-获取系统日期并格式化"><a class="markdownIt-Anchor" href="#一-获取系统日期并格式化"></a> 一、获取系统日期并格式化</h2>
<p>因为使用sunmoon接口<code>https://devapi.qweather.com/v7/astronomy/sunmoon?</code>需要使用当天日期，格式例如<code>20201218</code>，Linux的时间显示格式为<code>Mon 21 Dec 18:39:36 CST 2020</code>，因此我们需要把系统格式化。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221191037433.png" alt="image-20201221191037433" style="zoom:70%;" />
<p>可以使用Python的<code>datetime</code>模块，使用方式如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatTime</span>():</span></span><br><span class="line">	<span class="comment"># 实例化对象</span></span><br><span class="line">    dt = datetime.now()</span><br><span class="line">    year = dt.year</span><br><span class="line">    month = dt.month</span><br><span class="line">    day = dt.day</span><br><span class="line">    <span class="comment"># 组合时间</span></span><br><span class="line">    today = str(year) + str(month) + str(day)</span><br><span class="line">    <span class="comment"># print(&#x27;today: &#x27;,today)</span></span><br><span class="line">    <span class="keyword">return</span> today</span><br></pre></td></tr></table></figure>
<h2 id="二-发送日落请求"><a class="markdownIt-Anchor" href="#二-发送日落请求"></a> 二、发送日落请求</h2>
<p>获取了格式化的<code>date</code>之后，我们就可以获取日落时间了。过程如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSunsetTime</span>():</span></span><br><span class="line">    sunset_url = <span class="string">&#x27;https://devapi.qweather.com/v7/astronomy/sunmoon?&#x27;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;101280101&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;6dee7771746148fbbee9cedeb9c1ffc4&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;date&#x27;</span>: date,</span><br><span class="line">        <span class="string">&#x27;gzip&#x27;</span>: <span class="string">&#x27;y&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    sun_html = requests.get(sunset_url, params)</span><br><span class="line">    sun_content = sun_html.json()</span><br><span class="line">    sunset_time = sun_content[<span class="string">&#x27;sunset&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;sunset_time:&#x27;</span>, sunset_time)</span><br><span class="line">    print(<span class="string">&#x27;sunset_time is: &#x27;</span>, type(sunset_time))</span><br><span class="line">    <span class="keyword">return</span> sunset_time</span><br></pre></td></tr></table></figure>
<br/>
<p>以下红框是我们需要的时间，在使用<code>type()</code>验证了日落时间是<code>str</code>类型后，我们可以通过<strong>正则表达式</strong>来提取我们需要的<code>17:47</code></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221192116078.png" alt="image-20201221192116078" style="zoom:50%;" />
<h2 id="三-正则表达式提取做需要的字符串"><a class="markdownIt-Anchor" href="#三-正则表达式提取做需要的字符串"></a> 三、正则表达式提取做需要的字符串</h2>
<p>使用<code>re</code>模块下的<code>findall</code>配合正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分离日落时间，获得几点几分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSunsetHM</span>():</span></span><br><span class="line">    <span class="comment"># 使用正则表达式</span></span><br><span class="line">    sunsetime = getSunsetTime()</span><br><span class="line">    sunsetHM = (re.findall(<span class="string">r&quot;T(.+?)\+&quot;</span>, sunsetime))</span><br><span class="line">    print(sunsetHM)</span><br><span class="line">    <span class="keyword">return</span> sunsetHM</span><br></pre></td></tr></table></figure>
<br/>
<p>提取结果显示</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201221192820537.png" alt="image-20201221192820537" style="zoom:50%;" />
<hr />
<p>完整代码已上传到Github：</p>
<p><a href="https://github.com/tangspoon66/MyPythonCode/blob/master/formatTime.py">https://github.com/tangspoon66/MyPythonCode/blob/master/formatTime.py</a></p>
<br/>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/liao392781/article/details/80181088">https://blog.csdn.net/liao392781/article/details/80181088</a></p>
<p><a href="https://blog.csdn.net/shomy_liu/article/details/44141483">https://blog.csdn.net/shomy_liu/article/details/44141483</a></p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式-01</title>
    <url>/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/</url>
    <content><![CDATA[<h3 id="简单"><a class="markdownIt-Anchor" href="#简单"></a> 简单</h3>
<ul>
<li><code>\d</code> 匹配数字</li>
<li><code>\w</code> 匹配字母</li>
<li><code>.</code> 匹配所有</li>
</ul>
<p>例如：<code>00\d</code> 可以匹配000～009，<code>00\w</code> 可以匹配00a～00z，<code>\w\w</code> 可以匹配 aa，<code>\w.</code> 可以匹配 js、j1、j! 等</p>
<ul>
<li><code>*</code>表示任意个字符（包括0个）</li>
<li><code>+</code>表示至少一个字符</li>
<li><code>?</code>表示0个或1个字符</li>
<li><code>&#123;n&#125;</code>表示n个字符</li>
<li><code>&#123;n,m&#125;</code>表示n-m个字符：</li>
</ul>
<a id="more"></a>
<p>复杂例子：<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code>。</p>
<p>我们来从左到右解读一下：</p>
<ol>
<li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>'010'</code>；</li>
<li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code>，<code>'\t\t'</code>等；</li>
<li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>'1234567'</code>。</li>
</ol>
<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>
<p>如果要匹配<code>'010-12345'</code>这样的号码呢？由于<code>'-'</code>是特殊字符，在正则表达式中，要用<code>'\'</code>转义，所以，上面的正则是<code>\d&#123;3&#125;\-\d&#123;3,8&#125;</code>。</p>
<h3 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h3>
<p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线与$组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'js2015'</code>等等；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；</li>
<li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>'JavaScript'</code>、<code>'Javascript'</code>、<code>'javaScript'</code>或者<code>'javascript'</code>。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p>你可能注意到了，<code>js</code>也可以匹配<code>'jsp'</code>，但是加上<code>^js$</code>就变成了整行匹配，就只能匹配<code>'js'</code>了。</p>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1=<span class="regexp">/ABC\-001/</span></span><br><span class="line"><span class="keyword">var</span> re2=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>)  <span class="comment">//字符串的转义问题，字符串的两个\\实际上是一个\。</span></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure>
<h3 id="切分字符串"><a class="markdownIt-Anchor" href="#切分字符串"></a> 切分字符串</h3>
<p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure>
<p>嗯，无法识别连续的空格，用正则表达式试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure>
<p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>
<p>再加入<code>;</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure>
<p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p>
<h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3>
<p>用<code>()</code>表示的就是要提取的分组（Group）。比如：</p>
<p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line">re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line">re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
<p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p>
<p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p>
<p>提取子串非常有用。来看一个更凶残的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;19:05:30&#x27;</span>); <span class="comment">// [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure>
<p>对于<code>'2-30'</code>，<code>'4-31'</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p>
<h3 id="贪婪匹配"><a class="markdownIt-Anchor" href="#贪婪匹配"></a> 贪婪匹配</h3>
<p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p>
<p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure>
<h3 id="全局搜索"><a class="markdownIt-Anchor" href="#全局搜索"></a> 全局搜索</h3>
<p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure>
<p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p>
<p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>测试功能点总结</title>
    <url>/2020/11/17/%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。</p>
<a id="more"></a>
<h1 id="功能点列表"><a class="markdownIt-Anchor" href="#功能点列表"></a> 功能点列表</h1>
<blockquote>
<p>所有xmind文件都可以在blog的「<a href="https://file.tangspoon.cn">文件</a>」中下载，但目前使用的是Gcore的俄罗斯的vps搭建的OLAINDEX，所以访问与下载可能会有些慢，日后会进行优化。</p>
</blockquote>
<ol>
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%9C%8B%E5%8F%8B%E5%9C%88%E8%AF%84%E8%AE%BA-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">朋友圈点赞-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162135625.png" alt="image-20201117162135625" style="zoom:50%;" />
<hr />
<ol start="2">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">微信红包-测试点.xmind</a></li>
</ol>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201117162237889.png" alt="image-20201117162237889" /></p>
<hr />
<ol start="3">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%90%9C%E7%B4%A2%E6%A1%86-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">搜索框-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162335854.png" alt="image-20201117162335854" style="zoom:50%;" />
<hr />
<ol start="4">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E6%9C%8B%E5%8F%8B%E5%9C%88%E8%AF%84%E8%AE%BA-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">朋友圈评论-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162433886.png" alt="image-20201117162433886" style="zoom:50%;" />
<hr />
<ol start="5">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">视频播放器-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162512012.png" alt="image-20201117162512012" style="zoom:50%;" />
<hr />
<ol start="6">
<li><a href="https://file.tangspoon.cn/d/nl3EA3Gg/q/%E6%B5%8B%E8%AF%95%E7%82%B9/%E8%B4%AD%E7%89%A9%E8%BD%A6-%E6%B5%8B%E8%AF%95%E7%82%B9.xmind?download=1">购物车-测试点.xmind</a></li>
</ol>
<img src="https://picbed.tangspoon.cn/uPic/image-20201117162604959.png" alt="image-20201117162604959" style="zoom:50%;" />
<hr />
<blockquote>
<p>欢迎在下方评论区补充</p>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>测试点</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用例-基础知识</title>
    <url>/2020/11/16/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。</p>
<a id="more"></a>
<h2 id="测试用例-误区"><a class="markdownIt-Anchor" href="#测试用例-误区"></a> 测试用例-误区</h2>
<blockquote>
<p>首先，我们深刻理解测试用例的基本概念，打牢根基对日后cases的编写应该很有帮助。</p>
</blockquote>
<ol>
<li>
<p>测试用例是什么？</p>
<p>测试用例是“一组输入、执行条件、预期结果”</p>
</li>
<li>
<p>什么是一个好的测试用例？</p>
<p>“能发现当前未发现的缺陷的用例就是一个好的用例。”当然是这样的，但是我们要注意，不要盲目片面地去设计出“难以发现的缺陷”，忘了测试的存在。测试用例实际上是个集合，所以对它的评价也只能对cases的集合来进行。作为测试依据的测试用例，必须要能完整覆盖「测试需求」，而不应该针对单个的测试用例去评判好坏。</p>
</li>
<li>
<p>测试用例的预期结果不需要验证吗？</p>
<p>比如我们测试一个论坛的更改昵称的功能，我们的预期结果不应该仅仅只有“昵称更改成功”，还应该包含着对预期结果的验证：在数据库中执行查询语句，看查询结果是否与预期一致。</p>
</li>
</ol>
<h2 id="测试用例-作用"><a class="markdownIt-Anchor" href="#测试用例-作用"></a> 测试用例-作用</h2>
<ol>
<li>
<p>指导测试的「实施」</p>
<p>整个整个测试过程分成好几个阶段，每个阶段都有不同优先级与重要级的cases。</p>
</li>
<li>
<p>「规划」测试数据</p>
<p>在实践中，数据和用例是分开的。按照测试用例配备一组或若干组测试「原始数据」，以及标准测试结果。除正常数据之外，还必须根据测试用例设计大量的「边缘数据」和「错误数据」。</p>
</li>
<li>
<p>评估测试结果的度量基准</p>
<p>在测试执行阶段完成后，我们得进行测试结果的评估，然后编写测试报告。做大部分的判断都是需要量化的结果的，测试也不例外。我们怎么判断一个软件的质量如何呢？测试用例就能给我们提供帮助。我们可以用测试用例中统计出测试覆盖率、测试合格率、重要测试合格率等等。</p>
</li>
</ol>
<h2 id="测试用例-设计方法"><a class="markdownIt-Anchor" href="#测试用例-设计方法"></a> 测试用例-设计方法</h2>
<h3 id="等价类划分"><a class="markdownIt-Anchor" href="#等价类划分"></a> 等价类划分</h3>
<h4 id="输入数据的划分方式可以从哪几个方面划分"><a class="markdownIt-Anchor" href="#输入数据的划分方式可以从哪几个方面划分"></a> 输入数据的划分方式（可以从哪几个方面划分？）</h4>
<p>输入数据的「个数、集合、规则、取值范围、布尔值」。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116115530110.png" alt="image-20201116115530110" style="zoom:50%;" />
<h4 id="设计测试用例的步骤"><a class="markdownIt-Anchor" href="#设计测试用例的步骤"></a> 设计测试用例的步骤</h4>
<ol>
<li>
<p>分析需求，确定「输入」「数据类型」。</p>
<p>例如，固定电话号码的测试，固话号码的输入为：区号+电话号，前者的数据类型为：3/4位的数字，后者的类型为：7/8位的电话号。</p>
<p><strong>所以，分析需求，得从输入与数据类型两个维度来看。</strong></p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116122413990.png" alt="image-20201116122413990" style="zoom:50%;" />
<img src="https://picbed.tangspoon.cn/uPic/image-20201116123007606.png" alt="image-20201116123007606" style="zoom:50%;" />
</li>
<li>
<p>根据「输入规则」，使用上面的划分方式效&amp;无效等价类</p>
<p>1）规则列表（可以从长度，集合，规则，取之范围……来看）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116140515364.png" alt="image-20201116140515364" style="zoom:50%;" />
<p>2）「划分」有效等价类与无效等价类</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116140757649.png" alt="image-20201116140757649" style="zoom:50%;" />
</li>
<li>
<p>设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类）</p>
</li>
<li>
<p>设计用例，覆盖无效等价类（一条用例只能覆盖一条无效等价类）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116141015502.png" alt="image-20201116141015502" style="zoom:50%;" />
</li>
</ol>
<hr />
<h3 id="边界值"><a class="markdownIt-Anchor" href="#边界值"></a> 边界值</h3>
<blockquote>
<p>边界值分析法一般是搭配「等价类划分」使用来设计测试用例</p>
</blockquote>
<h4 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h4>
<p>首先，得明白上点、离点、内点的概念。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116142302992.png" alt="image-20201116142302992" style="zoom:50%;" />
<h4 id="什么时候用边界值"><a class="markdownIt-Anchor" href="#什么时候用边界值"></a> 什么时候用边界值？</h4>
<p>在使用「等价类划分」时，划分有效&amp;无效等价类这一步时，要结合边界值来设计测试用例。</p>
<p>还是以固话号码为例。区号长度3/4位，上点：3、4，离点：2、5，内点：3/4（与上点重复）</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116144337242.png" alt="image-20201116144337242" style="zoom:50%;" />
<p>所以，在设计测试用例时，“3. 以0开头的小于3位的数字（离点：2位）”设计成“01（2位，而不是1位） 1234567”。</p>
<hr />
<h3 id="判定表法"><a class="markdownIt-Anchor" href="#判定表法"></a> 判定表法</h3>
<img src="https://picbed.tangspoon.cn/uPic/image-20201116145508305.png" alt="image-20201116145508305" style="zoom:50%;" />
<hr />
<h3 id="因果图"><a class="markdownIt-Anchor" href="#因果图"></a> 因果图</h3>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201116150217436.png" alt="image-20201116150217436" /></p>
<hr />
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="https://picbed.tangspoon.cn/uPic/image-20201116150700289.png" alt="image-20201116150700289" /></p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1QJ411g7nR?p=8">https://www.bilibili.com/video/BV1QJ411g7nR?p=8</a></li>
<li><a href="https://www.cnblogs.com/kuihua/p/5925092.html">https://www.cnblogs.com/kuihua/p/5925092.html</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的“用户登陆”用例设计真的简单吗？</title>
    <url>/2020/11/01/%E7%AE%80%E5%8D%95%E7%9A%84%E2%80%9C%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E2%80%9D%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。</p>
<a id="more"></a>
<h3 id="一-基础用例"><a class="markdownIt-Anchor" href="#一-基础用例"></a> 一、基础用例</h3>
<ol>
<li>输入正确的账号密码，验证是否登陆成功；</li>
<li>输入正确的账号错误的密码，验证是否登陆失败，并且提示信息正确；（“提示信息正确”指的是每个项目的提示都不一样，这里统称提示信息正确，往下所有均为此意）</li>
<li>输入未注册的账号和任意密码，验证是否登陆失败，并提示信息正确；</li>
<li>用户名和密码两者为空，验证是否登陆失败，并提示信息正确；</li>
<li>用户名和密码两者之一为空，验证是否登陆失败，并提示信息正确；</li>
<li>如果登陆功能启用了「验证码功能」，在用户名与密码正确的前提下，输入正确的验证码，验证是否登陆成功；</li>
<li>如果登陆功能启用了「验证码功能」，用户名与密码输入正确的前提下，输入错误的验证码，验证是否登陆失败，并提示信息正确；</li>
<li>用户民密码是否支持特殊字符和中文；</li>
<li>前端校验格式长度等，后端是否也校验</li>
</ol>
<h3 id="二-中阶用例"><a class="markdownIt-Anchor" href="#二-中阶用例"></a> 二、中阶用例</h3>
<ol>
<li>用户名和密码是否大小写敏感；</li>
<li>页面上的密码框是否加密显示；</li>
<li>忘记用户名和忘记密码的功能是否可用；</li>
<li>前端页面是否根据设计要求限制用户名和密码的长度；</li>
<li>如果登陆功能需要验证码，点击验证图片是否可以更换验证码，更换后的验证码是否可用；</li>
<li>刷新页面是否会刷新验证码；</li>
<li>如果验证码具有时效性，需要分别验证时效内和时效外的验证码的有效性；</li>
<li>不同级别的用户，比如管理员和普通用户，登陆系统后的权限是否正确；</li>
<li>后台系统创建的用户第一次登陆成功时，是否提示修改密码；</li>
<li>用户登陆成功直到会话超时后，继续操作是否会重定向到用户登陆界面；</li>
<li>页面默认焦点是否定位在用户名的输入框中；</li>
<li>快捷键tab和enter等，是否可以正常使用。</li>
</ol>
<blockquote>
<p>1-4可归纳为「用户名密码的大小与长度」细分类，5-7是验证码类，9-12是用户体验类</p>
</blockquote>
<hr />
<p><strong>一个质量过硬的软件系统，除了显式功能性需求以外，其他的「非功能性需求」即隐式功能性需求也是极其关键的</strong></p>
<p>非功能性需求主要涉及：安全、性能、兼容三大方面。</p>
<hr />
<h3 id="三-安全测试用例"><a class="markdownIt-Anchor" href="#三-安全测试用例"></a> 三、安全测试用例</h3>
<ol>
<li>用户名密码后台存储是否加密；</li>
<li>用户名在网络传输过程中是否加密；</li>
<li>密码是否具有有效期，密码有效期到期后，是否提示需要修改密码；</li>
<li>不登陆的情况下，在浏览器中直接输入登陆后的URL地址，验证是否会重定向到用户已登陆的界面；</li>
<li>密码输入框是否不支持复制和粘贴；</li>
<li>密码输入框框内输入密码是否都可以在页面源代码模式下被查看；</li>
<li>用户名和密码的输入框分别输入典型的“SQL 注入攻击”字符串，验证系统的返回页面；</li>
<li>用户名和密码的输入框中分别输入典型的“XSS 跨站脚本攻击”字符串，验证系统行为是否被篡改；</li>
<li>连续多次登陆失败的情况下，系统是否会阻止后续的尝试以应对暴力破解；</li>
<li>同一用户在同一终端的多种浏览器上登陆，验证登陆功能的互斥性是否符合设计预期；</li>
<li>同一用户先后在多台终端的浏览器上登陆，验证登陆是否具有互斥性。</li>
</ol>
<h3 id="四-性能压力测试用例"><a class="markdownIt-Anchor" href="#四-性能压力测试用例"></a> 四、性能压力测试用例</h3>
<ol>
<li>
<p>单用户登陆的响应时间是否小于3秒；</p>
</li>
<li>
<p>单用户登陆时，后台请求数量是否过多；</p>
</li>
<li>
<p>高并发场景下用户登陆的响应时间是否小于5秒；</p>
</li>
<li>
<p>高并发场景下「服务端的监控指标」是否符合预期；</p>
</li>
<li>
<p>高集合点并发场景下，是否存在资源思索和不不合理的资源等待；</p>
</li>
<li>
<p>长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏。</p>
</li>
</ol>
<h3 id="五-兼容性测试用例"><a class="markdownIt-Anchor" href="#五-兼容性测试用例"></a> 五、兼容性测试用例</h3>
<ol>
<li>不同浏览器下，验证登陆页面的现实以及功能的正确性；</li>
<li>相同浏览器的不同版本下，验证登录页面的现实以及功能的正确性；</li>
<li>不同移动设备终端的不同浏览器下，验证登录页面的现实以及功能的正确性；</li>
<li>不同分辨率的界面下，验证登录页面的现实以及功能正确性。</li>
</ol>
<h3 id="六-其他网友补充"><a class="markdownIt-Anchor" href="#六-其他网友补充"></a> 六、其他网友补充</h3>
<ol>
<li>
<p>是否支持第三方登录；</p>
</li>
<li>
<p>是否可记住密码，记住密码保存是否加密，记住密码是否有有效期，过期后是否会清空密码；</p>
</li>
<li>
<p>是否可以用抓包工具抓到的请求包直接登录；</p>
</li>
<li>
<p>截取到的token等信息，是否可以直接在其他终端上使用，绕开登陆。token过期时间教研；</p>
</li>
<li>
<p>修改密码后</p>
<p>（1）修改完密码后是否重定向到登录界面<br />
（2）修改完密码后，分别使用原密码和新密码登录<br />
（3）在其他终端修改密码后，本终端是否自动下线？下线后，使用原密码能否继续登录？</p>
</li>
<li>
<p>密码错误限制次数<br />
（1）密码输入错误是否有最大次数限制？分别测试最大值-1、最大值、最大值+1时的输错密码情况<br />
（2）超过最大次数限制后，是否采取强制手段限制登录或对账号暂时冻结处理<br />
（3）超过最大次数限制后，分别输入正确的密码和错误的密码再次登录</p>
</li>
<li>
<p>登录用户限制：比如同时支持10个用户登录，同时9个或者11个用户登录是否正常或者提示信息正确</p>
</li>
<li>
<p>用户名和密码是否对空格敏感</p>
</li>
<li>
<p>密码是否有明文和暗文显示两种模式(有时候只有暗文显示真的不知道自己的密码是否输入正确)</p>
</li>
<li>
<p>更改密码后是否还能用之前的密码登录</p>
</li>
<li>
<p>一个用户是否具备多种登录方式(用户名，手机号，邮箱…)</p>
</li>
<li>
<p>若支持手机号+验证码登录，验证码是否有时间限制？移动端设备是否可以直接获取验证码？</p>
</li>
</ol>
<blockquote>
<p>一个优秀的测试工程师必须具有很宽广的知识面，如果你不能对被测系统的设计有深入的理解、不明白安全攻击的基本原理、没有掌握性能测试的基本设计方法，很难设计出“有的放矢”的测试用例。</p>
</blockquote>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>解决badboy出现“页面的脚本发生素错误”</title>
    <url>/2020/10/29/%E8%A7%A3%E5%86%B3badboy%E5%87%BA%E7%8E%B0%E2%80%9C%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%84%9A%E6%9C%AC%E5%8F%91%E7%94%9F%E7%B4%A0%E9%94%99%E8%AF%AF%E2%80%9D/</url>
    <content><![CDATA[<h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3>
<p>学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。</p>
<a id="more"></a>
<hr />
<img src="https://picbed.tangspoon.cn/uPic/image-20201102195628553.png" alt="image-20201102195628553" style="zoom:50%;" />
<p>网上正常的几种方法都尝试过了，但无效。后来看到了<a href="https://blog.csdn.net/weixin_38470851/article/details/80687911">这篇CSDN的文章</a>，果然有用。记录一下。</p>
<img src="https://picbed.tangspoon.cn/uPic/Xnip2020-11-02_19-45-07.jpg" alt="Xnip2020-11-02_19-45-07" style="zoom:50%;" />
]]></content>
      <categories>
        <category>troubleshooting</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>troubleshooting</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试基础理论</title>
    <url>/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/</url>
    <content><![CDATA[<h3 id="软件测试的分类"><a class="markdownIt-Anchor" href="#软件测试的分类"></a> 软件测试的分类</h3>
<h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4>
<ul>
<li>
<p>黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「<strong><a href="https://www.omegaxyz.com/2019/07/23/software-specification/">需求规格说明书</a></strong>」，检查程序的功能是否符合它的功能说明。</p>
<p>方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等</p>
<ul>
<li>错误推测法：基于<strong>经验和直觉</strong>，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格……</li>
<li>因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的<strong>联系、组合情况</strong>。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。<strong>因果图最终产生的是判定表</strong>。</li>
</ul>
</li>
<li>
<p>白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。</p>
<p>主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等</p>
<a id="more"></a>
</li>
</ul>
<hr />
<h4 id="阶段"><a class="markdownIt-Anchor" href="#阶段"></a> 阶段</h4>
<ul>
<li>
<p>单元测试：</p>
<ul>
<li>重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「<strong>最小可测试单元</strong>」进行检查和验证，所以全局测试不算是单元测试。</li>
<li>单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态数据流分析</li>
<li>单元测试方法：控制流测试、数据流测试、排错测试、分域测试</li>
</ul>
</li>
<li>
<p>集成测试：重点测试「接口」</p>
<ul>
<li>
<p>策略：自顶向下和自底向上</p>
</li>
<li>
<p>应关注：</p>
<img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/jicheng-test.png" alt="jicheng-test" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>系统测试</p>
<p>测试方法有：功能、安全、性能、兼容性、易用性、稳定性……</p>
</li>
<li>
<p>验收测试</p>
<p>Alpha：用户在<strong>开发者的场所</strong>进行，并且在开发者对用户的“指导”下进行测试。总是，A测试是在<strong>受控的环境</strong>下进行的。</p>
<p>Beta：与上相对。</p>
</li>
</ul>
<hr />
<h4 id="方向"><a class="markdownIt-Anchor" href="#方向"></a> 方向</h4>
<ul>
<li>
<p>功能测试：看功能是否正常。</p>
<blockquote>
<p>黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做）</p>
</blockquote>
</li>
<li>
<p>性能测试：判断程序能做多好（与时间挂钩）</p>
<ul>
<li>
<p>压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。</p>
</li>
<li>
<p>负载测试：</p>
<p>定义：数据在超负荷环境下运行，测试软件系统是否能够承担。这种超负荷主要指多并发用户。</p>
<p>理解：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟）</p>
<p>方法：认为生成大量数据，并利用工具模拟频繁并发访问</p>
<blockquote>
<p>以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。</p>
</blockquote>
</li>
<li>
<p>并发测试：一瞬间同一个程序在做同一件事情</p>
</li>
</ul>
<p>从用户角度看性能：软件对用户操作的响应时间</p>
<p>系统管理员角度看：</p>
<ul>
<li>系统的响应时间</li>
<li>系统运行服务器的状态，如cpu利用情况、内润使用情况等</li>
<li>系统是否能够实现拓展</li>
<li>系统支持多少用户访问</li>
<li>系统性能的瓶颈在哪里</li>
<li>系统是否支持7*24小时的业务访问</li>
</ul>
</li>
<li>
<p>安全测试（了解）：防止攻击，例如ddos等</p>
</li>
<li>
<p>兼容性</p>
</li>
</ul>
<h4 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h4>
<p>根据软件的状态划分的</p>
<ul>
<li>静态：不会运行的软件，通过白盒测试看代码</li>
<li>动态：把软件运行起来测试</li>
</ul>
<h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4>
<ul>
<li>冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试），仅对基本功能测试，保证软件跑得起来。</li>
<li>回归测试：回归bug，bug修改了，有没有检查。</li>
</ul>
<hr />
<h3 id="测试流程"><a class="markdownIt-Anchor" href="#测试流程"></a> 测试流程</h3>
<p>4个阶段：测试需求分析阶段、测试计划阶段、执行测试阶段、测试评估阶段。</p>
<h4 id="需求分析阶段"><a class="markdownIt-Anchor" href="#需求分析阶段"></a> 需求分析阶段</h4>
<p>主要是学习业务流程，提取功能点，把小功能提取出来，做成树状图。</p>
<ul>
<li>阅读需求文档：产品经理用文档描述</li>
<li>查看产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。）</li>
</ul>
<h4 id="测试设计阶段"><a class="markdownIt-Anchor" href="#测试设计阶段"></a> 测试设计阶段</h4>
<blockquote>
<p>前三个由产品经理或者组长写，方法是：5W1H</p>
</blockquote>
<ul>
<li>
<p>测试计划：时间、人、资源的分配</p>
</li>
<li>
<p>测试方案</p>
<ul>
<li>每个测试内容如何展开</li>
<li>采用什么测试计划</li>
<li>哪些内容先测</li>
</ul>
</li>
<li>
<p>测试策略</p>
<ul>
<li>哪些内容先测后测（先测功能还是兼容？）</li>
<li>开始和结束的标准是什么？</li>
</ul>
</li>
<li>
<p><strong>测试用例（重点！重中之重！）</strong></p>
<p>包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。</p>
<ul>
<li>
<p>用例编号：唯一的</p>
</li>
<li>
<p>用例名称：言简意赅</p>
</li>
<li>
<p>前置条件：在执行用例前，软件必须要满足的条件</p>
</li>
<li>
<p>优先级：执行用例的时间要求紧急的等级</p>
</li>
<li>
<p>重要级：被测功能在软件中的重要等级</p>
</li>
</ul>
<p>要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ）</p>
</li>
</ul>
<blockquote>
<p>测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方</p>
</blockquote>
<h4 id="测试执行阶段"><a class="markdownIt-Anchor" href="#测试执行阶段"></a> 测试执行阶段</h4>
<p>搭建环境，执行冒烟测试，然后正式测试。</p>
<h4 id="测试评估阶段"><a class="markdownIt-Anchor" href="#测试评估阶段"></a> 测试评估阶段</h4>
<p>出测试报告，确认是否可以上线。</p>
<hr />
<h3 id="测试方法"><a class="markdownIt-Anchor" href="#测试方法"></a> 测试方法</h3>
<h4 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h4>
<p>通过少部分的值，代表大部分的情况。</p>
<ul>
<li>
<p>有效等价类</p>
<p>满足条件的：0.01，0.02，200，199.99</p>
</li>
<li>
<p>无效等价类</p>
<p>不满足条件的：0，200.01</p>
</li>
</ul>
<h4 id="边界法"><a class="markdownIt-Anchor" href="#边界法"></a> 边界法</h4>
<p>0，负数，+1，-1，本身，整数，非整数，字符</p>
<hr />
<h3 id="研发管理模型"><a class="markdownIt-Anchor" href="#研发管理模型"></a> 研发管理模型</h3>
<blockquote>
<p>作用：在开发中会经历很多过程，模型可以知道不同的工作流程。</p>
</blockquote>
<h4 id="瀑布流"><a class="markdownIt-Anchor" href="#瀑布流"></a> 瀑布流</h4>
<p>从上往下，不可逆不可返回的流程。</p>
<h4 id="v字型"><a class="markdownIt-Anchor" href="#v字型"></a> V字型</h4>
<p>左边是开发做的，右边是测试做的，二者一一对照。</p>
<h4 id="w字型"><a class="markdownIt-Anchor" href="#w字型"></a> w字型</h4>
<p>测试与开发同步了。</p>
<hr />
<h3 id="软件的生命周期"><a class="markdownIt-Anchor" href="#软件的生命周期"></a> 软件的生命周期</h3>
<p>是指软件的产生到报废的整个过程。包括可行性分析与项目计划，需求分析，概要设计和详细设计，编码，调试，维护七个阶段。</p>
<h3 id="软件测试的生命周期"><a class="markdownIt-Anchor" href="#软件测试的生命周期"></a> 软件测试的生命周期</h3>
<p>是指从测试项目计划建立到BUG提交的整个「测试过程」，包括测试计划，测试需求分析，测试用例编写，测试用例执行，BUG提交。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试宝典-01</title>
    <url>/2020/10/27/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-01/</url>
    <content><![CDATA[<h2 id="一-软件工程"><a class="markdownIt-Anchor" href="#一-软件工程"></a> 一、软件工程</h2>
<h4 id="1-软件生命周期有哪些阶段常见的软件生命周期模型有哪些"><a class="markdownIt-Anchor" href="#1-软件生命周期有哪些阶段常见的软件生命周期模型有哪些"></a> 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？</h4>
<p>软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。</p>
<p>常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。</p>
<a id="more"></a>
<h4 id="2-什么是版本控制常用的系统有哪些"><a class="markdownIt-Anchor" href="#2-什么是版本控制常用的系统有哪些"></a> 2. 什么是版本控制，常用的系统有哪些？</h4>
<p>是一种软体工程技巧，确保不同的人编辑的统一文档都能得到更新。</p>
<p>1）Git：分布式的版本控制系统。</p>
<p>2）SVN：subversion，分支管理系统。</p>
<h2 id="二-测试模型"><a class="markdownIt-Anchor" href="#二-测试模型"></a> 二、测试模型</h2>
<h4 id="1-常见的测试模型"><a class="markdownIt-Anchor" href="#1-常见的测试模型"></a> 1. 常见的测试模型</h4>
<p>1）V字型：这是一种古老的瀑布模型，反映了实际和测试之间的关系。局限:仅仅把测试过程作为编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，如果前面设计错误， 得一直到后期的验收测试才被发现，耗时耗力。</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123616102.png" alt="image-20201108123616102" style="zoom:50%;" />
<p>2）W型：测试与开发同时进行，在 V 模型的基础上，增加了在开发阶段的同步测试。局限：仍然不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试</p>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123631829.png" alt="image-20201108123631829" style="zoom:50%;" />
<h4 id="2-请根据v模型分别概述测试人员在软件的需求定义阶段-设计阶段-编码阶段-系统集成阶段的工作任务及其相应生成的文档"><a class="markdownIt-Anchor" href="#2-请根据v模型分别概述测试人员在软件的需求定义阶段-设计阶段-编码阶段-系统集成阶段的工作任务及其相应生成的文档"></a> 2. 请根据”V”模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的「工作任务」及其相应「生成的文档」?</h4>
<p>1）需求定义阶段：根据项目需求提取测试需求，形成「测试需求文档」；根据测试需求和项目计划生成「测试计划」。</p>
<p>2）设计阶段：根据测试需求拟定测试方案并形成「测试方案文档」；根据测试方案文档指定测试用例，并形成「测试用例文档」</p>
<p>3）编码阶段：执行测试并完善测试用例文档</p>
<p>4）系统集成阶段：测试总结报告，阶段问题统计报告，测试问题报告</p>
<h2 id="三-测试计划"><a class="markdownIt-Anchor" href="#三-测试计划"></a> 三、测试计划</h2>
<h4 id="1-编写测试计划的目的是"><a class="markdownIt-Anchor" href="#1-编写测试计划的目的是"></a> 1. 编写测试计划的目的是？</h4>
<p>使测试工作顺利进行；使项目参与人员沟通更顺畅；使测试工作更系统（人与系统）</p>
<h4 id="2-测试计划编写六要素"><a class="markdownIt-Anchor" href="#2-测试计划编写六要素"></a> 2. 测试计划编写六要素</h4>
<p>5W1H（谁、时间、地点、做了什么事、为什么、怎么做的H）</p>
<h4 id="3-测试人员在软件开发过程中的任务是什么"><a class="markdownIt-Anchor" href="#3-测试人员在软件开发过程中的任务是什么"></a> 3. 测试人员在软件开发过程中的任务是什么？</h4>
<p>寻找bug，衡量软件的品质，避免软件开发过程中的缺陷，关注用户体验。总的来说就是：确保软件质量。</p>
<h2 id="四-测试种类"><a class="markdownIt-Anchor" href="#四-测试种类"></a> 四、测试种类</h2>
<h4 id="1-请列出你所知道的软件测试种类至少五项"><a class="markdownIt-Anchor" href="#1-请列出你所知道的软件测试种类至少五项"></a> 1. 请列出你所知道的「软件测试种类」，至少五项。</h4>
<img src="https://picbed.tangspoon.cn/uPic/image-20201108123501083.png" alt="image-20201108123501083" style="zoom:50%;" />
<h4 id="2-黑盒测试和白盒测试的常用测试方法有举个例子"><a class="markdownIt-Anchor" href="#2-黑盒测试和白盒测试的常用测试方法有举个例子"></a> 2. 黑盒测试和白盒测试的常用测试方法有？举个例子？</h4>
<p>1）黑盒：等价类划分法、边界值法、因果图法和错误猜测法</p>
<p>2）白盒：逻辑覆盖法、循环测试路径选择、基本路径测试</p>
<p>例子：在一次输入多个条件的完整性查询中。利用等价类划分法和边界分析法，首先利用等价类划分法，制定一个或多个结果是OK的测试用例，然后确认多个NG的测试用例。然后再用边界值分析法，对结果分别是OK和NG的测试用例进行拓展和补充。</p>
<h4 id="3-简述黑盒测试和白盒测试的优缺点"><a class="markdownIt-Anchor" href="#3-简述黑盒测试和白盒测试的优缺点"></a> 3. 简述黑盒测试和白盒测试的优缺点？</h4>
<p>1）黑盒</p>
<ul>
<li>优点：a. 比较简单，不用了解内部代码的实现；b. 从用户的角度出发，很容易知道用户会用到哪些功能，会遇到什么问题；c. 与软件内部无关；d. 在做软件自动化测试时较方便。</li>
<li>缺点：代码覆盖率较低；自动化测试的复用性较低。</li>
</ul>
<p>2）白盒</p>
<ul>
<li>优点：代码覆盖率高，提高代码质量，发现隐藏的问题。</li>
<li>缺点：a. 测试基于代码，只能测试开发人员的对与不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；b. 系统庞大时，测试开销会很大；c. 测试有很多路径，不可能测试完所有的路径。</li>
</ul>
<h4 id="4-单元测试的策略有哪些主要内容有"><a class="markdownIt-Anchor" href="#4-单元测试的策略有哪些主要内容有"></a> 4. 单元测试的策略有哪些，主要内容有？</h4>
<p>逻辑覆盖，循环覆盖，代码走查，静态数据流分析，代码评审，桌前检查，同行评审</p>
<h4 id="5-白盒测试逻辑覆盖有哪几种覆盖标准覆盖率最高的是"><a class="markdownIt-Anchor" href="#5-白盒测试逻辑覆盖有哪几种覆盖标准覆盖率最高的是"></a> 5. 白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是？</h4>
<p>语句覆盖，分支覆盖，条件覆盖，路径覆盖，分支条件覆盖。最高的是路径覆盖。</p>
<h2 id="五-用例设计"><a class="markdownIt-Anchor" href="#五-用例设计"></a> 五、用例设计</h2>
<h4 id="1-什么是测试用例测试用例的基本要素"><a class="markdownIt-Anchor" href="#1-什么是测试用例测试用例的基本要素"></a> 1. 什么是测试用例，测试用例的基本要素？</h4>
<p>测试用例是为某个测试目标编写的一组输入、执行条件与预期结果，以便测试某个程序是否符合特定要求。</p>
<p>基本要素：测试索引，测试环境，测试输入，测试操作，预期结果，评价标准</p>
<h4 id="2-描述测试用例设计的完整过程"><a class="markdownIt-Anchor" href="#2-描述测试用例设计的完整过程"></a> 2. 描述测试用例设计的完整过程</h4>
<p>1）根据概要设计、需求文档、测试计划、测试方案细分出测试项</p>
<p>2）根据测试项，按照详细设计与测试方案中测试的覆盖率细分出测试子项</p>
<p>3）用测试设计方法（等价类划分，边界值，因果图等）编写测试用例</p>
<p>注意：用例一定要及时更新（补充与删除），要全面（考虑功能、性能、兼容性等）</p>
<h4 id="3-有个广告的纸杯子请设计测试用例"><a class="markdownIt-Anchor" href="#3-有个广告的纸杯子请设计测试用例"></a> 3. 有个广告的纸杯子，请设计测试用例</h4>
<p>基本功能测试（逻辑功能测试）。</p>
<p>1）硬度：是否达到设计标准。 装载能力:在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。 装载种类:开水(是否产生异味)、温水、冷水、冰水、咖啡。。</p>
<p>2）界面测试(UI 测试)。</p>
<p>看其形状、大小设计是否适合人方便拿起。</p>
<p>外观是否吸引人(广告嘛)，赏心悦目。</p>
<p>带广告的图案沾水受是否掉色、模糊。</p>
<p>3）易用性测试。</p>
<p>看其形状、大小设计是否适合人方便拿起。</p>
<p>残疾人士用此杯去喝水的容程度。 杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。</p>
<p>4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。</p>
<p>5）安全性测试。杯子所用的材料(包括纸基、涂层和广告颜料)是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。</p>
<p>6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。</p>
<p>7）对设计的改进建议。“如果是一次性杯子，能否标示已使用(比如变色)”和“杯子是否有使用者标贴(多人使用时防止混淆)”。</p>
<h4 id="4-一个身份证号码输入框怎么设计用例"><a class="markdownIt-Anchor" href="#4-一个身份证号码输入框怎么设计用例"></a> 4. 一个身份证号码输入框，怎么设计用例?</h4>
<p>校验身份证号的规则有效性（地址码、生日编码、顺序码、校验码）</p>
<p>检验15位身份证和18位身份正好可用</p>
<p>校验末尾是x的情况</p>
<p>校验不足15位、16-17位和18位的情况</p>
<p>如果是必输项，空白时是否有提示与流程是否正常进行</p>
<p>如果不是必输项，校验不输入时流程能否正常进行</p>
<p>检验非数字的情况，是否会有正确提示信息（包括大小写字母，汉字，特殊字符与标点符号）</p>
<h4 id="5-登陆功能怎么设计测试用例"><a class="markdownIt-Anchor" href="#5-登陆功能怎么设计测试用例"></a> 5. 登陆功能怎么设计测试用例？</h4>
<p>具体需求:有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。</p>
<p>此题的考察目的：1. 了解需求(测什么都是从了解需求开始)；2. 是否有设计 Test Case 的能力；3. 是否熟悉各种测试方法； 4. 是否有丰富的 Web 测试经验;；5. 是否了解 Web 开发。</p>
<p>了解需求：1. 登陆界面是弹出窗口式的，还是直接在网页里面；2. 账号长度和密码的强度要求（比如需要多少位、大小写敏感、特殊字符混搭）；3. 界面美观是否有特殊要求（是否要进行UI测试）</p>
<p>用例设计：</p>
<h5 id="1功能测试function-test"><a class="markdownIt-Anchor" href="#1功能测试function-test"></a> 1）功能测试：Function Test</h5>
<ol>
<li>
<p>输入正确的账号密码，点击提交按钮，验证是否能正确登陆（正常输入）</p>
</li>
<li>
<p>输入错误的账号密码，验证登陆会失败，与给出相应的错误提示（错误输入）</p>
</li>
<li>
<p>登陆成功后能否正确跳转到正确界面</p>
</li>
<li>
<p>账号和密码如果太长或太短，应该怎么处理（安全性，密码太短都有提示）</p>
</li>
<li>
<p>账号和密码中，有特殊字符（比如空格）和其他非英文情况（是否做了顾虑）</p>
</li>
<li>
<p>账号和密码前后都有空格的处理</p>
</li>
<li>
<p>输入密码时，大写键盘有提示</p>
</li>
<li>
<p>密码是否加密显示</p>
</li>
<li>
<p>什么都不输，点击提交按钮，看提示信息</p>
</li>
<li>
<p>记住账号功能</p>
</li>
<li>
<p>登陆失败后，不能记录密码的功能</p>
</li>
<li>
<p>牵涉到验证码的，还要考虑验证难度是否过大，刷新或者换一个的按钮是否好用</p>
</li>
<li>
<p>登陆页面中的注册、忘记密码、登出、用另一账号等链接是否正确</p>
</li>
</ol>
<h5 id="2界面测试ui-test"><a class="markdownIt-Anchor" href="#2界面测试ui-test"></a> 2）界面测试：UI Test</h5>
<ol>
<li>布局是否合理，2个Testbox和1个按钮是否对其</li>
<li>Testbox和按钮的长度，高度是否符合要求</li>
<li>界面的设计风格是否与UI的设计风格统一</li>
<li>界面的文字简洁易懂，没有错别字</li>
</ol>
<h5 id="3性能测试-performance-test"><a class="markdownIt-Anchor" href="#3性能测试-performance-test"></a> 3）性能测试 Performance Test</h5>
<ol>
<li>打开登陆页面，需要几秒</li>
<li>输入正确的账号密码后，登陆成功跳转到新页面，不超过5秒</li>
</ol>
<h5 id="4安全性测试-security-test"><a class="markdownIt-Anchor" href="#4安全性测试-security-test"></a> 4）安全性测试 Security Test</h5>
<ol>
<li>登陆成功后生成的 Cookie 是否有 HttpOnly（降低脚本盗取风险）</li>
<li>账号密码是否通过加密的方式，发送到Web服务器</li>
<li>账号和密码的验证，应该是用服务器端验证，而不只是用客户端的JS分析</li>
<li>账号和密码的输入框，应该屏蔽SQL注入攻击</li>
<li>账号和密码的输入框，要禁止输入脚本（防止XSS攻击）</li>
<li>错误登陆的次数使用限制（防止暴力破解）</li>
<li>考虑是否支持多用户在同一机器上登陆</li>
<li>考虑一用户在多台机器登陆</li>
</ol>
<h5 id="5可用性测试-usability-test"><a class="markdownIt-Anchor" href="#5可用性测试-usability-test"></a> 5）可用性测试 Usability Test</h5>
<ol>
<li>是否可以用全键盘操作，是否有快捷键</li>
<li>输入账号，密码后回车，是否可以登陆</li>
<li>输入框是否可以用Tab切换</li>
</ol>
<h5 id="6兼容性测试-compatibility-test"><a class="markdownIt-Anchor" href="#6兼容性测试-compatibility-test"></a> 6）兼容性测试 Compatibility Test</h5>
<ol>
<li>主流浏览器功能是否正常</li>
<li>不同系统平台是否工作正常（Macos pc）</li>
<li>移动设备是否工作正常</li>
<li>不同分辨率</li>
</ol>
<h5 id="7本地化测试-localization-test"><a class="markdownIt-Anchor" href="#7本地化测试-localization-test"></a> 7）本地化测试 Localization Test</h5>
<p>不同语言环境，页面显示是否正确</p>
<h5 id="8辅助性测试"><a class="markdownIt-Anchor" href="#8辅助性测试"></a> 8）辅助性测试</h5>
<p>高对比度下是否显示正常（视力不好的人）</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
