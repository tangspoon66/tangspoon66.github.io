{"meta":{"title":"tang's blog","subtitle":"记录，思考","description":"技术导向，完美主义，实用主义","author":"tang","url":"https://blog.tangspoon.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-13T06:57:39.553Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"/404.html","permalink":"https://blog.tangspoon.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-13T06:57:39.565Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"about/index.html","permalink":"https://blog.tangspoon.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-11-08T05:08:12.187Z","updated":"2020-11-08T05:08:12.182Z","comments":false,"path":"tags/index.html","permalink":"https://blog.tangspoon.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-16T15:14:35.417Z","updated":"2020-11-08T05:08:56.575Z","comments":false,"path":"categories/index.html","permalink":"https://blog.tangspoon.cn/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2020-11-16T14:38:18.825Z","updated":"2020-11-16T14:38:18.818Z","comments":false,"path":"archives/index.html","permalink":"https://blog.tangspoon.cn/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"About unittest","slug":"About-unittest","date":"2020-12-04T10:44:32.000Z","updated":"2020-12-04T15:34:08.768Z","comments":true,"path":"2020/12/04/About-unittest/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/04/About-unittest/","excerpt":"","text":"一、TestFixture 该部分内容极为简单，不再赘述。 二、TestSuite 作用：把测试用例组合到一起 TestSuite()是一个类，需要实例化使用。 1. addTest() 「逐个」加载用例 格式：addTest(测试类名(‘测试用例’)) 123456789101112131415161718192021import unittestclass AllTest(unittest.TestCase): def setUp(self) -&gt; None: pass def tearDown(self) -&gt; None: pass # 测试用例1 def test_1(self): self.assertEqual(1, 2) # 测试用例2 def test_2(self): self.assertEqual(2, 3)if __name__ == &#x27;__main__&#x27;: # 实例化TestSuite() suite = unittest.TestSuite() suite.addTest(AllTest(&#x27;test_1&#x27;)) suite.addTest(AllTest(&#x27;test_2&#x27;)) unittest.TextTestRunner(verbosity=2).run(suite) 2. loadTestsFormTestCase(测试类名)、loadTestsFromModule(‘模块名.py’) 两个都是是继承Testloader()，只是前面是加载一个测试类，后者是加载模块名。 12suite=unittest.TestLoader().loadTestsFromTestCase(BaiduTest)suite=unittest.TestLoader().loadTestsFromModule(&#x27;unittest1.py&#x27;) 3. discover() 「批量」加载用例 使用discover()，其实和使用addTest()是类似的，都是要实例化才能使用。 我们来看： 12suite = unittest.TestSuite().addTest(xxxx)discover = unittest.defaultTestLoader.discover(test_dir,pattern=&#x27;xxx&#x27;,top_level_dir=None) 其实addTest()是unittest 的TestSuite()类下面的一个子类而已，同样的，discover()是unitest的defaultTestLoder()类下的字类，所以都是需要实例化的。 start_dir ：要测试的模块名或测试用例目录。 pattern=‘test*.py’ ：表示用例文件名的匹配原则。星号“*”表示任意多个字符。 top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录中），默认为 None。 三、测试断言 一个测试用例只有两种结果，要么 Pass，要么 Fail（代码错误也显示 Fail）。因此，在自动化测试的测试用例中，切记不要使用 if else 这类判 断代码来代替断言。 另外，在自动化测试中尽量不要应用打印结果来判断测试 用例的情况，用例如，果在代码错误或者功能有 Bug 的情况下就让用例报错或 者失败，而不是结果显示 Pass，只有功能正常的测试用例结果才是 Pass 的。","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"初识POM","slug":"初识POM","date":"2020-12-04T08:04:40.000Z","updated":"2020-12-04T08:51:15.380Z","comments":true,"path":"2020/12/04/初识POM/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/04/%E5%88%9D%E8%AF%86POM/","excerpt":"","text":"一、什么是POM POM：Page Object Model——页面对象模。是一种思想。 二、为什么要用POM 在自动化测试的代码编写中，采用普通模式，会产生很多代码冗余。例如元素定位模块，每一个元素都得写find_element_by_xxx，在大型项目中这么写效率显然非常低下。 另外，在UI测试中，前端元素会经常发生改变。普通模式把元素定位、元素操作逻辑、测试脚本等模块揉杂在一个文件内，其一，这种操作看起来非常混乱；其二，如果前端页面发生变化，首先要修改页面元素定位，还要修改测试代码。 而POM模型，把元素定位、业务逻辑分开编写，每个模块独立。每一个页面对应一个页面类，页面的元素写到这个页面类中。 三、怎么用 1. bage.py如下： base.py主要写复用率高的函数，比如打开页面、元素定位、退出等等。该页面中不应该含有固定参数，应该全用变量，所有变量都应该在测试用例中定义的。 1234567891011121314151617class BasePage(object): # init def __init__(self, driver, url): self.driver = driver self.url = url # open def open(self): self.driver.get(self.url) # locator def locator(self, loc): return self.driver.find_element(*loc) # quit def quit(self): self.driver.quit() 2. login_page.py如下： 对象页面其实也就只需写两个内容，获取元素，然后封装元素的每一个操作：先定位，然后再用selenium的元素操作send_keys、click等。 12345678910111213141516171819202122232425from selenium.webdriver.common.by import Byfrom base_page.base import BasePage&#x27;&#x27;&#x27; 在这里主要写登陆页面，思路如下： 1、找到元素 2、然后元素操作封装&#x27;&#x27;&#x27;class LoginPage(BasePage): url = &#x27;http://39.98.138.157/shopxo/index.php?s=/index/user/logininfo.html&#x27; username = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[1]/input&#x27;) password = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[2]/input&#x27;) login_btn = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[3]/button&#x27;) def input_username(self, un): self.locator(self.username).send_keys(un) def input_password(self, pwd): self.locator(self.password).send_keys(pwd) def click_login(self): self.locator(self.login_btn).click() 3. TestUnit.py如下： 在测试模块中，可以用unittest进行测试。并生成相应的测试报告。 1234567891011121314151617181920from selenium import webdriverfrom page_object.login_page import LoginPageclass TestUnit(LoginPage): # 写测试流程 def login(self): self.open() self.input_username(un) self.input_password(pwd) self.quit()if __name__ == &#x27;__main__&#x27;: un = &#x27;carslan&#x27; pwd = &#x27;666666&#x27; driver = webdriver.Chrome() lp = TestUnit(driver, LoginPage.url) lp.login() 四、项目源代码下载 请进入AutoTest文件夹下载","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"Python中的init()到底怎么理解？","slug":"Python中的init-到底怎么理解？","date":"2020-11-24T08:37:47.000Z","updated":"2020-11-24T12:26:04.194Z","comments":true,"path":"2020/11/24/Python中的init-到底怎么理解？/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/24/Python%E4%B8%AD%E7%9A%84init-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F/","excerpt":"在Person类里面有一个__init__(self,name,age)，这里我们分成__init__()和self，和age name三个部分来看。","text":"在Person类里面有一个__init__(self,name,age)，这里我们分成__init__()和self，和age name三个部分来看。 __init__()是初始化函数。为什么需要初始化呢？简单来说，我们在创建Person这个对象的时候，我们仅仅只是创建了一个模具，这个模具什么都没有，没有作为一个person应该有的name和age。这显然是不合理的。 所以我们在实例化对象p=Person()的时候，Person类马上开始初始化，创造出一个拥有属性的person。 那么self又是什么东西？ self是必须的，缺少了会报错。在很多博客上都有说：“self外部对象在类内部的表示”。这里我们说人话，注意听“谁调用，就表示谁”。这里我们把Person实例化给了p，所以就是p调用，简单理解就是这个self就是表示p。我们必须得把p传入到类里面，然后才能通过点.的方式去访问类的属性和方法呀。 参考资料 知乎回答： https://www.zhihu.com/question/46973549/answer/293788116 最良心的Python教程： https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"}]},{"title":"Hexo在generate后出现错误“LaTeX-incompatible input and strict mode is set to 'warn': Unicode text character 开 used in math mode [unicodeTextInMathMode]”","slug":"Hexo在generate后出现错误“LaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-开-used-in-math-mode-unicodeTextInMathMode-”","date":"2020-11-19T04:11:23.000Z","updated":"2020-11-19T04:13:08.972Z","comments":true,"path":"2020/11/19/Hexo在generate后出现错误“LaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-开-used-in-math-mode-unicodeTextInMathMode-”/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/19/Hexo%E5%9C%A8generate%E5%90%8E%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E2%80%9CLaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-%E5%BC%80-used-in-math-mode-unicodeTextInMathMode-%E2%80%9D/","excerpt":"前言 完美主义不允许。 这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。","text":"前言 完美主义不允许。 这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。 正文 在逐篇blog排查过没有拼写错误后，然后逐渐采取了一个很蠢的方式：逐篇删除文章，查找问题所在的博文（还好这个新站点博文数量还不多）。 在删除了《正则表达式-01》这篇文章，执行sudo hexo s后，报错消失。 打开文章，从头开始逐段删除，终于定位到具体的段落 然后在这个段落中再逐渐删除找报错点。终于定位到了！是$这个符号搞的鬼。 基于直觉，加了一个转义字符\\，报错消失～ 出错原因 可以看到下图，是有两个$的，而在Markdown语法中，两个$符号是数学符号和公式的使用。要想使用单个$，要加个转义字符\\。 总结体会 遇到问题要及早解决。如果我第一次遇到了这片文章的故障，就想办法解决，相比现在才去用蠢办法解决时间会节省太多了（起码不用特地写一篇blog～）。 要努力做一个完美主义的人。完美主义我觉得是一个程序员/IT从业者必须具备的一个特质。如果没有完美主义，就很难会深究一个问题。遇到问题就想“能用就行，随便啦”，这个程序员的大忌啊。要“尽量”把每一件事情都做得完美，日后才能安安稳稳过日子嘛。 问题要深究。解决了问题之后，还要知道为什么，日后才不会重复犯错误。就像这次加了转义字符解决了问题，还继续深究为什么会这样，才知道了在markdown中$的用法。","categories":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.tangspoon.cn/tags/Hexo/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"}]},{"title":"测试功能点总结","slug":"测试功能点总结","date":"2020-11-17T08:27:43.000Z","updated":"2020-11-19T03:09:46.267Z","comments":true,"path":"2020/11/17/测试功能点总结/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/17/%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"前言 给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。","text":"前言 给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。 功能点列表 所有xmind文件都可以在blog的「文件」中下载，但目前使用的是Gcore的俄罗斯的vps搭建的OLAINDEX，所以访问与下载可能会有些慢，日后会进行优化。 朋友圈点赞-测试点.xmind 微信红包-测试点.xmind 搜索框-测试点.xmind 朋友圈评论-测试点.xmind 视频播放器-测试点.xmind 购物车-测试点.xmind 欢迎在下方评论区补充","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"测试点","slug":"测试点","permalink":"https://blog.tangspoon.cn/tags/%E6%B5%8B%E8%AF%95%E7%82%B9/"}]},{"title":"测试用例-基础知识","slug":"测试用例-基础知识","date":"2020-11-16T07:11:13.000Z","updated":"2020-11-16T07:17:21.696Z","comments":true,"path":"2020/11/16/测试用例-基础知识/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/16/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"前言 很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。","text":"前言 很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。 测试用例-误区 首先，我们深刻理解测试用例的基本概念，打牢根基对日后cases的编写应该很有帮助。 测试用例是什么？ 测试用例是“一组输入、执行条件、预期结果” 什么是一个好的测试用例？ “能发现当前未发现的缺陷的用例就是一个好的用例。”当然是这样的，但是我们要注意，不要盲目片面地去设计出“难以发现的缺陷”，忘了测试的存在。测试用例实际上是个集合，所以对它的评价也只能对cases的集合来进行。作为测试依据的测试用例，必须要能完整覆盖「测试需求」，而不应该针对单个的测试用例去评判好坏。 测试用例的预期结果不需要验证吗？ 比如我们测试一个论坛的更改昵称的功能，我们的预期结果不应该仅仅只有“昵称更改成功”，还应该包含着对预期结果的验证：在数据库中执行查询语句，看查询结果是否与预期一致。 测试用例-作用 指导测试的「实施」 整个整个测试过程分成好几个阶段，每个阶段都有不同优先级与重要级的cases。 「规划」测试数据 在实践中，数据和用例是分开的。按照测试用例配备一组或若干组测试「原始数据」，以及标准测试结果。除正常数据之外，还必须根据测试用例设计大量的「边缘数据」和「错误数据」。 评估测试结果的度量基准 在测试执行阶段完成后，我们得进行测试结果的评估，然后编写测试报告。做大部分的判断都是需要量化的结果的，测试也不例外。我们怎么判断一个软件的质量如何呢？测试用例就能给我们提供帮助。我们可以用测试用例中统计出测试覆盖率、测试合格率、重要测试合格率等等。 测试用例-设计方法 等价类划分 输入数据的划分方式（可以从哪几个方面划分？） 输入数据的「个数、集合、规则、取值范围、布尔值」。 设计测试用例的步骤 分析需求，确定「输入」「数据类型」。 例如，固定电话号码的测试，固话号码的输入为：区号+电话号，前者的数据类型为：3/4位的数字，后者的类型为：7/8位的电话号。 所以，分析需求，得从输入与数据类型两个维度来看。 根据「输入规则」，使用上面的划分方式效&amp;无效等价类 1）规则列表（可以从长度，集合，规则，取之范围……来看） 2）「划分」有效等价类与无效等价类 设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类） 设计用例，覆盖无效等价类（一条用例只能覆盖一条无效等价类） 边界值 边界值分析法一般是搭配「等价类划分」使用来设计测试用例 基本概念 首先，得明白上点、离点、内点的概念。 什么时候用边界值？ 在使用「等价类划分」时，划分有效&amp;无效等价类这一步时，要结合边界值来设计测试用例。 还是以固话号码为例。区号长度3/4位，上点：3、4，离点：2、5，内点：3/4（与上点重复） 所以，在设计测试用例时，“3. 以0开头的小于3位的数字（离点：2位）”设计成“01（2位，而不是1位） 1234567”。 判定表法 因果图 总结 参考资料： https://www.bilibili.com/video/BV1QJ411g7nR?p=8 https://www.cnblogs.com/kuihua/p/5925092.html","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"简单的“用户登陆”用例设计真的简单吗？","slug":"简单的“用户登陆”用例设计真的简单吗？","date":"2020-11-01T12:21:07.000Z","updated":"2020-11-08T04:11:55.402Z","comments":true,"path":"2020/11/01/简单的“用户登陆”用例设计真的简单吗？/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/01/%E7%AE%80%E5%8D%95%E7%9A%84%E2%80%9C%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E2%80%9D%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97%EF%BC%9F/","excerpt":"前言 可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。","text":"前言 可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。 一、基础用例 输入正确的账号密码，验证是否登陆成功； 输入正确的账号错误的密码，验证是否登陆失败，并且提示信息正确；（“提示信息正确”指的是每个项目的提示都不一样，这里统称提示信息正确，往下所有均为此意） 输入未注册的账号和任意密码，验证是否登陆失败，并提示信息正确； 用户名和密码两者为空，验证是否登陆失败，并提示信息正确； 用户名和密码两者之一为空，验证是否登陆失败，并提示信息正确； 如果登陆功能启用了「验证码功能」，在用户名与密码正确的前提下，输入正确的验证码，验证是否登陆成功； 如果登陆功能启用了「验证码功能」，用户名与密码输入正确的前提下，输入错误的验证码，验证是否登陆失败，并提示信息正确； 用户民密码是否支持特殊字符和中文； 前端校验格式长度等，后端是否也校验 二、中阶用例 用户名和密码是否大小写敏感； 页面上的密码框是否加密显示； 忘记用户名和忘记密码的功能是否可用； 前端页面是否根据设计要求限制用户名和密码的长度； 如果登陆功能需要验证码，点击验证图片是否可以更换验证码，更换后的验证码是否可用； 刷新页面是否会刷新验证码； 如果验证码具有时效性，需要分别验证时效内和时效外的验证码的有效性； 不同级别的用户，比如管理员和普通用户，登陆系统后的权限是否正确； 后台系统创建的用户第一次登陆成功时，是否提示修改密码； 用户登陆成功直到会话超时后，继续操作是否会重定向到用户登陆界面； 页面默认焦点是否定位在用户名的输入框中； 快捷键tab和enter等，是否可以正常使用。 1-4可归纳为「用户名密码的大小与长度」细分类，5-7是验证码类，9-12是用户体验类 一个质量过硬的软件系统，除了显式功能性需求以外，其他的「非功能性需求」即隐式功能性需求也是极其关键的 非功能性需求主要涉及：安全、性能、兼容三大方面。 三、安全测试用例 用户名密码后台存储是否加密； 用户名在网络传输过程中是否加密； 密码是否具有有效期，密码有效期到期后，是否提示需要修改密码； 不登陆的情况下，在浏览器中直接输入登陆后的URL地址，验证是否会重定向到用户已登陆的界面； 密码输入框是否不支持复制和粘贴； 密码输入框框内输入密码是否都可以在页面源代码模式下被查看； 用户名和密码的输入框分别输入典型的“SQL 注入攻击”字符串，验证系统的返回页面； 用户名和密码的输入框中分别输入典型的“XSS 跨站脚本攻击”字符串，验证系统行为是否被篡改； 连续多次登陆失败的情况下，系统是否会阻止后续的尝试以应对暴力破解； 同一用户在同一终端的多种浏览器上登陆，验证登陆功能的互斥性是否符合设计预期； 同一用户先后在多台终端的浏览器上登陆，验证登陆是否具有互斥性。 四、性能压力测试用例 单用户登陆的响应时间是否小于3秒； 单用户登陆时，后台请求数量是否过多； 高并发场景下用户登陆的响应时间是否小于5秒； 高并发场景下「服务端的监控指标」是否符合预期； 高集合点并发场景下，是否存在资源思索和不不合理的资源等待； 长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏。 五、兼容性测试用例 不同浏览器下，验证登陆页面的现实以及功能的正确性； 相同浏览器的不同版本下，验证登录页面的现实以及功能的正确性； 不同移动设备终端的不同浏览器下，验证登录页面的现实以及功能的正确性； 不同分辨率的界面下，验证登录页面的现实以及功能正确性。 六、其他网友补充 是否支持第三方登录； 是否可记住密码，记住密码保存是否加密，记住密码是否有有效期，过期后是否会清空密码； 是否可以用抓包工具抓到的请求包直接登录； 截取到的token等信息，是否可以直接在其他终端上使用，绕开登陆。token过期时间教研； 修改密码后 （1）修改完密码后是否重定向到登录界面 （2）修改完密码后，分别使用原密码和新密码登录 （3）在其他终端修改密码后，本终端是否自动下线？下线后，使用原密码能否继续登录？ 密码错误限制次数 （1）密码输入错误是否有最大次数限制？分别测试最大值-1、最大值、最大值+1时的输错密码情况 （2）超过最大次数限制后，是否采取强制手段限制登录或对账号暂时冻结处理 （3）超过最大次数限制后，分别输入正确的密码和错误的密码再次登录 登录用户限制：比如同时支持10个用户登录，同时9个或者11个用户登录是否正常或者提示信息正确 用户名和密码是否对空格敏感 密码是否有明文和暗文显示两种模式(有时候只有暗文显示真的不知道自己的密码是否输入正确) 更改密码后是否还能用之前的密码登录 一个用户是否具备多种登录方式(用户名，手机号，邮箱…) 若支持手机号+验证码登录，验证码是否有时间限制？移动端设备是否可以直接获取验证码？ 一个优秀的测试工程师必须具有很宽广的知识面，如果你不能对被测系统的设计有深入的理解、不明白安全攻击的基本原理、没有掌握性能测试的基本设计方法，很难设计出“有的放矢”的测试用例。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-10-29T12:05:08.000Z","updated":"2020-11-08T04:20:34.608Z","comments":true,"path":"2020/10/29/Linux基本操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/29/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"前言 虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。 这篇博文开个Linux栏目吧。","text":"前言 虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。 这篇博文开个Linux栏目吧。 基本操作 新建文件 1touch test1.txt 新建文件夹 1mkdir test_dir 复制 1cp 源路径 （空格）目标路径 移动/剪切/重命名 12345# 移动&#x2F;剪切mv test.txt 文件夹路径# 移动+重命名mv test.txt test_dir&#x2F;test2.txt #test_dir为文件夹 查看当前所在路径 1pwd 权限修改 这个参数较多，比较复杂，详细的后面再出一篇博文专门讲这一点。这里只讲常用的几点。 12chmod 777 file # 所有人可读写chmod 600 file # 拥有者可读写 删除 12345rm # 删除文件rm -f # 强制删除文件rm -r # 删除文件夹rm -rf # 强制删除文件夹注意尽量少用 rm -rf！很危险！ 读取文档内容 常用语查看Linux的log日志文件 1234cat # 一次全部读取more # 逐步读取tail -f # 一直读取最新内容tail -n 行数 文件名 # 从第几行开始读","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/tags/Linux/"}]},{"title":"解决badboy出现“页面的脚本发生素错误”","slug":"解决badboy出现“页面的脚本发生素错误”","date":"2020-10-29T09:18:02.000Z","updated":"2020-11-24T13:16:41.345Z","comments":true,"path":"2020/10/29/解决badboy出现“页面的脚本发生素错误”/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/29/%E8%A7%A3%E5%86%B3badboy%E5%87%BA%E7%8E%B0%E2%80%9C%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%84%9A%E6%9C%AC%E5%8F%91%E7%94%9F%E7%B4%A0%E9%94%99%E8%AF%AF%E2%80%9D/","excerpt":"前言 学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。","text":"前言 学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。 网上正常的几种方法都尝试过了，但无效。后来看到了这篇CSDN的文章，果然有用。记录一下。","categories":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"}]},{"title":"后盾人MySQL-多表操作","slug":"后盾人MySQL-多表操作","date":"2020-10-28T13:39:51.000Z","updated":"2020-11-08T04:45:12.940Z","comments":true,"path":"2020/10/28/后盾人MySQL-多表操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"前言 MySQL 表的操作还是有很多需要理解的地方，在此感谢后盾人的文章。","text":"前言 MySQL 表的操作还是有很多需要理解的地方，在此感谢后盾人的文章。 JOIN inner join 查询一班的所有同学 1select s.id,sname,cname from stu s join class c on s.class_id&#x3D;c.id where c.id&#x3D;1; 每个班级发表的文章数量，来操作多张表的关联操作 123456789# 班级：class# 文章：article# 但class与article未设置直接连接，还需用stu联合起来（stu作为桥梁：用stu的class_id把class的id联合，然后再用stu的id把article的stu_id联合）select c.id,count(*) from stu as sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.id;# 1. 计算数量用count(*)；2. 为什么用group by后面的是c.id呢？因为题目要求是「每个班级发表的文章数量」，所以肯定是用class的id来排的。 一班的所有女生发表的文章 12345678# 一班：class# 女生：stu# 文章：articleselect c.id,a.title from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idwhere sex&#x3D;&#39;女&#39;; 哪个班级发表的文章超过两篇 12345678select c.id,count(*) as total from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.idhaving total &gt;&#x3D;2;# 注意total是在count(*)设置的# having total也就是拥有count（*）这个数&gt;&#x3D;2的 每个班级文章的总点击数与平均点击数 123456select c.id,sum(a.click) as class_sum,avg(a.click) from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.idorder by class_sum asc; 每个班级有多少同学 123# 班级：class# 学生：stuselect c.id,count(*) from stu s join class c on s.class_id&#x3D;c.id group by c.id; 上面是两张表连立后的新表，可以看到直接通过cname来统计每个班有多少人（有两个cname就证明有两个人） 学生人数大于两个的班级名称 1234SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as cON s.class_id &#x3D; c.idGROUP BY c.cnameHAVING total&gt;&#x3D;2; outer join 外链接包括left join与right join，可以简单理解为 LEFT JOIN会包含左侧所有表记录，RIGHT JOIN 会包含右侧表全部记录。 获取没有设置QQ的用户 123SELECT s.sname FROM stu AS s LEFT JOIN stu_info as iON s.id &#x3D; i.stu_idWHERE i.qq is null;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"后盾人MySQL-基本操作","slug":"后盾人MySQL-基本操作","date":"2020-10-28T13:17:38.000Z","updated":"2020-11-08T04:46:23.760Z","comments":true,"path":"2020/10/28/后盾人MySQL-基本操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"感谢后盾人的MySQL教程","text":"感谢后盾人的MySQL教程 查询数据 用的两张表： 字段处理 查询制定字段，并排序字段 1select description,cname from class; 条件筛选 根据条件查询 1select *from class where cname&#x3D;&#39;php&#39;; 查询包含关键词的数据 1select *from class where description like &#39;%p%&#39;; 合并「列」返回查询结果 1select concat(id,cname) as &#39;class_info&#39; from class; 介绍中不包含php的班级 1select *from class where description not like &#39;%php%&#39;; 查询学生所在班级编号，并去除重复值 1select distinct class_id from stu; 查询年龄在20~35岁的同学 1select * from stu where age between 20 and 35; 查找2、3班的所有同学 1select *from stu where class_id in(2,3); 查找除了1、3班的同学 1select *from stu where class_id not in(1,3); NULL 查询没有非配班级的学生姓名 1select sname from stu where class_id is null; 查询结果中对没分配班级的学生显示未分配 1select sname,ifnull(class_id,&#39;未分配&#39;) from stu; 排序结果 按学生年龄从大到小排序 1select *from stu order by age desc; 班级从大到小排序，相同班级的同学年龄从小到大排序 1select *from stu order by class_id desc,age asc; 也就是多个条件的罗列。 随机获得一名同学 1select *from stu order by rand() limit 1; 最后报名的同学 1select *from stu order by id desc limit 1; 第二和第三报名的同学 1select *from stu order by id asc limit 1,2; 查找2班年龄最小的同学 12select *from stu where class_id&#x3D;2 and age is not null order by age asc limit 1;# 注意不要忘了order by age中的age 综上：排序中选择某个特定对象，可以用limit来限制。但一定要先排好序再使用。 删除记录 删除所有年龄小于20的同学 1delete from stu where age&lt;20; 删除所有年龄小在30并没有班级的同学 1delete from stu where age&#x3D;30 and class_id is null; 添加记录 添加一条记录 1insert into stu SET sname&#x3D;&#39;小明&#39;,age&#x3D;22,class_id&#x3D;1; 添加多条件记录 12insert into stu(sname,class_id,age) values(&#39;小明&#39;,2,32),(&#39;小张&#39;,3,45);# 注意不要忘了values","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"个人理解TCP/IP","slug":"个人理解TCP:IP","date":"2020-10-27T16:53:05.000Z","updated":"2020-11-08T04:18:36.253Z","comments":true,"path":"2020/10/28/个人理解TCP:IP/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/","excerpt":"本文学习参考文章：https://www.odaily.com/post/5133541 TCP/IP是什么？ TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP……","text":"本文学习参考文章：https://www.odaily.com/post/5133541 TCP/IP是什么？ TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP…… 不同的协议层对数据包有不同的称谓，在传输层叫做段 (segment)，在网络层叫做数据报 (datagram)，在链路层叫做帧 (frame)。 TCP/IP的分层管理 TCP/IP参考模型：网络接口层、网络层、传输层和应用层。 网络上很多会从下往上理解，但从上往下会更符合普通用户的理解。 应用层：这一层的任务是：将接收到的数据包按照「协议」解读成各种类型的数据，然后把这些数据打包传到下一层：传输层。协议有：HTTP、FTP、SMTP、Telnet、NFS、RIP等。 例如：我要发一封邮件，就要用SMTP协议把数据包解读，传给传输层帮我传输。 传输层（TCP层）：这层的任务是：确保分割的单元在另一端正确地到达，它建立端口到端口的连接。用TCP/UDP协议，把应用层传来的数据进行分割成以数据报文段为单位的数据包交给下一层（网络层）。（这是在「网络」中两台机器互相传数据。） 网络层（IP层）：这层的任务是把传输层的数据，在众多的路由器中「找到路」，传给下一层。 该层常见的协议有：IP，ICMP，ARP，RARP 网络接口层（数据连接+物理层）：负责传输「局域网」的数据。这层使用什么协议取决于所使用的无力网络：如果物理网是LAN，那么通常使用的是以太网协议以及他的变体。 两台主机之间是通过网卡进行发送和接受数据的，**以太网在「子网」内以广播的形式发送数据。**光靠MAC地址并不能让两台主机通信，因为如果两台主机不在同一子网，以太网协议就不能用了。这时需要通过网路层来区分每台主机所在的网络是哪个子网。 上面的整个流程举个例子：我向我朋友发一封邮件，内容为“你好！”，这时候在「应用层」就使用SMTP协议对邮件内容进行打包整理，传给「传输层」，用TCP/UDP协议来切割数据（传输的过程都是在网络中进行的，不是局域网）。可是数据都要传去哪里呢？这件事交给「网络层」（IP），它会选择一条路径把交到离你最近的路由器上，再由光线传到我们家里的广猫中，这个时候就交给「网络接口层的协议」发挥作用了，在局域网中把广猫的数据通过网线或wifi发送到我们的电脑网卡中开始接收。 TCP、UDP与其他 TCP协议：面向连接的、基于字节流的、可靠的传输层通信协议 面向连接：需要经过三次握手后，client与servers端才会开始进行数据的传输（但我握手过程中传送的包不包含任何数据） 稳定可靠：能把数据准确可靠地传给对方，简单来说就是，它把数据切成一个个数据包，从第一只数据包开始传，传送成功就翻倍，发现失败就地爬起来，从绊倒的那只数据包重新开始，周而复始。 基于字节流服务：把大块数据分割成以报文段为单位的数据包进行管理。 UDP、ARP、RARP概念相对简单，具体可以参考文章：一文看懂互联网TCP/UDP协议","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.tangspoon.cn/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"https://blog.tangspoon.cn/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"面试宝典-01","slug":"面试宝典-01","date":"2020-10-27T05:29:07.000Z","updated":"2020-11-08T04:37:04.073Z","comments":true,"path":"2020/10/27/面试宝典-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/27/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-01/","excerpt":"一、软件工程 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？ 软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。 常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。","text":"一、软件工程 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？ 软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。 常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。 2. 什么是版本控制，常用的系统有哪些？ 是一种软体工程技巧，确保不同的人编辑的统一文档都能得到更新。 1）Git：分布式的版本控制系统。 2）SVN：subversion，分支管理系统。 二、测试模型 1. 常见的测试模型 1）V字型：这是一种古老的瀑布模型，反映了实际和测试之间的关系。局限:仅仅把测试过程作为编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，如果前面设计错误， 得一直到后期的验收测试才被发现，耗时耗力。 2）W型：测试与开发同时进行，在 V 模型的基础上，增加了在开发阶段的同步测试。局限：仍然不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试 2. 请根据”V”模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的「工作任务」及其相应「生成的文档」? 1）需求定义阶段：根据项目需求提取测试需求，形成「测试需求文档」；根据测试需求和项目计划生成「测试计划」。 2）设计阶段：根据测试需求拟定测试方案并形成「测试方案文档」；根据测试方案文档指定测试用例，并形成「测试用例文档」 3）编码阶段：执行测试并完善测试用例文档 4）系统集成阶段：测试总结报告，阶段问题统计报告，测试问题报告 三、测试计划 1. 编写测试计划的目的是？ 使测试工作顺利进行；使项目参与人员沟通更顺畅；使测试工作更系统（人与系统） 2. 测试计划编写六要素 5W1H（谁、时间、地点、做了什么事、为什么、怎么做的H） 3. 测试人员在软件开发过程中的任务是什么？ 寻找bug，衡量软件的品质，避免软件开发过程中的缺陷，关注用户体验。总的来说就是：确保软件质量。 四、测试种类 1. 请列出你所知道的「软件测试种类」，至少五项。 2. 黑盒测试和白盒测试的常用测试方法有？举个例子？ 1）黑盒：等价类划分法、边界值法、因果图法和错误猜测法 2）白盒：逻辑覆盖法、循环测试路径选择、基本路径测试 例子：在一次输入多个条件的完整性查询中。利用等价类划分法和边界分析法，首先利用等价类划分法，制定一个或多个结果是OK的测试用例，然后确认多个NG的测试用例。然后再用边界值分析法，对结果分别是OK和NG的测试用例进行拓展和补充。 3. 简述黑盒测试和白盒测试的优缺点？ 1）黑盒 优点：a. 比较简单，不用了解内部代码的实现；b. 从用户的角度出发，很容易知道用户会用到哪些功能，会遇到什么问题；c. 与软件内部无关；d. 在做软件自动化测试时较方便。 缺点：代码覆盖率较低；自动化测试的复用性较低。 2）白盒 优点：代码覆盖率高，提高代码质量，发现隐藏的问题。 缺点：a. 测试基于代码，只能测试开发人员的对与不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；b. 系统庞大时，测试开销会很大；c. 测试有很多路径，不可能测试完所有的路径。 4. 单元测试的策略有哪些，主要内容有？ 逻辑覆盖，循环覆盖，代码走查，静态数据流分析，代码评审，桌前检查，同行评审 5. 白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是？ 语句覆盖，分支覆盖，条件覆盖，路径覆盖，分支条件覆盖。最高的是路径覆盖。 五、用例设计 1. 什么是测试用例，测试用例的基本要素？ 测试用例是为某个测试目标编写的一组输入、执行条件与预期结果，以便测试某个程序是否符合特定要求。 基本要素：测试索引，测试环境，测试输入，测试操作，预期结果，评价标准 2. 描述测试用例设计的完整过程 1）根据概要设计、需求文档、测试计划、测试方案细分出测试项 2）根据测试项，按照详细设计与测试方案中测试的覆盖率细分出测试子项 3）用测试设计方法（等价类划分，边界值，因果图等）编写测试用例 注意：用例一定要及时更新（补充与删除），要全面（考虑功能、性能、兼容性等） 3. 有个广告的纸杯子，请设计测试用例 基本功能测试（逻辑功能测试）。 1）硬度：是否达到设计标准。 装载能力:在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。 装载种类:开水(是否产生异味)、温水、冷水、冰水、咖啡。。 2）界面测试(UI 测试)。 看其形状、大小设计是否适合人方便拿起。 外观是否吸引人(广告嘛)，赏心悦目。 带广告的图案沾水受是否掉色、模糊。 3）易用性测试。 看其形状、大小设计是否适合人方便拿起。 残疾人士用此杯去喝水的容程度。 杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。 4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。 5）安全性测试。杯子所用的材料(包括纸基、涂层和广告颜料)是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。 6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。 7）对设计的改进建议。“如果是一次性杯子，能否标示已使用(比如变色)”和“杯子是否有使用者标贴(多人使用时防止混淆)”。 4. 一个身份证号码输入框，怎么设计用例? 校验身份证号的规则有效性（地址码、生日编码、顺序码、校验码） 检验15位身份证和18位身份正好可用 校验末尾是x的情况 校验不足15位、16-17位和18位的情况 如果是必输项，空白时是否有提示与流程是否正常进行 如果不是必输项，校验不输入时流程能否正常进行 检验非数字的情况，是否会有正确提示信息（包括大小写字母，汉字，特殊字符与标点符号） 5. 登陆功能怎么设计测试用例？ 具体需求:有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。 此题的考察目的：1. 了解需求(测什么都是从了解需求开始)；2. 是否有设计 Test Case 的能力；3. 是否熟悉各种测试方法； 4. 是否有丰富的 Web 测试经验;；5. 是否了解 Web 开发。 了解需求：1. 登陆界面是弹出窗口式的，还是直接在网页里面；2. 账号长度和密码的强度要求（比如需要多少位、大小写敏感、特殊字符混搭）；3. 界面美观是否有特殊要求（是否要进行UI测试） 用例设计： 1）功能测试：Function Test 输入正确的账号密码，点击提交按钮，验证是否能正确登陆（正常输入） 输入错误的账号密码，验证登陆会失败，与给出相应的错误提示（错误输入） 登陆成功后能否正确跳转到正确界面 账号和密码如果太长或太短，应该怎么处理（安全性，密码太短都有提示） 账号和密码中，有特殊字符（比如空格）和其他非英文情况（是否做了顾虑） 账号和密码前后都有空格的处理 输入密码时，大写键盘有提示 密码是否加密显示 什么都不输，点击提交按钮，看提示信息 记住账号功能 登陆失败后，不能记录密码的功能 牵涉到验证码的，还要考虑验证难度是否过大，刷新或者换一个的按钮是否好用 登陆页面中的注册、忘记密码、登出、用另一账号等链接是否正确 2）界面测试：UI Test 布局是否合理，2个Testbox和1个按钮是否对其 Testbox和按钮的长度，高度是否符合要求 界面的设计风格是否与UI的设计风格统一 界面的文字简洁易懂，没有错别字 3）性能测试 Performance Test 打开登陆页面，需要几秒 输入正确的账号密码后，登陆成功跳转到新页面，不超过5秒 4）安全性测试 Security Test 登陆成功后生成的 Cookie 是否有 HttpOnly（降低脚本盗取风险） 账号密码是否通过加密的方式，发送到Web服务器 账号和密码的验证，应该是用服务器端验证，而不只是用客户端的JS分析 账号和密码的输入框，应该屏蔽SQL注入攻击 账号和密码的输入框，要禁止输入脚本（防止XSS攻击） 错误登陆的次数使用限制（防止暴力破解） 考虑是否支持多用户在同一机器上登陆 考虑一用户在多台机器登陆 5）可用性测试 Usability Test 是否可以用全键盘操作，是否有快捷键 输入账号，密码后回车，是否可以登陆 输入框是否可以用Tab切换 6）兼容性测试 Compatibility Test 主流浏览器功能是否正常 不同系统平台是否工作正常（Macos pc） 移动设备是否工作正常 不同分辨率 7）本地化测试 Localization Test 不同语言环境，页面显示是否正确 8）辅助性测试 高对比度下是否显示正常（视力不好的人）","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS学习笔记-03","slug":"JS学习笔记-03","date":"2020-10-25T10:15:58.000Z","updated":"2020-11-08T04:37:25.818Z","comments":true,"path":"2020/10/25/JS学习笔记-03/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/","excerpt":"函数 定义函数 123456789//第一种function abs(x) &#123; &#125;//第二种var abs = function(x)&#123;&#125;/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/","text":"函数 定义函数 123456789//第一种function abs(x) &#123; &#125;//第二种var abs = function(x)&#123;&#125;/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/ 调用 调用函数时，按顺序传入参数。 JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数 123abs(10, &#x27;blablabla&#x27;); // 返回10abs(9, &#x27;haha&#x27;, &#x27;hehe&#x27;, null); // 返回9abs(); // 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免 arguments 获得调用者的所有参数，但不是一个Array 是一个关键字 只在函数内部起作用 1234567891011121314function foo(x) &#123; console.log(&#x27;x = &#x27; + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log(&#x27;arg &#x27; + i + &#x27; = &#x27; + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30);/*x = 10arg 0 = 10arg 1 = 20arg 2 = 308*/ 要善于利用arguments判断传入参数多少的作用 rest参数 是ES6新增的特性，形式为：…变量名 作用：获取函数多余的参数 123456789101112131415161718//获取a，b之外的参数例子：function foo(a, b, ...rest) &#123; console.log(&#x27;a = &#x27; + a); console.log(&#x27;b = &#x27; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined 因为b在参数中被定义了，要直接输出// Array [] 练习 用rest参数编写一个add()函数，用于接收任意个参数并返回她们的和。 12345678&#x27;use strict&#x27;;function sum(...rest)&#123; let sum=0; rest.forEach(function(elemnt)&#123; sum += element; &#125;); return sum;&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。 1234567891011121314&#x27;use strict&#x27;;function area_of_circle(r,pi)&#123; var area; if(arguments===1)&#123; area=Math.pow(r,2)*3.14; &#125;else&#123; area=Math.pow(r,2)*3.1416; &#125;&#125;//解构赋值function area_of_circle(r, pi)&#123; var[r,pi=3.14]=arguments; return pi*r*r;&#125; 变量作用域和解构赋值 变量提升 js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。 注意：只是变量的声明，并不是赋值。 块级作用域 ES6引入了新关键字 let，用let代替var可以声明一个块级作用域的变量。 12345678910&#x27;use strict&#x27;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 常量 ES6引入了一个const关键字来定义常量 12345&#x27;use strict&#x27;;const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 解构赋值 此知识点小点比较多，详细请看廖雪峰的官网 在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1var [x, y, z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;]; 如果数组本身还有嵌套，只需要嵌套和层次对齐即可。 1var arr[x,[y,z]] = [1,[2,3]]; 从对象中取出其中几个属性的值，也可以用解构赋值 123456789101112131415161718var person=&#123; name: &#x27;tang&#x27;, tel: &#x27;12345&#x27;, age: 20, password: &#x27;S-12345&#x27;, address:&#123; city:&#x27;beijing&#x27;, street:No.1 Road, zipcode:&#x27;10000&#x27; &#125;&#125;;//把person的name和tel取出给var定义的name,telvar &#123;name,tel&#125;=person;console.log(&#x27;name=&#x27;+name+&#x27;,&#x27;+&#x27;tel=&#x27;+tel);/*name=tangtel=12345*/ 如果要对嵌套对象address里面的值进行赋值，也能用解构赋值： 1var &#123;name,address:&#123;city,street&#125;&#125;=person; 如果要使用的变量名和属性名不一致，可以用下面的语法获取： 123var &#123;name,password:id&#125;=person;//这里就是把password「属性」赋值给了变量id//注意：是把password这个属性赋值给了id，所以password不是一个变量 有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把&#123;开头的语句做块处理，= 不再合法。 123var x,y;&#123;x,y&#125;=&#123;x:100,y:300&#125;;//解决办法，用()括起来 方法 this关键字 this是一个特殊变量，始终指向当前对象。下面的例子就是this指向的对象是小明。 12345678var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:function()&#123; var y = new Date().getFullYear(); return y-this.birth; //当前对象为xiaoming &#125;&#125; 但想要把age方法里面的内容拆开写，要怎么办呢？ 123456789101112131415//写一个getAge()方法function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;//编写小明对象var xiaoming=&#123; ame:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;//情况一：xiaoming.age();//正常返回25//情况二：getAge; //NaN 为什么情况二返回的是NaN？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。 想要指向正确，必须用obj.xxx()的形式调用，也就是「对象.方法名」 that 我们先看看下面： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，this指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。 修复方法：使用that变量，在方法内部一开始就首先捕获this： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; var that = this; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age();//25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。 apply 可以指定函数的this指向哪个对象，apply(this要指定的对象 , Array函数本身的参数) 1234567891011function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;xiaoming.getAge();//25getAge.apply(xiaoming,[]); apply()把参数打包成Array再传入；call()把参数按顺序传入。二者功能类似。 例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下： 12Math.max.apply(null,[3,4,5]);Math.max.call(null,3,4,5); 高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。 所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。 1234567&#x27;use strict&#x27;;function add(x, y, f) &#123; //add函数的参数为x,y,f，而参数f是一个函数 return f(x) + f(y);&#125;var x = add(-5, 6, Math.abs); console.log(x);// 11 高阶函数将在下一篇博文详解","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-02","slug":"JS学习笔记-02","date":"2020-10-25T10:11:47.000Z","updated":"2020-11-08T04:37:44.247Z","comments":true,"path":"2020/10/25/JS学习笔记-02/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/","excerpt":"循环 for for循环三个条件可省略，但如果无退出条件，则死循环。退出：break 12345678var x=0;for(;;)&#123; if(x&gt;100)&#123; break; &#125; x++;&#125;","text":"循环 for for循环三个条件可省略，但如果无退出条件，则死循环。退出：break 12345678var x=0;for(;;)&#123; if(x&gt;100)&#123; break; &#125; x++;&#125; for…in 用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三） 1234567891011121314151617181920212223//例一var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; console.log(key); //&#x27;name&#x27; &#x27;age&#x27; &#x27;school&#x27;&#125;//例二var arr=[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;];for(var i in arr)&#123; console.log(i); //‘0’，‘1’，‘2‘ /*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/ /*请注意，for ... in对Array的循环得到的是String而不是Number。*/&#125;//例三var arr=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];for(var i in arr)&#123; console.log(arr[i]); //&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;&#125; 要过滤继承属性，使用day01学的hasOwnProperty()方法实现。例如： ps：或者使用for...of，这也是为什么设计for...of的原因之一。 12345678910var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; if(o.hasOwnProperty(key))&#123; console.log(key); //不然会输出toString属性 &#125;&#125; hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性key」 练习 请利用循环遍历数组中的每个名字 123456789101112&#x27;use strict&#x27;; var arr = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;];//法1for(var key in arr)&#123; console.log(arr[key]);&#125;//法2var i=arr.length-1;while(i&gt;=0)&#123; console.log(arr[i]) i--;&#125; for…of for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。 for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象 参考 张鑫旭大佬的文章 Map和Set Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。 Map Map是一组「键值对」的结构，具有极快的查找速度。例： 123var m new Map([&#x27;Micheal&#x27;,95],[&#x27;Bob&#x27;,88],[&#x27;Tracy&#x27;,93])m.get(&#x27;Micheal&#x27;); //返回的是95！//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字 其他操作如下： 12345var m= new Map(); //新建空Mapm.set(&#x27;tang&#x27;,100); //添加新 key-valuem.set(&#x27;tang&#x27;,1); //覆盖上面的100，返回1m.has(&#x27;tang&#x27;); //返回truem.delete(&#x27;tang&#x27;); Set 与Map不同，Set只存「key」，不存「value」。key不能重复。 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, &#x27;3&#x27;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 注意数字3和字符串'3'是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;s.add(4);s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s &#x3D; new Set([1, 2, 3]);s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;s.delete(3);s; &#x2F;&#x2F; Set &#123;1, 2&#125; iterable &amp; for…of Array可以下标循环，但遍历Map 和Set就无法使用下标。为了统一集合类型，ES6引入了iterable类型，Array 、Map和Set 都属于iterable类型。 具有iterable类型的「集合」，可以通过for...of循环来遍历","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-01","slug":"JS学习笔记-01","date":"2020-10-25T10:05:55.000Z","updated":"2020-11-19T03:21:08.503Z","comments":true,"path":"2020/10/25/JS学习笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/","excerpt":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name","text":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name 变量 只能用var申明一次。没用var申明的变量：全局变量 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 strict模式 'use strict';强制通过var申明 二、字符串 多行字符串 由于多行字符串用\\n写起来费事，最新的ES6标准新增了如下方式表示： 123&#96;这是一个多行字符串&#96;; 模板字符串 很多变量连接时 1234var name &#x3D; &#39;小明&#39;;var age &#x3D; 20;var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;alert(message); 三、数组 indexOf() 搜索指定元素的位置 12345var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2 slice() 截取Array的部分元素，返回一个新的Array 123var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] slice()的起止参数包括开始索引，不包括结束索引 如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组 1234var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];var aCopy &#x3D; arr.slice();aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false push() 和 pop() push()插入数组尾部 pop()删除～ unshift() 和 shift() unshift()插入 头部第一 shift()删除头部第一 reverse() 数组的反转 splice() 修改数组的万能方法，格式为：从哪里开始，删除多少个，添加什么 12345678910var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只删除,不添加:arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只添加,不删除:arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;] concat() 连接两个数组。没有修改原数组，只是生成新数组 join() 把array里面的元素，用指定的字符连起来 123var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];arr.join(&#39;-&#39;);arr;返回的就是&#39;a-b&#39; ps：如果Array的元素不是字符串，则自动转化再拼接 三、对象 用[‘x’]访问（少用） 属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用.访问 1234var xiaohong &#x3D; &#123; name: &#39;小红&#39;, &#39;middle-school&#39;: &#39;No.1 Middle School&#39;&#125;; 123xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;xiaohong.name; &#x2F;&#x2F; &#39;小红&#39; ps：写代码尽量规范，尽量用.访问 由于对象是动态类型，因此可以随便给对象添加或修改属性 123456789101112var xiaoming&#x3D;&#123; name: &#39;小明&#39;&#125;;xiaoming.age; &#x2F;&#x2F;undefinedxiaoming.age&#x3D;18; &#x2F;&#x2F;添加了age属性delete xiaoming.age; &#x2F;&#x2F;删除name属性xiaoming.age; &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefineddelete xiaoming.name; &#x2F;&#x2F;删除namexiaoming.name; &#x2F;&#x2F;undefineddelete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined 检测属性存在性 用in操作符，返回布尔值 123456var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990,&#125;;&#x27;name&#x27; in xiaoming; // true&#x27;grade&#x27; in xiaoming; // false 注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用hasOwnProperty() 12345var xiaoming=&#123; name=&quot;小明&quot;;&#125;xiaoming.hasOwnProperty(&#x27;name&#x27;); //truexiaoming.hasOwnProperty(&#x27;toString&#x27;); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"正则表达式-01","slug":"正则表达式-01","date":"2020-10-25T09:57:31.000Z","updated":"2020-11-19T03:55:20.987Z","comments":true,"path":"2020/10/25/正则表达式-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/","excerpt":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符：","text":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符： 复杂例子：\\d&#123;3&#125;\\s+\\d&#123;3,8&#125;。 我们来从左到右解读一下： \\d&#123;3&#125;表示匹配3个数字，例如'010'； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配' '，'\\t\\t'等； \\d&#123;3,8&#125;表示3-8个数字，例如'1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\\'转义，所以，上面的正则是\\d&#123;3&#125;\\-\\d&#123;3,8&#125;。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线与$组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 使用 1234var re1=/ABC\\-001/var re2=new RegExp(&#x27;ABC\\\\-001&#x27;) //字符串的转义问题，字符串的两个\\\\实际上是一个\\。re1; // /ABC\\-001/re2; // /ABC\\-001/ 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 1&#39;a b c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;] 嗯，无法识别连续的空格，用正则表达式试试： 1&#39;a b c&#39;.split(&#x2F;\\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 无论多少个空格都可以正常分割。加入,试试： 1&#39;a,b, c d&#39;.split(&#x2F;[\\s\\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 再加入;试试： 1&#39;a,b;; c d&#39;.split(&#x2F;[\\s\\,\\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 用()表示的就是要提取的分组（Group）。比如： ^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re &#x3D; &#x2F;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x2F;;re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec(&#x27;19:05:30&#x27;); // [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： 12var re = /^(\\d+?)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 123var r1 = /test/g;// 等价于:var r2 = new RegExp(&#x27;test&#x27;, &#x27;g&#x27;); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 1234567891011121314151617var s = &#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;;var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // [&#x27;JavaScript&#x27;]re.lastIndex; // 10re.exec(s); // [&#x27;VBScript&#x27;]re.lastIndex; // 20re.exec(s); // [&#x27;JScript&#x27;]re.lastIndex; // 29re.exec(s); // [&#x27;ECMAScript&#x27;]re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"软件测试基础理论","slug":"软件测试笔记-01","date":"2020-10-20T14:24:10.000Z","updated":"2020-11-08T04:38:53.951Z","comments":true,"path":"2020/10/20/软件测试笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/","excerpt":"软件测试的分类 方法 黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「需求规格说明书」，检查程序的功能是否符合它的功能说明。 方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等 错误推测法：基于经验和直觉，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格…… 因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的联系、组合情况。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。因果图最终产生的是判定表。 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。 主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等","text":"软件测试的分类 方法 黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「需求规格说明书」，检查程序的功能是否符合它的功能说明。 方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等 错误推测法：基于经验和直觉，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格…… 因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的联系、组合情况。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。因果图最终产生的是判定表。 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。 主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等 阶段 单元测试： 重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。 单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态数据流分析 单元测试方法：控制流测试、数据流测试、排错测试、分域测试 集成测试：重点测试「接口」 策略：自顶向下和自底向上 应关注： 系统测试 测试方法有：功能、安全、性能、兼容性、易用性、稳定性…… 验收测试 Alpha：用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。总是，A测试是在受控的环境下进行的。 Beta：与上相对。 方向 功能测试：看功能是否正常。 黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做） 性能测试：判断程序能做多好（与时间挂钩） 压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。 负载测试： 定义：数据在超负荷环境下运行，测试软件系统是否能够承担。这种超负荷主要指多并发用户。 理解：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟） 方法：认为生成大量数据，并利用工具模拟频繁并发访问 以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。 并发测试：一瞬间同一个程序在做同一件事情 从用户角度看性能：软件对用户操作的响应时间 系统管理员角度看： 系统的响应时间 系统运行服务器的状态，如cpu利用情况、内润使用情况等 系统是否能够实现拓展 系统支持多少用户访问 系统性能的瓶颈在哪里 系统是否支持7*24小时的业务访问 安全测试（了解）：防止攻击，例如ddos等 兼容性 状态 根据软件的状态划分的 静态：不会运行的软件，通过白盒测试看代码 动态：把软件运行起来测试 其他 冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试），仅对基本功能测试，保证软件跑得起来。 回归测试：回归bug，bug修改了，有没有检查。 测试流程 4个阶段：测试需求分析阶段、测试计划阶段、执行测试阶段、测试评估阶段。 需求分析阶段 主要是学习业务流程，提取功能点，把小功能提取出来，做成树状图。 阅读需求文档：产品经理用文档描述 查看产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。） 测试设计阶段 前三个由产品经理或者组长写，方法是：5W1H 测试计划：时间、人、资源的分配 测试方案 每个测试内容如何展开 采用什么测试计划 哪些内容先测 测试策略 哪些内容先测后测（先测功能还是兼容？） 开始和结束的标准是什么？ 测试用例（重点！重中之重！） 包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。 用例编号：唯一的 用例名称：言简意赅 前置条件：在执行用例前，软件必须要满足的条件 优先级：执行用例的时间要求紧急的等级 重要级：被测功能在软件中的重要等级 要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ） 测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方 测试执行阶段 搭建环境，执行冒烟测试，然后正式测试。 测试评估阶段 出测试报告，确认是否可以上线。 测试方法 等价类 通过少部分的值，代表大部分的情况。 有效等价类 满足条件的：0.01，0.02，200，199.99 无效等价类 不满足条件的：0，200.01 边界法 0，负数，+1，-1，本身，整数，非整数，字符 研发管理模型 作用：在开发中会经历很多过程，模型可以知道不同的工作流程。 瀑布流 从上往下，不可逆不可返回的流程。 V字型 左边是开发做的，右边是测试做的，二者一一对照。 w字型 测试与开发同步了。 软件的生命周期 是指软件的产生到报废的整个过程。包括可行性分析与项目计划，需求分析，概要设计和详细设计，编码，调试，维护七个阶段。 软件测试的生命周期 是指从测试项目计划建立到BUG提交的整个「测试过程」，包括测试计划，测试需求分析，测试用例编写，测试用例执行，BUG提交。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-13T03:51:26.002Z","updated":"2020-11-08T04:39:03.719Z","comments":true,"path":"2020/10/13/hello-world/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/categories/Python/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"},{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/categories/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"},{"name":"网络","slug":"网络","permalink":"https://blog.tangspoon.cn/categories/%E7%BD%91%E7%BB%9C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.tangspoon.cn/tags/Hexo/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"},{"name":"测试点","slug":"测试点","permalink":"https://blog.tangspoon.cn/tags/%E6%B5%8B%E8%AF%95%E7%82%B9/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"},{"name":"网络基础","slug":"网络基础","permalink":"https://blog.tangspoon.cn/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}