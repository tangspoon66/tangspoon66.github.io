{"meta":{"title":"tang's blog","subtitle":"判断得与失的时限大概要拉长一些，或许是一辈子","description":"技术导向，完美主义，实用主义","author":"tang","url":"https://blog.tangspoon.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-13T06:57:39.553Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"/404.html","permalink":"https://blog.tangspoon.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-13T06:57:39.565Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"about/index.html","permalink":"https://blog.tangspoon.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2020-11-08T05:08:12.187Z","updated":"2020-11-08T05:08:12.182Z","comments":false,"path":"tags/index.html","permalink":"https://blog.tangspoon.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-16T15:14:35.417Z","updated":"2020-11-08T05:08:56.575Z","comments":false,"path":"categories/index.html","permalink":"https://blog.tangspoon.cn/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2020-11-16T14:38:18.825Z","updated":"2020-11-16T14:38:18.818Z","comments":false,"path":"archives/index.html","permalink":"https://blog.tangspoon.cn/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"智能闹钟（三）| 使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲","slug":"智能闹钟（三）| 使用「网易云音乐NodeJS版API接口」获取每日推荐歌曲","date":"2020-12-22T07:15:59.000Z","updated":"2020-12-23T13:07:34.180Z","comments":true,"path":"2020/12/22/智能闹钟（三）| 使用「网易云音乐NodeJS版API接口」获取每日推荐歌曲/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/22/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%89%EF%BC%89|%20%E4%BD%BF%E7%94%A8%E3%80%8C%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90NodeJS%E7%89%88API%E6%8E%A5%E5%8F%A3%E3%80%8D%E8%8E%B7%E5%8F%96%E6%AF%8F%E6%97%A5%E6%8E%A8%E8%8D%90%E6%AD%8C%E6%9B%B2/","excerpt":"","text":"准备 使用前请仔细查看里面的调用前须知 进行简单的需求分析： 一、搭建API 我个人选择了把接口搭建在VPS中，7x24x365在线，等调试好语音识别模块后再部署到树莓派上。但如果你的是是国外的服务器，请仔细阅读一下文档内的「调用前须知」，里面有提示相关的注意事项。当然，如果仅仅学习API的调用的话，我们可以搭建在本机电脑中。 注意⚠️：以下所有步骤均默认在管理员（root）用户下进行 1. 安装 1234git clone https:&#x2F;&#x2F;github.com&#x2F;Binaryify&#x2F;NeteaseCloudMusicApi.git# 进入到项目文件内cd xxx&#x2F;xxx&#x2F;NeteaseCloudMusicApi npm install 2. 运行 （1）在「VPS」运行 要想API 7x24x365 在线，让项目保持后台运行就可以。我这里运用了比较简单的方法：screen命令。 123456cd NeteaseCloudMusicApi# 新建一个名为NeteaseCloud的screenscreen -S NeteaseCloud# 在新生成的窗口中运行APInode app.js# 然后就可以放心把窗口关掉了 在关掉后我们尝试访问http://VPS的ip:3000。如无意外，我们会看到： 那么我们如何恢复screen呢？ 注意⚠️：回复screen一定要在新建screen的用户下进行。我上面是进入到了root中 12345sudo -i# 查看所有screenscreen -ls # 找到我们的NeteaseCloudscreen -r screen的id 想要关闭screen，我们可以看到上图有提示：1 Socket in /var/run/screen/S-root，我们进入到这个文件夹删除相应的文件，就可以关闭screen了。 （2）在「本地电脑」运行 123# 想要运行项目，仍然要进入项目文件夹中cd NeteaseCloudMusicApinode app.js （3）「修改端口」运行 服务器启动默认端口为 3000，若不想使用 3000 端口，可使用以下命令： 1234# Mac&#x2F;LinuxPORT&#x3D;4000 node app.js# windowsset PORT&#x3D;4000 &amp;&amp; node app.js 二、登陆 文档里面提供了手机、邮箱两种登陆方式，但使用邮箱登陆会返回402错误码，我们直接使用手机登陆。 接口地址 : /login/cellphone 调用例子 : /login/cellphone?phone=xxx&amp;password=yyy 要注意：下面的大部分接口都要登陆成功后才能使用，而登陆接口response信息中会有带有cookie，所以我们要使用session()来保持登陆状态。 12345678910111213141516171819# -*- coding: utf-8 -*import requestsurl = &#x27;http://localhost:3000&#x27;phone = &#x27;xxxx&#x27;pwd = &#x27;xxxx&#x27;s = requests.session()# 登陆def login(): login_url = url + &#x27;/login/cellphone&#x27; login = s.get(login_url, data=&#123;&#x27;phone&#x27;: phone, &#x27;password&#x27;: pwd&#125;) try: if login.status_code is 200: print(&#x27;恭喜！登陆成功！&#x27;) except Exception as e: print(&#x27;Exception&#x27;,e) 三、获取所有每日推荐歌曲信息 使用该接口需要完成「登陆」后才能使用。 接口地址 : /recommend/songs 调用例子 : /recommend/songs 我们尝试使用postman请求接口，response信息如下： 仔细看会发现会发现，response中是没有歌曲播放url的！那怎么播放歌曲呢？ 别急，我们仔细思考一下，唯一能识别出一首歌的标志只有id，那会不会有其他接口可以通过id获得可流媒体播放的url呢？翻遍了文档终于找到相关信息。（我觉得作者应该把该接口放在更前面的位置） 我们使用postman请求，观察response数据结构。然后开始编码通过id获取播放url，代码如下： 123456789101112131415161718192021# 获取每日推荐歌曲iddef getSongs_id(): # 获取每日推荐歌曲字典 dailySongs_url = url + &#x27;/recommend/songs&#x27; dailySongs_object = s.get(dailySongs_url) songs_dict = dailySongs_object.json() # 0~31首 for list_index in range(0, 32): song_id.append(songs_dict[&#x27;data&#x27;][&#x27;dailySongs&#x27;][list_index][&#x27;id&#x27;]) return song_id# 获取播放urldef getSongs_url(): getSongs_url = url + &#x27;/song/url&#x27; # 传入song_id[]作为data song_id = getSongs_id() song_url_object = s.post(getSongs_url, data=&#123;&#x27;id&#x27;:song_id&#125;) song_url_dict = song_url_object.json() for i in range(0, 32): songs_url.append(song_url_dict[&#x27;data&#x27;][i][&#x27;url&#x27;]) return songs_url 四、播放音乐 参考了网络资料，在Linux中播放音乐有几种选择，用得比较多的是pygame和mplayer。但不知什么原因我树莓派一直装不了pygame，所以最终选择了mplayer作为我的播放器。 基本使用方式很简单： 1mplayer file&#x2F;url 但要如何在python脚本中调用mplayer呢？使用os.system('cmd' %s)或Subprocess.Popen('cmd')，具体区别可以参考这篇文章，一句话说完就是：前者比较老旧，但会显示cmd命令执行的信息；后者强大，支持多种参数和模式，但没有输出信息。 在整个项目中我们两个模块都会用到，在播放音乐部分我们使用前者，后面「渐入渐出部分」我们再使用后者。 先尝试播放日推第一首歌。 1os.system(&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27; % songs_url[0]) 从左到右解析一下代码：单引号''里的内容就是os.system('cmd')中的cmd，&quot;%s&quot;是str类型的参数，输出&gt;（重定向）到/dev/null 2&gt;&amp;1文件，该文件会像黑洞一样吞噬所有的输入，同时也不会获得任何输出，单引号''部分的代码意思是mplayer播放%s的url，且不输出信息。更详细的意思请看这里。后面的% 和 song_url[0]中间是有个空格的，这个就是传到&quot;%s&quot;的参数。 要播放32首歌曲，可以写个for循环，重复执行mplayer的播放操作就可以。 这部分代码整合到了下方的「优化播放流程」当中。 至此，文章一开头的需求分析全部模块已经基本完成，但仍有优化空间 五、项目优化整合 我们做项目应该更贴近生活考虑，带给用户更好的体验，所以还得在细节中下点功夫。 1. 优化播放流程 早上醒来意识是不清醒的，第一时间播放「天气」肯定听不清楚，而且完全没让人有个好心情啊！所以「天气播报」应该往后捎捎。由此大概确定**项目的完整播放流程为：**先播放一到两首歌，然后「天气播报」，然后再播放剩下的歌曲。 同时，我们大概率会在第一次播放时听不清楚具体温度，所以我们应该做两次天气的播报。 注意⚠️：下方代码line 12播放天气文件的py脚本，要**填写绝对路径！绝对路径！**不然无法播放天气！ 12345678910111213141516171819# 播放模块def playmusic(): # getSongs_url()函数在上面以实现 songs_url = getSongs_url() print(&#x27;开始播放音乐&#x27;) try: print(&#x27;第一首歌&#x27;) # 先播放第一首 os.system(&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27; % songs_url[0]) # 播放两次天气 print(&#x27;播放天气&#x27;) for i in range(0,2) os.system(&#x27;python /tmp/clock/TextToVoice.py&#x27;) # 开始随机播放2～32首 for i in range(1, 32): # print(&#x27;播放第&#x27; + str(i) + &#x27;首&#x27;) os.system(&#x27;mplayer &quot;%s&quot; &gt; /dev/null 2&gt;&amp;1&#x27; % songs_url[i]) except Exception as e: print(&#x27;Exception&#x27;, e) 2. 渐入播放 如果播放的音乐一开始非常大声，我们很容易受惊。 所以在播放第一首歌时，渐入。我们可以有两种设计方式，第一种是通过mplayer的slave模式修改，另一种通过amixer修改Linux系统的声音。这里我选择后者，相对来说会更简单。 123# amxier调音量基本使用amixer sset 声卡名字(str类型) volume音量(volume%)# 例如：amixer sset Headphone 20% 思路：使用一个for循环，先从一个低音量开始，在range()里面每次递增%1，在每一次循环（递增）中，都会有0.3秒的延迟，这样就实现了较为顺滑的渐入操作。 在python里面控制amixer模块，这次我们尝试使用subprocess.Popen(cmd) 123456789101112import subprocessimport timedef slowUp(): # %0 and %100 volume = 65 # 每次增加%1，一直从 %65 ～ %90 for volume in range(65, 100, 1): # 延迟 0.3 秒递增 time.sleep(0.3) command = [&quot;amixer&quot;, &quot;sset&quot;, &quot;Headphone&quot;, &quot;&#123;&#125;%&quot;.format(volume)] subprocess.Popen(command) **但有个很重要的问题：**我们要怎么使用这个渐入函数呢？直接嵌入到播放第一首歌前面吗？肯定不对的，因为程序会先执行完slowUp()函数完成了音量的递增之后，再开始播放音乐。这样是毫无意义的。 有两个解决办法。 第一个是多线程，但对多线程不太熟悉，用不好可能很容易崩，后面认真学习后，会再进行代码重构。 第二种就比较机灵点：设置两个时间一样的crontab任务，一个执行播放音乐的py脚本，另一个执行渐入渐入的脚本。也就是把多线程这件事交给了crontab！ 夸夸自己，真是太机智了！ 六、END&amp;总结 这篇文章只是介绍了如何使用「网易云音乐NodeJS版API接口」播放每日推荐歌曲，看起来顺风顺水，实际上遇到的坑真的数不过来。但我们一定要**「善于思考，善于记录」**，坚持每天输出一些内容，到最后就掌握越来越多技能。 下一篇文章，详细讲一下部署项目的部署问题。源代码也将整合。 相关文章 智能闹钟（一）｜macOS 入门使用树莓派 3B+ 智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报","categories":[{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"},{"name":"Python","slug":"智能闹钟/Python","permalink":"https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"},{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/tags/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"}]},{"title":"树莓派开启crontab日志","slug":"树莓派开启crontab日志","date":"2020-12-22T04:04:38.000Z","updated":"2020-12-23T12:54:53.045Z","comments":true,"path":"2020/12/22/树莓派开启crontab日志/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/","excerpt":"","text":"今天的树莓派闹钟情况有点问题，想查看一下crontab任务完成情况，结果找了半天找不到log。原来是树莓派系统默认禁止了生成日志文件。解决办法也很简单。 1sudo vim &#x2F;etc&#x2F;rsyslog.conf 在文件中找到： 1#cron.* &#x2F;var&#x2F;log&#x2F;cron.log 把#去掉，然后’esc’，输入:wq 输入一下代码重新启动日志服务 1sudo service rsyslog restart 执行一个crontab任务，再到/var/log/cron.log就可以查看到执行情况 参考资料： https://my.oschina.net/u/4341499/blog/4280350","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[]},{"title":"格式化时间","slug":"格式化时间","date":"2020-12-21T10:17:43.000Z","updated":"2020-12-21T11:30:48.460Z","comments":true,"path":"2020/12/21/格式化时间/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/21/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%B6%E9%97%B4/","excerpt":"在和风天气API获取日落时间时，没仔细看清楚官方文档，绕了一个大圈。但是也学到了时间格式化的一些操作，在这里继续记录下来。","text":"在和风天气API获取日落时间时，没仔细看清楚官方文档，绕了一个大圈。但是也学到了时间格式化的一些操作，在这里继续记录下来。 一、获取系统日期并格式化 因为使用sunmoon接口https://devapi.qweather.com/v7/astronomy/sunmoon?需要使用当天日期，格式例如20201218，Linux的时间显示格式为Mon 21 Dec 18:39:36 CST 2020，因此我们需要把系统格式化。 可以使用Python的datetime模块，使用方式如下。 12345678910def formatTime(): # 实例化对象 dt = datetime.now() year = dt.year month = dt.month day = dt.day # 组合时间 today = str(year) + str(month) + str(day) # print(&#x27;today: &#x27;,today) return today 二、发送日落请求 获取了格式化的date之后，我们就可以获取日落时间了。过程如下。 1234567891011121314def getSunsetTime(): sunset_url = &#x27;https://devapi.qweather.com/v7/astronomy/sunmoon?&#x27; params = &#123; &#x27;location&#x27;: &#x27;101280101&#x27;, &#x27;key&#x27;: &#x27;6dee7771746148fbbee9cedeb9c1ffc4&#x27;, &#x27;date&#x27;: date, &#x27;gzip&#x27;: &#x27;y&#x27; &#125; sun_html = requests.get(sunset_url, params) sun_content = sun_html.json() sunset_time = sun_content[&#x27;sunset&#x27;] print(&#x27;sunset_time:&#x27;, sunset_time) print(&#x27;sunset_time is: &#x27;, type(sunset_time)) return sunset_time 以下红框是我们需要的时间，在使用type()验证了日落时间是str类型后，我们可以通过正则表达式来提取我们需要的17:47 三、正则表达式提取做需要的字符串 使用re模块下的findall配合正则表达式 1234567# 分离日落时间，获得几点几分def getSunsetHM(): # 使用正则表达式 sunsetime = getSunsetTime() sunsetHM = (re.findall(r&quot;T(.+?)\\+&quot;, sunsetime)) print(sunsetHM) return sunsetHM 提取结果显示 参考资料： https://blog.csdn.net/liao392781/article/details/80181088 https://blog.csdn.net/shomy_liu/article/details/44141483","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气播报","slug":"智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报","date":"2020-12-21T09:58:25.000Z","updated":"2020-12-23T12:55:44.396Z","comments":true,"path":"2020/12/21/智能闹钟（二）｜使用「和风天气、百度语音合成」API进行天气的播报/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/21/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BD%9C%E4%BD%BF%E7%94%A8%E3%80%8C%E5%92%8C%E9%A3%8E%E5%A4%A9%E6%B0%94%E3%80%81%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E3%80%8DAPI%E8%BF%9B%E8%A1%8C%E5%A4%A9%E6%B0%94%E7%9A%84%E6%92%AD%E6%8A%A5/","excerpt":"","text":"每日天气提醒在我的生活中时非常有必要的，对我每日的出行会有巨大帮助。因此，智能闹钟项目要考虑加入天气播报功能。该功能可以使用免费的「和风天气」提供的api来实现。 一、需求分析 首先我们得明白需求： 实况天气：参考出门穿什么衣服、是否需要带伞 对应「实况天气」开发版接口：https://devapi.qweather.com/v7/weather/now? 需要获得的数据如下： 每天最低、最高温度：参考整体温度 日落时间：希望每天都可以看到好看的晚霞 2、3需求对应「3天预报」开发版接口：https://devapi.qweather.com/v7/weather/3d? 需要获得的数据如下： ⚠️注意：日落时间可以用「天气预报」、「太阳和月亮」两个接口获得，但使用前者非常简单。 二、功能实现 1. 获取实况温度与实况状态 1234567891011121314151617def getNowWeather(): # 开发版接口地址 url = &#x27;https://devapi.qweather.com/v7/weather/now?&#x27; # 接口参数 params = &#123; # 你的城市id &#x27;location&#x27;: &#x27;xxx&#x27;, # 和风天气key &#x27;key&#x27;: &#x27;xxx&#x27;, # 使用gzip可较少延迟 &#x27;gzip&#x27;: &#x27;y&#x27; &#125; html = requests.get(url, params) content = html.json() now_temp = content[&#x27;now&#x27;][&#x27;temp&#x27;] now_text = content[&#x27;now&#x27;][&#x27;text&#x27;] return now_temp, now_text 2. 最低、最高温度、日落时间 我们使用postman对调用接口，对response分析，可以获得第一天的数据 12345678910def get3d(): url = &#x27;https://devapi.qweather.com/v7/weather/3d?&#x27; # params与getNowWeather()的一样 html = requests.get(url, params) html_content = html.json() tempMax = html_content[&#x27;daily&#x27;][0][&#x27;tempMax&#x27;] tempMin = html_content[&#x27;daily&#x27;][0][&#x27;tempMin&#x27;] sunsetTime = html_content[&#x27;daily&#x27;][0][&#x27;sunset&#x27;] return tempMax, tempMin, sunsetTime 三、总结 在开始做一个项目模块前，一定要做好需求分析，认真阅读开发者文档，了解清楚需求都要用到哪些接口/工具，不然用错接口就会浪费很多很多时间。就像API文档里面的「天气预报」和「太阳和月亮」接口都可以获得日落时间，但是用前者可以简单上十倍！ 一开始的我直冲太阳和月亮，还写了一大堆格式化时间的函数，多此一举。 其次，功能的实现还是比较简单的，但是其实应该加入code≠200的报错情况，增强程序的健壮性。 另外，还需要加入： 当天温度最高气温还是 &lt; 15 时，提醒穿衣 实况天气为“雨”的时候，提醒带伞 具体需要结合百度语音合成来使用，下一篇文章会记录结合过程。 项目源代码会在整个「智能闹钟」项目完成后上传到Github。","categories":[{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"},{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/tags/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"}]},{"title":"PyCharm远程连接树莓派同步编辑py文件","slug":"PyCharm远程连接树莓派同步编辑py文件","date":"2020-12-20T03:54:24.000Z","updated":"2020-12-20T04:00:32.005Z","comments":true,"path":"2020/12/20/PyCharm远程连接树莓派同步编辑py文件/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/20/PyCharm%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E5%90%8C%E6%AD%A5%E7%BC%96%E8%BE%91py%E6%96%87%E4%BB%B6/","excerpt":"直接在树莓派上面调试python脚本非常麻烦，作出一次修改就得删除然后上传重新覆盖，效率太低了。其实大部分编译器都会有远程连接服务器编辑代码的功能，PyCharm也不例外。 网上大多数都是在创建project时添加remote，这里我们说更实用的场景：直接在project创建好后，再添加remote。","text":"直接在树莓派上面调试python脚本非常麻烦，作出一次修改就得删除然后上传重新覆盖，效率太低了。其实大部分编译器都会有远程连接服务器编辑代码的功能，PyCharm也不例外。 网上大多数都是在创建project时添加remote，这里我们说更实用的场景：直接在project创建好后，再添加remote。 我们打开project的Preferences（macOS的快捷键是commond+,），然后在左上角的搜索框输入interpreter（解释器），然后如下图，点击Add。 然后左侧栏选择SSH Interpreter，在右方填写好树莓派的ip、用户名，然后点击next。然后填写密码，记得Save password 接下来，Interpreter处要选择好树莓派的python版本，默认选择路径是/usr/bin/python，这个路径其实就是我们执行python这个命令时使用的python，此路径默认2.7。2020年了我们当然要使用py3啦，所以我们要提前把/usr/bin/pyhton这个路径的python版本改为python3的。 剩下的我们就按照下图操作，然后点击Finish即可。 然后我们在项目中新建一个test.py文件，里面输入print('test')测试一下。可以看到，是已经自动上传到树莓派中了。 然后我们直接在FinalShell的的文件查看器中查看是否有test.py文件 Done！","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"}]},{"title":"智能闹钟（一）｜macOS入门使用树莓派3B+","slug":"智能闹钟（一）｜macOS入门使用树莓派3B","date":"2020-12-19T05:23:28.000Z","updated":"2020-12-19T15:04:17.354Z","comments":true,"path":"2020/12/19/智能闹钟（一）｜macOS入门使用树莓派3B/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/19/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BD%9CmacOS%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3B/","excerpt":"前言 最近，苹果手机坏了，暂时用回一加6古董机。iOS的捷径可以实现每日闹钟停止后可以自动播放网易云音乐的每日推荐歌曲，这个功能真的太喜欢了。但是会有10%的几率播放失败，而且安卓系统并没有类似功能。可能你会想到目前的智能音箱调闹钟不就可以了吗？首先，智能音箱对网络依赖极强，网络故障啥都干不了。其次，智能音箱并没有对接到网易云的每日推荐歌单，闹钟播放的歌曲都是随机的。 因此，作为一个geek，还是自己亲手打造一个可以播放网易云每日推荐歌曲的闹钟吧！","text":"前言 最近，苹果手机坏了，暂时用回一加6古董机。iOS的捷径可以实现每日闹钟停止后可以自动播放网易云音乐的每日推荐歌曲，这个功能真的太喜欢了。但是会有10%的几率播放失败，而且安卓系统并没有类似功能。可能你会想到目前的智能音箱调闹钟不就可以了吗？首先，智能音箱对网络依赖极强，网络故障啥都干不了。其次，智能音箱并没有对接到网易云的每日推荐歌单，闹钟播放的歌曲都是随机的。 因此，作为一个geek，还是自己亲手打造一个可以播放网易云每日推荐歌曲的闹钟吧！ 一、烧录镜像 1. 格式化内存卡 macOS使用SD Memory Card Formatter格式化内存卡，点击此处进入官网下载。（拉到最下面点击accept） 打开SD Card Formatter，按照下图操作。 如下，证明格式化成功 2. 下载树莓派镜像文件 点击此处进入下载页面，我这里下载Lite版的，下载完后不用解压。 3. 下载烧录工具 macOS可以使用 Etcher烧录树莓派，戳这里进入官网：https://etcher.io 选择你刚才下载的镜像（zip 格式），然后选择你的储存卡，点 Flash！即可烧录系统。 耐心等待一段时间，大概需要5分钟就可烧录成功。 注意：烧录后TF卡名字会变为：boot。 4. 编写ssh连接与wifi配置文件 新建两个txt文件，分别命名为：ssh、wpa_supplicant.conf ssh文件是没有后缀的 wpa_supplicant.conf写入下面信息： SSID名字中不能有符号. 优先级范围为1-10 123456789101112131415country&#x3D;CNctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant Group&#x3D;netdevupdate_config&#x3D;1network&#x3D;&#123; ssid&#x3D;&quot;Wifi1的名字&quot; psk&#x3D;&quot;密码&quot; priority&#x3D;优先级，越大越优先&#125;network&#x3D;&#123; ssid&#x3D;&quot;Wifi2的名字&quot; psk&#x3D;&quot;密码&quot; priority&#x3D;优先级&#125; 然后将这两个文件移动至烧录系统镜像后TF卡的根目录。 在Finder中推出TF卡！！！ 要养成好习惯！不然容易烧卡！ 在Finder中推出TF卡！！！ 要养成好习惯！不然容易烧卡！ 二、准备开机 树莓派3B+的电源要求是5V 2.5A的，最好不要太低，否则会损坏机器。（近300块啊） 1. ssh连接 进入到我们的路由器中，然后查看树莓派的IP地址。 ssh工具推荐使用FinalShell，按下图填写 连接成功。可以看到会提示让我们修改ssh密码，但是因为我日常忘记各种密码，我就直接用默认的吧。 三、系统设置 1. 软件源更改 一定要更改源，不然下载程序会非常慢。这里改成清华源。 （1）先安装vim（你可以使用nano或者vi，我个人喜欢vim） 1sudo apt-get install vim （2）修改source.list文件 1vim &#x2F;etc&#x2F;apt&#x2F;sources.list 先把里面的所有内容都注释掉，然后增加下面两行代码 12deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib （3）再修改raspi.list 1vim &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list 同样，先把里面的所有内容都注释掉，然后增加以下内容 1deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui （4）最后，进行更新 第二条命令执行时间会比较长。 12sudo apt-get updatesudo apt-get upgrade 2. 更改时区 查看时区是否为你的当地时区 1date 如果不是，执行命令更改成Asia-Shanghai 1sudo dpkg-reconfigure tzdata 基本设置done！ 四、关闭派不能直接拔出电源！！ 注意⚠️： 关闭树莓派不能直接拔出电源！！！ 正确关闭树莓派方法是：先执行sudo halt，然后等待只有电源指示灯亮的时候（或者等待20s），再拔电源。 下一篇我们利用Node.js版本的网易云apiNeteaseCloudMusicApi，写一个py脚本，实现定时播放网易云音乐每日推荐歌曲。 参考资料： https://stepneverstop.github.io/burn-system2raspberry-in-macos.html https://sspai.com/post/37356 https://www.icxbk.com/article/detail/1077.html","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"linux","slug":"linux","permalink":"https://blog.tangspoon.cn/tags/linux/"}]},{"title":"吐血原创整理｜怎么把java web项目部署到centos7中？","slug":"吐血原创整理｜怎么把java-web项目部署到centos7中？","date":"2020-12-12T13:51:16.000Z","updated":"2020-12-13T15:10:24.584Z","comments":true,"path":"2020/12/12/吐血原创整理｜怎么把java-web项目部署到centos7中？/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/12/%E5%90%90%E8%A1%80%E5%8E%9F%E5%88%9B%E6%95%B4%E7%90%86%EF%BD%9C%E6%80%8E%E4%B9%88%E6%8A%8Ajava-web%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0centos7%E4%B8%AD%EF%BC%9F/","excerpt":"今天打开FinalShell，在vps列表最底下发现了一个叫“pr”的备注，瞬间想起6美元上的一个灵车pacificrack。双击后，震惊，链接居然绿了！连接速度居然还变快了……想不到近一年过去了还没翻车。既然这样，那就用来干点“正事”吧，把失败了的宠物论坛重新搭建起来，折腾一下。","text":"今天打开FinalShell，在vps列表最底下发现了一个叫“pr”的备注，瞬间想起6美元上的一个灵车pacificrack。双击后，震惊，链接居然绿了！连接速度居然还变快了……想不到近一年过去了还没翻车。既然这样，那就用来干点“正事”吧，把失败了的宠物论坛重新搭建起来，折腾一下。 在linux环境上部署javaweb项目比想象中的要简单太多，只需要java环境、mysql、tomcat三样。 我们先查看一下VPS是否自带有以上环境 123rpm -qa|grep javarpm -qa|grep mysqlrpm -qa|grep tomcat 还好，都没有（不然我还得卸载）。所以，第一步是装好java环境。 一、安装java环境 1. 使用wget高效率下载jdk8，安装java环境 进入jdk8下载页面，点击下载链接。（注意到链接左上角是有一把锁🔒的，证明点击后还有验证项目，所以不是直接wget这条url。） 点入链接，打勾后，直接在Download下右键（不是左键！），复制下载链接，这条链接才是可以直接在VPS下wget的。 然后我们连上VPS，输入wget，然后粘贴上面的下载链接。有了VPS后，我们要利用好VPS优秀的远程网络，不要再傻傻的下载到本地电脑，然后再手动上传到VPS中，简直多此一举。 注意，我为什么不直接把下载链接分享出来呢？因为每条下载链接的有效性只能保持一段时间，过后就会失效。具体多久没有探究。oracle公司考虑得真的非常完美，感觉这样其中一个好处就是：可以大幅提高官网的访问率和官方方式下载率，不用一条链接用万年。 2. 解压包 然后我们再/usr/local目录下创建一个名叫java的目录，把刚下载的jdk tar.gz包解压到这里，详细命令如下： 1234567# 新建java目录mkdir &#x2F;usr&#x2F;local&#x2F;java# 解压jdk包到java目录tar -zxvf 包名 -C &#x2F;usr&#x2F;local&#x2F;java# 查看解压包名cd &#x2F;usr&#x2F;local&#x2F;javals 注意！ls后就像上图一样，java文件夹内只能有一个jdk的包，不要放置其他内容 3. 配置环境变量 1vi &#x2F;etc&#x2F;profile 然后如图添加以下内容，然后保存，退出。（注意红框的内容自行更换为自己下载的包名，也就是上面ls查看出来的） 1234# javaexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_271export CLASSPATH&#x3D;$CLASSPATH:$JAVA_HOME&#x2F;lib&#x2F;export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin 然后更新文件： 1source &#x2F;etc&#x2F;profile 4. 验证 1java -version 出现上图，java环境安装成功！ 如果出现了什么幺蛾子的话，就看error提示吧。linux问题很多，很难一一说明。死活有问题的话，就重装系统，换个系统吧，这是最最最没办法中的办法。 二、安装MySQL 5.7 1. 检查是否有冲突的mariadb-lib，然后卸载 1234# 查看是否存在mariadbrpm -qa|grep mariadb# 卸载rpm -e --nodes mariadb-libs-5.5.64-1.el7.x86_64 2. 下载MySQL安装包 1234# 下载rpmwget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm# 安装yum localinstall mysql57-community-release-el7-11.noarch.rpm 3. 安装 1yum install -y mysql-community-server 安装完毕后，启动mysql服务 1service mysqld start 查看mysql服务是否启动成功 1ps -ef|grep mysql 4. 修改密码 查询MySQL的临时密码 1grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log 复制临时密码，使用临时登录MySQL 1mysql -uroot -p 修改密码，然后刷新权限 把下面的xxx修改成自己的密码。 123ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;xxxx&#39;;# 刷新权限！一定要！flush privileges; 最后尝试使用新修改的密码重新登陆。 三、安装tomcat 8 1. 使用wegt下载tar.gz包 2. 安装 1234567# 创建tomcat文件夹mkdir &#x2F;usr&#x2F;local&#x2F;tomcat# 解压tar -zvxf xxx(你的tomcat包名) -C &#x2F;usr&#x2F;local&#x2F;tomcat# 重命名cd &#x2F;usr&#x2F;local&#x2F;tomcatmv xxx(你的tomcat包名) tomcat8 3. 防火墙开放端口 查看防火墙开放情况 1firewall-cmd --list-ports 如果显示-bash: firewall-cmd: 未找到命令,证明没有防火墙。下方是防火墙的相关操作。 12345678910# 安装防火墙yum install firewalld# 开启防火墙systemtcl start firewalld# 开放8080与3306端口，然后重启防火墙firewalld-cmd --add-port&#x3D;8080&#x2F;tcp --permanentfirewalld-cmd --add-port&#x3D;3306&#x2F;tcp --permanentfirewall-cmd --reload# 重新查看开放端口列表firewalld-cmd --list-ports 如图显示，则端口开启成功 4. 开启tomcat，尝试外部访问 12# 有关tomcat的脚本都在bin目录下，bat后缀为windows用户的脚本cd &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;tomcat8&#x2F;bin &amp;&amp; ls 12# 运行tomcatsh startup.sh 尝试外部访问：在浏览器中输入VPS的ip:8080。如图，tomcat部署成功！ 5. 配置开机启动 创建tomcat8系统服务文件 1vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;tomcat8.service 然后在文件中粘贴如下内容，保存后退出。 12345678910111213[Unit]Description&#x3D;Tomcat8After&#x3D;syslog.target network.target remote-fs.target nss-lookup.target[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.shExecReload&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;startup.shExecStop&#x3D;&#x2F;usr&#x2F;tomcat&#x2F;tomcat8&#x2F;bin&#x2F;shutdown.sh[Install]WantedBy&#x3D;multi-user.target 最后启用tomcat8系统配置文件 1systemctl enable tomcat8 四、导入javaweb项目的sql文件到VPS的数据库中 注意：以下命令一行一行逐渐执行，不是直接复制粘贴 1234# 安装上传下载工具cd ~ &amp;&amp; yum install lrzsz# 上传rz 123456789101112# 进入mysqlmysql -uroot -p# 查看数据库show databases;# 新建数据库creat database xxx(你的数据库名) default charater set utf8 collate utf8_general_ci;# 使用数据库use xxx(你的数据库名)# 导入你的sql文件，路径为你sql文件的路径source &#x2F;xxx&#x2F;xxx&#x2F;xxx.sql;# 查看sql文件的table，是否导入成功show tables; 导入sql成功！现在VPS数据库中已经有我们的数据表了！ 五、上传war包到VPS中 先在IDEA打包好war包，打包方法参考：intellij idea打包war包。 我们使用rz命令把war包上传到tomcat8里的wabapps文件夹下。 稍等一下，我们再查看一下webapps有什么变化。可以看到上传pet.war后还多了一个pet文件，原因是tomcat帮我们把war项目自动解析了。这个pet就是我们运行中的pet项目。 此时我们访问尝试访问 ip:8080/项目路径，如无意外，项目访问成功。但我部署项目中就很少没有意外的，这次我就404了…… 六、故障解决 1. 访问出现404 javaweb部署导致404出现的原因有挺多种的，当然我们可以选择Google、Baidu，但其实最快、最稳妥的办法就是查看tomcat的日志。访问不了tomcat会给出针对性的报错原因的。 tomcat的日志在/xxx(tomcat安装目录)/logs/catalina.out 查看日志最后100行 1tail -n 100 catalina.out 一眼就看出是MySQL的问题！导致这个原因一般只有两个：首先是jdbc文件mysql配置信息错误，不然就是数据库版本不对。 打开idea，查看项目的jdbc配置文件，果然这里的password忘记更改成VPS数据库的密码了。 重新编译，打包war包。 删除VPS中tomcat/webapps中的项目war包 和 自动解析生成的项目文件夹 然后重新上传新打包的war包，然后等待大概两分钟（tomcat要重新部署新的war包），过后我们再尝试尝试访问 ip:8080/项目文件。 然后然后……总是如此曲折 2. 样式不见了…… 真是天秀～，查看log也没有报错。 那就F12，看看Console，所有的何css、js资源都无法获取， 网络搜索了一下，在这里这篇文章里获取到了一点点思路，是获取的路径有问题。那么我们在本地idea上编译然后F12，对比看看 从上图我们可以看到，我们的资源多了一个项目名称的目录，index自然获取不到在外部的resources里的css、js文件。可是当时为这个问题已经折腾了一整天了，完完整整的一天，思路已经被局限，没有想到在webapps下的ROOT目录。 在晚上9点折腾无果后，决定加Roothub项目作者交流一下，看看能否获得提示。第二天交流后有一句话给了我提示：“可以设置根路径访问的。”一句惊醒梦中人～ 想到我们直接输入ip访问的Apache Tomcat的首页是部署在ROOT目录下的，这个就是tomcat的根目录呀。那我直接把ROOT下的文件替换成我的项目下的所有文件能不能直接访问呢？ 但不知道为何，使用命令行无法操作ROOT这个目录，想要cp备份不行，cd进入也不行，rm也不行。只好使用FinalShell的图形界面操作了。 在替换操作之后，VPS监控到CPU占用率马上提高，可能是tomcat已经在部署项目了。等CPU占比下来后，访问 ip:8080，成功访问。 其实这种做法是一种折中的解决办法吧，那假如我还有其他要部署的项目呢？还是直接覆盖ROOT目录？这样就在一台VPS下只能存在一个javaweb项目了。这显然是不合理的。 综合搜索资料后分析，出现这种情况大概是原项目作者在开发时使用的是绝对路径。但具体怎么回事目前还未有足够时间去深究，以后有机会再研究。 七、域名访问项目 这里重点讲述tomcat的配置，域名解析什么的就略过吧。相关配置在tomcat/conf/server.xml。 1. 修改成80端口访问 3. 改域名 1vi server.xml 需要修改两个地方：进入vi后，键入esc，直接键入/ ，然后输入Engine，回车。把localhost修改成自己的域名。 最后重启tomcat即可！ MySQL参考：https://www.jianshu.com/p/1dab9a4d0d5f tomcat部署参考：https://ken.io/note/centos7-tomcat-setup 部署到根目录参考：https://www.cnblogs.com/xdot/p/8418655.html","categories":[{"name":"linux","slug":"linux","permalink":"https://blog.tangspoon.cn/categories/linux/"},{"name":"troubleshooting","slug":"linux/troubleshooting","permalink":"https://blog.tangspoon.cn/categories/linux/troubleshooting/"}],"tags":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"},{"name":"linux","slug":"linux","permalink":"https://blog.tangspoon.cn/tags/linux/"}]},{"title":"原创 ｜ macOS 使用HTMLTestRunner与unittestreport失败解决过程","slug":"原创-｜-macOS-使用HTMLTestRunner与unittestreport失败解决过程","date":"2020-12-07T09:06:35.000Z","updated":"2020-12-08T13:50:45.462Z","comments":true,"path":"2020/12/07/原创-｜-macOS-使用HTMLTestRunner与unittestreport失败解决过程/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/07/%E5%8E%9F%E5%88%9B-%EF%BD%9C-macOS-%E4%BD%BF%E7%94%A8HTMLTestRunner%E4%B8%8Eunittestreport%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/","excerpt":"一、背景 在《Python自动化测试实战》中，使用的是HTMLTestRunner，但教程使用的是windows系统，本人使用的macOS与其有点出入。Baidu和Google的帖子全都是在手动下载py文件，然后手动放到Python的lib文件夹中，但本macOS无效。","text":"一、背景 在《Python自动化测试实战》中，使用的是HTMLTestRunner，但教程使用的是windows系统，本人使用的macOS与其有点出入。Baidu和Google的帖子全都是在手动下载py文件，然后手动放到Python的lib文件夹中，但本macOS无效。 二、解决过程 然后尝试换个思路，自动化测试报告中肯定不止只有老旧的HTMLTestRunner这个库呀，会不会有功能更加丰富、使用更方便、美观的第三方库呢？果然，有一个unittestreport 让人极为惊喜。 安装过程显示是非常简单的，直接使用pip安装。但我install之后import还是没反应。疑惑。这时，突然想起Pycharm中的Interpreter的配置，是可以直接安装第三方库的。 在Install Package后，就可以成功使用unittestreport了。 三、如何使用 在此文章中有提示。我自己写了个简单的demo，可直接运行，点此下载 123456789import unittestfrom unittestteport import TestRunner,HTMLTestRunner# 第一步：加载测试套件suite1 = unittest.defaultTestLoader.discover(r&quot;xxx\\xxx\\cases&quot;)# 第二步：创建运行对象，传入测试套件runner = HTMLTestRunner(stream=open(&quot;report.html&quot;,&#x27;wb&#x27;), title=&#x27;木森的测试报告&#x27;,)# 第三步：执行测试runner.run() 四、advanced 1. 为什么pip安装不能直接使用，而直接在Pycharm Interpreter安装就可以使用呢？ 打开Pycharm Interpreter的Avaliable Packages界面，仔细查看，会发现其实会有一个钩子选项。从这里可以得到提示，可能与一个叫site packages的文件夹有关。可以从这里入手。 我们看看Project中的External Libraries都有哪些，打开一看，有了site-packes！ 在里面可以找到我们刚刚导入的unittestreport，还有之前折腾失败的HTMLTestRunner。 pip安装失败，难道是pip安装的路径有问题？那我们查一下通过pip安装的unittestreport是在哪里。 在上述路径中删除一个库，PyCharm的External Libraries中的site-packages中就少了被删除的库，由此可证明其实pip install unittestreport已经成功了，只是我们还未在项目的解释器（PyCharm的Interpreter）中添加而已。其实这就像和我们使用selenium一样，每次新建一个project，就需要在解释器中添加相应的包才能使用的。 2. 为什么网上手动引入HTMLTestRunner.py的方法行不通呢？ 我们研究了上面的问题后，其实可以发现：我们是要在/Users/换成自己的用户名/opt/anaconda3/lib/python3.7/site-packages/中，创建一个HTMLTestRunner文件夹，然后把py文件放进即可。而不是放入什么bin目录或者lib目录。 手动引入其他第三方库类似。 或者更简单的，我们可以直接通过PyCharm的解释器在线添加packages。","categories":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"},{"name":"自动化测试","slug":"troubleshooting/自动化测试","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"}]},{"title":"About unittest","slug":"About-unittest","date":"2020-12-04T10:44:32.000Z","updated":"2020-12-07T09:16:30.931Z","comments":true,"path":"2020/12/04/About-unittest/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/04/About-unittest/","excerpt":"","text":"一、TestFixture 该部分内容极为简单，不再赘述。 二、TestSuite 作用：把测试用例组合到一起 TestSuite()是一个类，需要实例化使用。 1. addTest() 「逐个」加载用例 格式：addTest(测试类名(‘测试用例’)) 123456789101112131415161718192021import unittestclass AllTest(unittest.TestCase): def setUp(self) -&gt; None: pass def tearDown(self) -&gt; None: pass # 测试用例1 def test_1(self): self.assertEqual(1, 2) # 测试用例2 def test_2(self): self.assertEqual(2, 3)if __name__ == &#x27;__main__&#x27;: # 实例化TestSuite() suite = unittest.TestSuite() suite.addTest(AllTest(&#x27;test_1&#x27;)) suite.addTest(AllTest(&#x27;test_2&#x27;)) unittest.TextTestRunner(verbosity=2).run(suite) 2. loadTestsFormTestCase(测试类名)、loadTestsFromModule(‘模块名.py’) 两个都是是继承Testloader()，只是前面是加载一个测试类，后者是加载模块名。 12suite=unittest.TestLoader().loadTestsFromTestCase(BaiduTest)suite=unittest.TestLoader().loadTestsFromModule(&#x27;unittest1.py&#x27;) 3. discover() 「批量」加载用例 使用discover()，其实和使用addTest()是类似的，都是要实例化才能使用。 我们来看： 12suite = unittest.TestSuite().addTest(xxxx)discover = unittest.defaultTestLoader.discover(test_dir,pattern=&#x27;xxx&#x27;,top_level_dir=None) 其实addTest()是unittest 的TestSuite()类下面的一个子类而已，同样的，discover()是unitest的defaultTestLoder()类下的字类，所以都是需要实例化的。 start_dir ：要测试的模块名或测试用例目录。 pattern=‘test*.py’ ：表示用例文件名的匹配原则。星号“*”表示任意多个字符。 top_level_dir=None：测试模块的顶层目录。如果没顶层目录（也就是说测试用例不是放在多级目录中），默认为 None。 三、测试断言 一个测试用例只有两种结果，要么 Pass，要么 Fail（代码错误也显示 Fail）。因此，在自动化测试的测试用例中，切记不要使用 if else 这类判 断代码来代替断言。 另外，在自动化测试中尽量不要应用打印结果来判断测试 用例的情况，用例如，果在代码错误或者功能有 Bug 的情况下就让用例报错或 者失败，而不是结果显示 Pass，只有功能正常的测试用例结果才是 Pass 的。 四、生成测试报告 此处建议使用unittestreport，项目介绍：http://testingpai.com/article/1595507317340 需要注意的是，使用pip install的方式安装后，要在PyCharm的Interpreter中添加。使用使用更佳方便，效果也更加美观。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"About POM","slug":"About-POM","date":"2020-12-04T10:17:24.000Z","updated":"2020-12-13T10:19:25.976Z","comments":true,"path":"2020/12/04/About-POM/","link":"","permalink":"https://blog.tangspoon.cn/2020/12/04/About-POM/","excerpt":"","text":"一、什么是POM POM：Page Object Model——页面对象模型。是一种思想，是一种设计模式，相对应的还有关键字设计模式。 二、为什么要用POM 在自动化测试的代码编写中，采用普通模式，会产生很多代码冗余。例如元素定位模块，每一个元素都得写find_element_by_xxx，在大型项目中这么写效率显然非常低下。 另外，在UI测试中，前端元素会经常发生改变。普通模式把元素定位、元素操作逻辑、测试脚本等模块揉杂在一个文件内，其一，这种操作看起来非常混乱；其二，如果前端页面发生变化，首先要修改页面元素定位，还要修改测试代码。 而POM模型，把元素定位、业务逻辑分开编写，每个模块独立。每一个页面对应一个页面类，页面的元素写到这个页面类中。 三、在哪一阶段要用到POM 四、怎么用 1. bage.py如下： base.py主要写复用率高的函数，比如打开页面、元素定位、退出等等。该页面中不应该含有固定参数，应该全用变量，所有变量都应该在测试用例中定义的。 1234567891011121314151617class BasePage(object): # init def __init__(self, driver, url): self.driver = driver self.url = url # open def open(self): self.driver.get(self.url) # locator def locator(self, loc): return self.driver.find_element(*loc) # quit def quit(self): self.driver.quit() 2. login_page.py如下： 对象页面其实也就只需写两个内容，获取元素，然后封装元素的每一个操作：先定位，然后再用selenium的元素操作send_keys、click等。 12345678910111213141516171819202122232425from selenium.webdriver.common.by import Byfrom base_page.base import BasePage&#x27;&#x27;&#x27; 在这里主要写登陆页面，思路如下： 1、找到元素 2、然后元素操作封装&#x27;&#x27;&#x27;class LoginPage(BasePage): url = &#x27;http://39.98.138.157/shopxo/index.php?s=/index/user/logininfo.html&#x27; username = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[1]/input&#x27;) password = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[2]/input&#x27;) login_btn = (By.XPATH, &#x27;/html/body/div[4]/div/div[2]/div[2]/form/div[3]/button&#x27;) def input_username(self, un): self.locator(self.username).send_keys(un) def input_password(self, pwd): self.locator(self.password).send_keys(pwd) def click_login(self): self.locator(self.login_btn).click() 3. TestUnit.py如下： 在测试模块中，可以用unittest进行测试。并生成相应的测试报告。 1234567891011121314151617181920from selenium import webdriverfrom page_object.login_page import LoginPageclass TestUnit(LoginPage): # 写测试流程 def login(self): self.open() self.input_username(un) self.input_password(pwd) self.quit()if __name__ == &#x27;__main__&#x27;: un = &#x27;carslan&#x27; pwd = &#x27;666666&#x27; driver = webdriver.Chrome() lp = TestUnit(driver, LoginPage.url) lp.login() 四、Todo List 使用unittest重新整合TestUnit部分 加入流程异常捕捉断言测试。 在测试当中，正常流程的实现当然重要，但在编写脚本时，应该注意异常情况的捕捉反馈。 对自己的宠物论坛的注册、登陆、发帖编写自动化测试脚本，并生成相应的测试报告。 五、项目源代码下载 进入AutoTest文件夹下载POM_Get.zip文件。完成上面的todo后，整个项目将上传到 Github中。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}]},{"title":"Python中的init()到底怎么理解？","slug":"Python中的init-到底怎么理解？","date":"2020-11-24T08:37:47.000Z","updated":"2020-11-24T12:26:04.194Z","comments":true,"path":"2020/11/24/Python中的init-到底怎么理解？/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/24/Python%E4%B8%AD%E7%9A%84init-%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%EF%BC%9F/","excerpt":"在Person类里面有一个__init__(self,name,age)，这里我们分成__init__()和self，和age name三个部分来看。","text":"在Person类里面有一个__init__(self,name,age)，这里我们分成__init__()和self，和age name三个部分来看。 __init__()是初始化函数。为什么需要初始化呢？简单来说，我们在创建Person这个对象的时候，我们仅仅只是创建了一个模具，这个模具什么都没有，没有作为一个person应该有的name和age。这显然是不合理的。 所以我们在实例化对象p=Person()的时候，Person类马上开始初始化，创造出一个拥有属性的person。 那么self又是什么东西？ self是必须的，缺少了会报错。在很多博客上都有说：“self外部对象在类内部的表示”。这里我们说人话，注意听“谁调用，就表示谁”。这里我们把Person实例化给了p，所以就是p调用，简单理解就是这个self就是表示p。我们必须得把p传入到类里面，然后才能通过点.的方式去访问类的属性和方法呀。 参考资料 知乎回答： https://www.zhihu.com/question/46973549/answer/293788116 最良心的Python教程： https://github.com/TwoWater/Python/blob/master/Article/PythonBasis/python8/6.md","categories":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"}]},{"title":"原创 ｜ Hexo在generate后出现错误“LaTeX-incompatible input and strict mode is set to 'warn': Unicode text character 开 used in math mode [unicodeTextInMathMode]”","slug":"原创- | -Hexo在generate后出现错误“LaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-开-used-in-math-mode-unicodeTextInMathMode-”","date":"2020-11-19T04:11:23.000Z","updated":"2020-12-07T09:17:34.932Z","comments":true,"path":"2020/11/19/原创- | -Hexo在generate后出现错误“LaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-开-used-in-math-mode-unicodeTextInMathMode-”/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/19/%E5%8E%9F%E5%88%9B-%20|%20-Hexo%E5%9C%A8generate%E5%90%8E%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E2%80%9CLaTeX-incompatible-input-and-strict-mode-is-set-to-warn-Unicode-text-character-%E5%BC%80-used-in-math-mode-unicodeTextInMathMode-%E2%80%9D/","excerpt":"前言 完美主义不允许。 这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。","text":"前言 完美主义不允许。 这个问题困扰了很久，之前是因为tags和categories拼写错误导致的，也有忘记空格的。 正文 在逐篇blog排查过没有拼写错误后，然后逐渐采取了一个很蠢的方式：逐篇删除文章，查找问题所在的博文（还好这个新站点博文数量还不多）。 在删除了《正则表达式-01》这篇文章，执行sudo hexo s后，报错消失。 打开文章，从头开始逐段删除，终于定位到具体的段落 然后在这个段落中再逐渐删除找报错点。终于定位到了！是$这个符号搞的鬼。 基于直觉，加了一个转义字符\\，报错消失～ 出错原因 可以看到下图，是有两个$的，而在Markdown语法中，两个$符号是数学符号和公式的使用。要想使用单个$，要加个转义字符\\。 总结体会 遇到问题要及早解决。如果我第一次遇到了这片文章的故障，就想办法解决，相比现在才去用蠢办法解决时间会节省太多了（起码不用特地写一篇blog～）。 要努力做一个完美主义的人。完美主义我觉得是一个程序员/IT从业者必须具备的一个特质。如果没有完美主义，就很难会深究一个问题。遇到问题就想“能用就行，随便啦”，这个程序员的大忌啊。要“尽量”把每一件事情都做得完美，日后才能安安稳稳过日子嘛。 问题要深究。解决了问题之后，还要知道为什么，日后才不会重复犯错误。就像这次加了转义字符解决了问题，还继续深究为什么会这样，才知道了在markdown中$的用法。","categories":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.tangspoon.cn/tags/Hexo/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"}]},{"title":"测试功能点总结","slug":"测试功能点总结","date":"2020-11-17T08:27:43.000Z","updated":"2020-11-19T03:09:46.267Z","comments":true,"path":"2020/11/17/测试功能点总结/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/17/%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"前言 给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。","text":"前言 给自己思考的一些功能点做个总结，可以站在更高的角度去看待一个系统、系统中的一个功能，整个过程可谓十分有趣。但因为个人思路有限，感觉始终没有做到让自己很惊艳，还是缺乏经验啊。欢迎各位在下方评论区交流。 功能点列表 所有xmind文件都可以在blog的「文件」中下载，但目前使用的是Gcore的俄罗斯的vps搭建的OLAINDEX，所以访问与下载可能会有些慢，日后会进行优化。 朋友圈点赞-测试点.xmind 微信红包-测试点.xmind 搜索框-测试点.xmind 朋友圈评论-测试点.xmind 视频播放器-测试点.xmind 购物车-测试点.xmind 欢迎在下方评论区补充","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"测试点","slug":"测试点","permalink":"https://blog.tangspoon.cn/tags/%E6%B5%8B%E8%AF%95%E7%82%B9/"}]},{"title":"测试用例-基础知识","slug":"测试用例-基础知识","date":"2020-11-16T07:11:13.000Z","updated":"2020-11-16T07:17:21.696Z","comments":true,"path":"2020/11/16/测试用例-基础知识/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/16/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"前言 很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。","text":"前言 很多人说功能测试只是“点点点”，根本不是一门技术活。但实际上，“点点点”靠的是前期测试设计阶段生成的相应文档：《测试用例》。可以说，测试用例是功能测试的核心。在这里，我们来了解一下测试用例的相关知识。 测试用例-误区 首先，我们深刻理解测试用例的基本概念，打牢根基对日后cases的编写应该很有帮助。 测试用例是什么？ 测试用例是“一组输入、执行条件、预期结果” 什么是一个好的测试用例？ “能发现当前未发现的缺陷的用例就是一个好的用例。”当然是这样的，但是我们要注意，不要盲目片面地去设计出“难以发现的缺陷”，忘了测试的存在。测试用例实际上是个集合，所以对它的评价也只能对cases的集合来进行。作为测试依据的测试用例，必须要能完整覆盖「测试需求」，而不应该针对单个的测试用例去评判好坏。 测试用例的预期结果不需要验证吗？ 比如我们测试一个论坛的更改昵称的功能，我们的预期结果不应该仅仅只有“昵称更改成功”，还应该包含着对预期结果的验证：在数据库中执行查询语句，看查询结果是否与预期一致。 测试用例-作用 指导测试的「实施」 整个整个测试过程分成好几个阶段，每个阶段都有不同优先级与重要级的cases。 「规划」测试数据 在实践中，数据和用例是分开的。按照测试用例配备一组或若干组测试「原始数据」，以及标准测试结果。除正常数据之外，还必须根据测试用例设计大量的「边缘数据」和「错误数据」。 评估测试结果的度量基准 在测试执行阶段完成后，我们得进行测试结果的评估，然后编写测试报告。做大部分的判断都是需要量化的结果的，测试也不例外。我们怎么判断一个软件的质量如何呢？测试用例就能给我们提供帮助。我们可以用测试用例中统计出测试覆盖率、测试合格率、重要测试合格率等等。 测试用例-设计方法 等价类划分 输入数据的划分方式（可以从哪几个方面划分？） 输入数据的「个数、集合、规则、取值范围、布尔值」。 设计测试用例的步骤 分析需求，确定「输入」「数据类型」。 例如，固定电话号码的测试，固话号码的输入为：区号+电话号，前者的数据类型为：3/4位的数字，后者的类型为：7/8位的电话号。 所以，分析需求，得从输入与数据类型两个维度来看。 根据「输入规则」，使用上面的划分方式效&amp;无效等价类 1）规则列表（可以从长度，集合，规则，取之范围……来看） 2）「划分」有效等价类与无效等价类 设计用例，覆盖有效等价类（一条用例尽可能多的覆盖有效等价类） 设计用例，覆盖无效等价类（一条用例只能覆盖一条无效等价类） 边界值 边界值分析法一般是搭配「等价类划分」使用来设计测试用例 基本概念 首先，得明白上点、离点、内点的概念。 什么时候用边界值？ 在使用「等价类划分」时，划分有效&amp;无效等价类这一步时，要结合边界值来设计测试用例。 还是以固话号码为例。区号长度3/4位，上点：3、4，离点：2、5，内点：3/4（与上点重复） 所以，在设计测试用例时，“3. 以0开头的小于3位的数字（离点：2位）”设计成“01（2位，而不是1位） 1234567”。 判定表法 因果图 总结 参考资料： https://www.bilibili.com/video/BV1QJ411g7nR?p=8 https://www.cnblogs.com/kuihua/p/5925092.html","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"简单的“用户登陆”用例设计真的简单吗？","slug":"简单的“用户登陆”用例设计真的简单吗？","date":"2020-11-01T12:21:07.000Z","updated":"2020-11-08T04:11:55.402Z","comments":true,"path":"2020/11/01/简单的“用户登陆”用例设计真的简单吗？/","link":"","permalink":"https://blog.tangspoon.cn/2020/11/01/%E7%AE%80%E5%8D%95%E7%9A%84%E2%80%9C%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E2%80%9D%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%9C%9F%E7%9A%84%E7%AE%80%E5%8D%95%E5%90%97%EF%BC%9F/","excerpt":"前言 可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。","text":"前言 可以有许多不一样的拓展方式！值得记录。以下内容均来自「茹炳晟」在“极客时间”的课程「软件测试52讲」的总结归纳。强烈推荐本课程。 一、基础用例 输入正确的账号密码，验证是否登陆成功； 输入正确的账号错误的密码，验证是否登陆失败，并且提示信息正确；（“提示信息正确”指的是每个项目的提示都不一样，这里统称提示信息正确，往下所有均为此意） 输入未注册的账号和任意密码，验证是否登陆失败，并提示信息正确； 用户名和密码两者为空，验证是否登陆失败，并提示信息正确； 用户名和密码两者之一为空，验证是否登陆失败，并提示信息正确； 如果登陆功能启用了「验证码功能」，在用户名与密码正确的前提下，输入正确的验证码，验证是否登陆成功； 如果登陆功能启用了「验证码功能」，用户名与密码输入正确的前提下，输入错误的验证码，验证是否登陆失败，并提示信息正确； 用户民密码是否支持特殊字符和中文； 前端校验格式长度等，后端是否也校验 二、中阶用例 用户名和密码是否大小写敏感； 页面上的密码框是否加密显示； 忘记用户名和忘记密码的功能是否可用； 前端页面是否根据设计要求限制用户名和密码的长度； 如果登陆功能需要验证码，点击验证图片是否可以更换验证码，更换后的验证码是否可用； 刷新页面是否会刷新验证码； 如果验证码具有时效性，需要分别验证时效内和时效外的验证码的有效性； 不同级别的用户，比如管理员和普通用户，登陆系统后的权限是否正确； 后台系统创建的用户第一次登陆成功时，是否提示修改密码； 用户登陆成功直到会话超时后，继续操作是否会重定向到用户登陆界面； 页面默认焦点是否定位在用户名的输入框中； 快捷键tab和enter等，是否可以正常使用。 1-4可归纳为「用户名密码的大小与长度」细分类，5-7是验证码类，9-12是用户体验类 一个质量过硬的软件系统，除了显式功能性需求以外，其他的「非功能性需求」即隐式功能性需求也是极其关键的 非功能性需求主要涉及：安全、性能、兼容三大方面。 三、安全测试用例 用户名密码后台存储是否加密； 用户名在网络传输过程中是否加密； 密码是否具有有效期，密码有效期到期后，是否提示需要修改密码； 不登陆的情况下，在浏览器中直接输入登陆后的URL地址，验证是否会重定向到用户已登陆的界面； 密码输入框是否不支持复制和粘贴； 密码输入框框内输入密码是否都可以在页面源代码模式下被查看； 用户名和密码的输入框分别输入典型的“SQL 注入攻击”字符串，验证系统的返回页面； 用户名和密码的输入框中分别输入典型的“XSS 跨站脚本攻击”字符串，验证系统行为是否被篡改； 连续多次登陆失败的情况下，系统是否会阻止后续的尝试以应对暴力破解； 同一用户在同一终端的多种浏览器上登陆，验证登陆功能的互斥性是否符合设计预期； 同一用户先后在多台终端的浏览器上登陆，验证登陆是否具有互斥性。 四、性能压力测试用例 单用户登陆的响应时间是否小于3秒； 单用户登陆时，后台请求数量是否过多； 高并发场景下用户登陆的响应时间是否小于5秒； 高并发场景下「服务端的监控指标」是否符合预期； 高集合点并发场景下，是否存在资源思索和不不合理的资源等待； 长时间大量用户连续登陆和登出，服务器端是否存在内存泄漏。 五、兼容性测试用例 不同浏览器下，验证登陆页面的现实以及功能的正确性； 相同浏览器的不同版本下，验证登录页面的现实以及功能的正确性； 不同移动设备终端的不同浏览器下，验证登录页面的现实以及功能的正确性； 不同分辨率的界面下，验证登录页面的现实以及功能正确性。 六、其他网友补充 是否支持第三方登录； 是否可记住密码，记住密码保存是否加密，记住密码是否有有效期，过期后是否会清空密码； 是否可以用抓包工具抓到的请求包直接登录； 截取到的token等信息，是否可以直接在其他终端上使用，绕开登陆。token过期时间教研； 修改密码后 （1）修改完密码后是否重定向到登录界面 （2）修改完密码后，分别使用原密码和新密码登录 （3）在其他终端修改密码后，本终端是否自动下线？下线后，使用原密码能否继续登录？ 密码错误限制次数 （1）密码输入错误是否有最大次数限制？分别测试最大值-1、最大值、最大值+1时的输错密码情况 （2）超过最大次数限制后，是否采取强制手段限制登录或对账号暂时冻结处理 （3）超过最大次数限制后，分别输入正确的密码和错误的密码再次登录 登录用户限制：比如同时支持10个用户登录，同时9个或者11个用户登录是否正常或者提示信息正确 用户名和密码是否对空格敏感 密码是否有明文和暗文显示两种模式(有时候只有暗文显示真的不知道自己的密码是否输入正确) 更改密码后是否还能用之前的密码登录 一个用户是否具备多种登录方式(用户名，手机号，邮箱…) 若支持手机号+验证码登录，验证码是否有时间限制？移动端设备是否可以直接获取验证码？ 一个优秀的测试工程师必须具有很宽广的知识面，如果你不能对被测系统的设计有深入的理解、不明白安全攻击的基本原理、没有掌握性能测试的基本设计方法，很难设计出“有的放矢”的测试用例。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-10-29T12:05:08.000Z","updated":"2020-11-08T04:20:34.608Z","comments":true,"path":"2020/10/29/Linux基本操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/29/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"前言 虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。 这篇博文开个Linux栏目吧。","text":"前言 虽然之前在Linux环境下搭建过许多个Web服务，但如果你问我Linux常用的操作命令有哪些啊？还真不一定答得上来，好像也只有增删查改那几个常规操作吧。 这篇博文开个Linux栏目吧。 基本操作 新建文件 1touch test1.txt 新建文件夹 1mkdir test_dir 复制 1cp 源路径 （空格）目标路径 移动/剪切/重命名 12345# 移动&#x2F;剪切mv test.txt 文件夹路径# 移动+重命名mv test.txt test_dir&#x2F;test2.txt #test_dir为文件夹 查看当前所在路径 1pwd 权限修改 这个参数较多，比较复杂，详细的后面再出一篇博文专门讲这一点。这里只讲常用的几点。 12chmod 777 file # 所有人可读写chmod 600 file # 拥有者可读写 删除 12345rm # 删除文件rm -f # 强制删除文件rm -r # 删除文件夹rm -rf # 强制删除文件夹注意尽量少用 rm -rf！很危险！ 读取文档内容 常用语查看Linux的log日志文件 1234cat # 一次全部读取more # 逐步读取tail -f # 一直读取最新内容tail -n 行数 文件名 # 从第几行开始读","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/tags/Linux/"}]},{"title":"解决badboy出现“页面的脚本发生素错误”","slug":"解决badboy出现“页面的脚本发生素错误”","date":"2020-10-29T09:18:02.000Z","updated":"2020-11-24T13:16:41.345Z","comments":true,"path":"2020/10/29/解决badboy出现“页面的脚本发生素错误”/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/29/%E8%A7%A3%E5%86%B3badboy%E5%87%BA%E7%8E%B0%E2%80%9C%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%84%9A%E6%9C%AC%E5%8F%91%E7%94%9F%E7%B4%A0%E9%94%99%E8%AF%AF%E2%80%9D/","excerpt":"前言 学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。","text":"前言 学习 JMeter 接触了一下 badboy ，不过感觉这东西太旧了吧！事实证明，它是基于 ie 内核的……这玩意儿还是别用了吧。但问题还是要解决的，就当水一篇博文吧，也希望能帮助到有用的人。 网上正常的几种方法都尝试过了，但无效。后来看到了这篇CSDN的文章，果然有用。记录一下。","categories":[{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"}]},{"title":"后盾人MySQL-多表操作","slug":"后盾人MySQL-多表操作","date":"2020-10-28T13:39:51.000Z","updated":"2020-11-08T04:45:12.940Z","comments":true,"path":"2020/10/28/后盾人MySQL-多表操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C/","excerpt":"前言 MySQL 表的操作还是有很多需要理解的地方，在此感谢后盾人的文章。","text":"前言 MySQL 表的操作还是有很多需要理解的地方，在此感谢后盾人的文章。 JOIN inner join 查询一班的所有同学 1select s.id,sname,cname from stu s join class c on s.class_id&#x3D;c.id where c.id&#x3D;1; 每个班级发表的文章数量，来操作多张表的关联操作 123456789# 班级：class# 文章：article# 但class与article未设置直接连接，还需用stu联合起来（stu作为桥梁：用stu的class_id把class的id联合，然后再用stu的id把article的stu_id联合）select c.id,count(*) from stu as sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.id;# 1. 计算数量用count(*)；2. 为什么用group by后面的是c.id呢？因为题目要求是「每个班级发表的文章数量」，所以肯定是用class的id来排的。 一班的所有女生发表的文章 12345678# 一班：class# 女生：stu# 文章：articleselect c.id,a.title from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idwhere sex&#x3D;&#39;女&#39;; 哪个班级发表的文章超过两篇 12345678select c.id,count(*) as total from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.idhaving total &gt;&#x3D;2;# 注意total是在count(*)设置的# having total也就是拥有count（*）这个数&gt;&#x3D;2的 每个班级文章的总点击数与平均点击数 123456select c.id,sum(a.click) as class_sum,avg(a.click) from stu sjoin class cjoin article aon s.class_id&#x3D;c.id and s.id&#x3D;a.stu_idgroup by c.idorder by class_sum asc; 每个班级有多少同学 123# 班级：class# 学生：stuselect c.id,count(*) from stu s join class c on s.class_id&#x3D;c.id group by c.id; 上面是两张表连立后的新表，可以看到直接通过cname来统计每个班有多少人（有两个cname就证明有两个人） 学生人数大于两个的班级名称 1234SELECT count(*) as total,c.cname FROM stu as s INNER JOIN class as cON s.class_id &#x3D; c.idGROUP BY c.cnameHAVING total&gt;&#x3D;2; outer join 外链接包括left join与right join，可以简单理解为 LEFT JOIN会包含左侧所有表记录，RIGHT JOIN 会包含右侧表全部记录。 获取没有设置QQ的用户 123SELECT s.sname FROM stu AS s LEFT JOIN stu_info as iON s.id &#x3D; i.stu_idWHERE i.qq is null;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"后盾人MySQL-基本操作","slug":"后盾人MySQL-基本操作","date":"2020-10-28T13:17:38.000Z","updated":"2020-11-08T04:46:23.760Z","comments":true,"path":"2020/10/28/后盾人MySQL-基本操作/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E5%90%8E%E7%9B%BE%E4%BA%BAMySQL-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"感谢后盾人的MySQL教程","text":"感谢后盾人的MySQL教程 查询数据 用的两张表： 字段处理 查询制定字段，并排序字段 1select description,cname from class; 条件筛选 根据条件查询 1select *from class where cname&#x3D;&#39;php&#39;; 查询包含关键词的数据 1select *from class where description like &#39;%p%&#39;; 合并「列」返回查询结果 1select concat(id,cname) as &#39;class_info&#39; from class; 介绍中不包含php的班级 1select *from class where description not like &#39;%php%&#39;; 查询学生所在班级编号，并去除重复值 1select distinct class_id from stu; 查询年龄在20~35岁的同学 1select * from stu where age between 20 and 35; 查找2、3班的所有同学 1select *from stu where class_id in(2,3); 查找除了1、3班的同学 1select *from stu where class_id not in(1,3); NULL 查询没有非配班级的学生姓名 1select sname from stu where class_id is null; 查询结果中对没分配班级的学生显示未分配 1select sname,ifnull(class_id,&#39;未分配&#39;) from stu; 排序结果 按学生年龄从大到小排序 1select *from stu order by age desc; 班级从大到小排序，相同班级的同学年龄从小到大排序 1select *from stu order by class_id desc,age asc; 也就是多个条件的罗列。 随机获得一名同学 1select *from stu order by rand() limit 1; 最后报名的同学 1select *from stu order by id desc limit 1; 第二和第三报名的同学 1select *from stu order by id asc limit 1,2; 查找2班年龄最小的同学 12select *from stu where class_id&#x3D;2 and age is not null order by age asc limit 1;# 注意不要忘了order by age中的age 综上：排序中选择某个特定对象，可以用limit来限制。但一定要先排好序再使用。 删除记录 删除所有年龄小于20的同学 1delete from stu where age&lt;20; 删除所有年龄小在30并没有班级的同学 1delete from stu where age&#x3D;30 and class_id is null; 添加记录 添加一条记录 1insert into stu SET sname&#x3D;&#39;小明&#39;,age&#x3D;22,class_id&#x3D;1; 添加多条件记录 12insert into stu(sname,class_id,age) values(&#39;小明&#39;,2,32),(&#39;小张&#39;,3,45);# 注意不要忘了values","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"个人理解TCP/IP","slug":"个人理解TCP:IP","date":"2020-10-27T16:53:05.000Z","updated":"2020-11-08T04:18:36.253Z","comments":true,"path":"2020/10/28/个人理解TCP:IP/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/","excerpt":"本文学习参考文章：https://www.odaily.com/post/5133541 TCP/IP是什么？ TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP……","text":"本文学习参考文章：https://www.odaily.com/post/5133541 TCP/IP是什么？ TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP…… 不同的协议层对数据包有不同的称谓，在传输层叫做段 (segment)，在网络层叫做数据报 (datagram)，在链路层叫做帧 (frame)。 TCP/IP的分层管理 TCP/IP参考模型：网络接口层、网络层、传输层和应用层。 网络上很多会从下往上理解，但从上往下会更符合普通用户的理解。 应用层：这一层的任务是：将接收到的数据包按照「协议」解读成各种类型的数据，然后把这些数据打包传到下一层：传输层。协议有：HTTP、FTP、SMTP、Telnet、NFS、RIP等。 例如：我要发一封邮件，就要用SMTP协议把数据包解读，传给传输层帮我传输。 传输层（TCP层）：这层的任务是：确保分割的单元在另一端正确地到达，它建立端口到端口的连接。用TCP/UDP协议，把应用层传来的数据进行分割成以数据报文段为单位的数据包交给下一层（网络层）。（这是在「网络」中两台机器互相传数据。） 网络层（IP层）：这层的任务是把传输层的数据，在众多的路由器中「找到路」，传给下一层。 该层常见的协议有：IP，ICMP，ARP，RARP 网络接口层（数据连接+物理层）：负责传输「局域网」的数据。这层使用什么协议取决于所使用的无力网络：如果物理网是LAN，那么通常使用的是以太网协议以及他的变体。 两台主机之间是通过网卡进行发送和接受数据的，**以太网在「子网」内以广播的形式发送数据。**光靠MAC地址并不能让两台主机通信，因为如果两台主机不在同一子网，以太网协议就不能用了。这时需要通过网路层来区分每台主机所在的网络是哪个子网。 上面的整个流程举个例子：我向我朋友发一封邮件，内容为“你好！”，这时候在「应用层」就使用SMTP协议对邮件内容进行打包整理，传给「传输层」，用TCP/UDP协议来切割数据（传输的过程都是在网络中进行的，不是局域网）。可是数据都要传去哪里呢？这件事交给「网络层」（IP），它会选择一条路径把交到离你最近的路由器上，再由光线传到我们家里的广猫中，这个时候就交给「网络接口层的协议」发挥作用了，在局域网中把广猫的数据通过网线或wifi发送到我们的电脑网卡中开始接收。 TCP、UDP与其他 TCP协议：面向连接的、基于字节流的、可靠的传输层通信协议 面向连接：需要经过三次握手后，client与servers端才会开始进行数据的传输（但我握手过程中传送的包不包含任何数据） 稳定可靠：能把数据准确可靠地传给对方，简单来说就是，它把数据切成一个个数据包，从第一只数据包开始传，传送成功就翻倍，发现失败就地爬起来，从绊倒的那只数据包重新开始，周而复始。 基于字节流服务：把大块数据分割成以报文段为单位的数据包进行管理。 UDP、ARP、RARP概念相对简单，具体可以参考文章：一文看懂互联网TCP/UDP协议","categories":[{"name":"网络","slug":"网络","permalink":"https://blog.tangspoon.cn/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络基础","slug":"网络基础","permalink":"https://blog.tangspoon.cn/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}]},{"title":"面试宝典-01","slug":"面试宝典-01","date":"2020-10-27T05:29:07.000Z","updated":"2020-11-08T04:37:04.073Z","comments":true,"path":"2020/10/27/面试宝典-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/27/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-01/","excerpt":"一、软件工程 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？ 软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。 常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。","text":"一、软件工程 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？ 软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。 常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。 2. 什么是版本控制，常用的系统有哪些？ 是一种软体工程技巧，确保不同的人编辑的统一文档都能得到更新。 1）Git：分布式的版本控制系统。 2）SVN：subversion，分支管理系统。 二、测试模型 1. 常见的测试模型 1）V字型：这是一种古老的瀑布模型，反映了实际和测试之间的关系。局限:仅仅把测试过程作为编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，如果前面设计错误， 得一直到后期的验收测试才被发现，耗时耗力。 2）W型：测试与开发同时进行，在 V 模型的基础上，增加了在开发阶段的同步测试。局限：仍然不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试 2. 请根据”V”模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的「工作任务」及其相应「生成的文档」? 1）需求定义阶段：根据项目需求提取测试需求，形成「测试需求文档」；根据测试需求和项目计划生成「测试计划」。 2）设计阶段：根据测试需求拟定测试方案并形成「测试方案文档」；根据测试方案文档指定测试用例，并形成「测试用例文档」 3）编码阶段：执行测试并完善测试用例文档 4）系统集成阶段：测试总结报告，阶段问题统计报告，测试问题报告 三、测试计划 1. 编写测试计划的目的是？ 使测试工作顺利进行；使项目参与人员沟通更顺畅；使测试工作更系统（人与系统） 2. 测试计划编写六要素 5W1H（谁、时间、地点、做了什么事、为什么、怎么做的H） 3. 测试人员在软件开发过程中的任务是什么？ 寻找bug，衡量软件的品质，避免软件开发过程中的缺陷，关注用户体验。总的来说就是：确保软件质量。 四、测试种类 1. 请列出你所知道的「软件测试种类」，至少五项。 2. 黑盒测试和白盒测试的常用测试方法有？举个例子？ 1）黑盒：等价类划分法、边界值法、因果图法和错误猜测法 2）白盒：逻辑覆盖法、循环测试路径选择、基本路径测试 例子：在一次输入多个条件的完整性查询中。利用等价类划分法和边界分析法，首先利用等价类划分法，制定一个或多个结果是OK的测试用例，然后确认多个NG的测试用例。然后再用边界值分析法，对结果分别是OK和NG的测试用例进行拓展和补充。 3. 简述黑盒测试和白盒测试的优缺点？ 1）黑盒 优点：a. 比较简单，不用了解内部代码的实现；b. 从用户的角度出发，很容易知道用户会用到哪些功能，会遇到什么问题；c. 与软件内部无关；d. 在做软件自动化测试时较方便。 缺点：代码覆盖率较低；自动化测试的复用性较低。 2）白盒 优点：代码覆盖率高，提高代码质量，发现隐藏的问题。 缺点：a. 测试基于代码，只能测试开发人员的对与不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；b. 系统庞大时，测试开销会很大；c. 测试有很多路径，不可能测试完所有的路径。 4. 单元测试的策略有哪些，主要内容有？ 逻辑覆盖，循环覆盖，代码走查，静态数据流分析，代码评审，桌前检查，同行评审 5. 白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是？ 语句覆盖，分支覆盖，条件覆盖，路径覆盖，分支条件覆盖。最高的是路径覆盖。 五、用例设计 1. 什么是测试用例，测试用例的基本要素？ 测试用例是为某个测试目标编写的一组输入、执行条件与预期结果，以便测试某个程序是否符合特定要求。 基本要素：测试索引，测试环境，测试输入，测试操作，预期结果，评价标准 2. 描述测试用例设计的完整过程 1）根据概要设计、需求文档、测试计划、测试方案细分出测试项 2）根据测试项，按照详细设计与测试方案中测试的覆盖率细分出测试子项 3）用测试设计方法（等价类划分，边界值，因果图等）编写测试用例 注意：用例一定要及时更新（补充与删除），要全面（考虑功能、性能、兼容性等） 3. 有个广告的纸杯子，请设计测试用例 基本功能测试（逻辑功能测试）。 1）硬度：是否达到设计标准。 装载能力:在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。 装载种类:开水(是否产生异味)、温水、冷水、冰水、咖啡。。 2）界面测试(UI 测试)。 看其形状、大小设计是否适合人方便拿起。 外观是否吸引人(广告嘛)，赏心悦目。 带广告的图案沾水受是否掉色、模糊。 3）易用性测试。 看其形状、大小设计是否适合人方便拿起。 残疾人士用此杯去喝水的容程度。 杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。 4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。 5）安全性测试。杯子所用的材料(包括纸基、涂层和广告颜料)是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。 6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。 7）对设计的改进建议。“如果是一次性杯子，能否标示已使用(比如变色)”和“杯子是否有使用者标贴(多人使用时防止混淆)”。 4. 一个身份证号码输入框，怎么设计用例? 校验身份证号的规则有效性（地址码、生日编码、顺序码、校验码） 检验15位身份证和18位身份正好可用 校验末尾是x的情况 校验不足15位、16-17位和18位的情况 如果是必输项，空白时是否有提示与流程是否正常进行 如果不是必输项，校验不输入时流程能否正常进行 检验非数字的情况，是否会有正确提示信息（包括大小写字母，汉字，特殊字符与标点符号） 5. 登陆功能怎么设计测试用例？ 具体需求:有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。 此题的考察目的：1. 了解需求(测什么都是从了解需求开始)；2. 是否有设计 Test Case 的能力；3. 是否熟悉各种测试方法； 4. 是否有丰富的 Web 测试经验;；5. 是否了解 Web 开发。 了解需求：1. 登陆界面是弹出窗口式的，还是直接在网页里面；2. 账号长度和密码的强度要求（比如需要多少位、大小写敏感、特殊字符混搭）；3. 界面美观是否有特殊要求（是否要进行UI测试） 用例设计： 1）功能测试：Function Test 输入正确的账号密码，点击提交按钮，验证是否能正确登陆（正常输入） 输入错误的账号密码，验证登陆会失败，与给出相应的错误提示（错误输入） 登陆成功后能否正确跳转到正确界面 账号和密码如果太长或太短，应该怎么处理（安全性，密码太短都有提示） 账号和密码中，有特殊字符（比如空格）和其他非英文情况（是否做了顾虑） 账号和密码前后都有空格的处理 输入密码时，大写键盘有提示 密码是否加密显示 什么都不输，点击提交按钮，看提示信息 记住账号功能 登陆失败后，不能记录密码的功能 牵涉到验证码的，还要考虑验证难度是否过大，刷新或者换一个的按钮是否好用 登陆页面中的注册、忘记密码、登出、用另一账号等链接是否正确 2）界面测试：UI Test 布局是否合理，2个Testbox和1个按钮是否对其 Testbox和按钮的长度，高度是否符合要求 界面的设计风格是否与UI的设计风格统一 界面的文字简洁易懂，没有错别字 3）性能测试 Performance Test 打开登陆页面，需要几秒 输入正确的账号密码后，登陆成功跳转到新页面，不超过5秒 4）安全性测试 Security Test 登陆成功后生成的 Cookie 是否有 HttpOnly（降低脚本盗取风险） 账号密码是否通过加密的方式，发送到Web服务器 账号和密码的验证，应该是用服务器端验证，而不只是用客户端的JS分析 账号和密码的输入框，应该屏蔽SQL注入攻击 账号和密码的输入框，要禁止输入脚本（防止XSS攻击） 错误登陆的次数使用限制（防止暴力破解） 考虑是否支持多用户在同一机器上登陆 考虑一用户在多台机器登陆 5）可用性测试 Usability Test 是否可以用全键盘操作，是否有快捷键 输入账号，密码后回车，是否可以登陆 输入框是否可以用Tab切换 6）兼容性测试 Compatibility Test 主流浏览器功能是否正常 不同系统平台是否工作正常（Macos pc） 移动设备是否工作正常 不同分辨率 7）本地化测试 Localization Test 不同语言环境，页面显示是否正确 8）辅助性测试 高对比度下是否显示正常（视力不好的人）","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS学习笔记-03","slug":"JS学习笔记-03","date":"2020-10-25T10:15:58.000Z","updated":"2020-11-08T04:37:25.818Z","comments":true,"path":"2020/10/25/JS学习笔记-03/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/","excerpt":"函数 定义函数 123456789//第一种function abs(x) &#123; &#125;//第二种var abs = function(x)&#123;&#125;/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/","text":"函数 定义函数 123456789//第一种function abs(x) &#123; &#125;//第二种var abs = function(x)&#123;&#125;/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/ 调用 调用函数时，按顺序传入参数。 JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数 123abs(10, &#x27;blablabla&#x27;); // 返回10abs(9, &#x27;haha&#x27;, &#x27;hehe&#x27;, null); // 返回9abs(); // 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免 arguments 获得调用者的所有参数，但不是一个Array 是一个关键字 只在函数内部起作用 1234567891011121314function foo(x) &#123; console.log(&#x27;x = &#x27; + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log(&#x27;arg &#x27; + i + &#x27; = &#x27; + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30);/*x = 10arg 0 = 10arg 1 = 20arg 2 = 308*/ 要善于利用arguments判断传入参数多少的作用 rest参数 是ES6新增的特性，形式为：…变量名 作用：获取函数多余的参数 123456789101112131415161718//获取a，b之外的参数例子：function foo(a, b, ...rest) &#123; console.log(&#x27;a = &#x27; + a); console.log(&#x27;b = &#x27; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined 因为b在参数中被定义了，要直接输出// Array [] 练习 用rest参数编写一个add()函数，用于接收任意个参数并返回她们的和。 12345678&#x27;use strict&#x27;;function sum(...rest)&#123; let sum=0; rest.forEach(function(elemnt)&#123; sum += element; &#125;); return sum;&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。 1234567891011121314&#x27;use strict&#x27;;function area_of_circle(r,pi)&#123; var area; if(arguments===1)&#123; area=Math.pow(r,2)*3.14; &#125;else&#123; area=Math.pow(r,2)*3.1416; &#125;&#125;//解构赋值function area_of_circle(r, pi)&#123; var[r,pi=3.14]=arguments; return pi*r*r;&#125; 变量作用域和解构赋值 变量提升 js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。 注意：只是变量的声明，并不是赋值。 块级作用域 ES6引入了新关键字 let，用let代替var可以声明一个块级作用域的变量。 12345678910&#x27;use strict&#x27;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 常量 ES6引入了一个const关键字来定义常量 12345&#x27;use strict&#x27;;const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 解构赋值 此知识点小点比较多，详细请看廖雪峰的官网 在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1var [x, y, z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;]; 如果数组本身还有嵌套，只需要嵌套和层次对齐即可。 1var arr[x,[y,z]] = [1,[2,3]]; 从对象中取出其中几个属性的值，也可以用解构赋值 123456789101112131415161718var person=&#123; name: &#x27;tang&#x27;, tel: &#x27;12345&#x27;, age: 20, password: &#x27;S-12345&#x27;, address:&#123; city:&#x27;beijing&#x27;, street:No.1 Road, zipcode:&#x27;10000&#x27; &#125;&#125;;//把person的name和tel取出给var定义的name,telvar &#123;name,tel&#125;=person;console.log(&#x27;name=&#x27;+name+&#x27;,&#x27;+&#x27;tel=&#x27;+tel);/*name=tangtel=12345*/ 如果要对嵌套对象address里面的值进行赋值，也能用解构赋值： 1var &#123;name,address:&#123;city,street&#125;&#125;=person; 如果要使用的变量名和属性名不一致，可以用下面的语法获取： 123var &#123;name,password:id&#125;=person;//这里就是把password「属性」赋值给了变量id//注意：是把password这个属性赋值给了id，所以password不是一个变量 有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把&#123;开头的语句做块处理，= 不再合法。 123var x,y;&#123;x,y&#125;=&#123;x:100,y:300&#125;;//解决办法，用()括起来 方法 this关键字 this是一个特殊变量，始终指向当前对象。下面的例子就是this指向的对象是小明。 12345678var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:function()&#123; var y = new Date().getFullYear(); return y-this.birth; //当前对象为xiaoming &#125;&#125; 但想要把age方法里面的内容拆开写，要怎么办呢？ 123456789101112131415//写一个getAge()方法function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;//编写小明对象var xiaoming=&#123; ame:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;//情况一：xiaoming.age();//正常返回25//情况二：getAge; //NaN 为什么情况二返回的是NaN？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。 想要指向正确，必须用obj.xxx()的形式调用，也就是「对象.方法名」 that 我们先看看下面： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，this指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。 修复方法：使用that变量，在方法内部一开始就首先捕获this： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; var that = this; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age();//25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。 apply 可以指定函数的this指向哪个对象，apply(this要指定的对象 , Array函数本身的参数) 1234567891011function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;xiaoming.getAge();//25getAge.apply(xiaoming,[]); apply()把参数打包成Array再传入；call()把参数按顺序传入。二者功能类似。 例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下： 12Math.max.apply(null,[3,4,5]);Math.max.call(null,3,4,5); 高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。 所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。 1234567&#x27;use strict&#x27;;function add(x, y, f) &#123; //add函数的参数为x,y,f，而参数f是一个函数 return f(x) + f(y);&#125;var x = add(-5, 6, Math.abs); console.log(x);// 11 高阶函数将在下一篇博文详解","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-02","slug":"JS学习笔记-02","date":"2020-10-25T10:11:47.000Z","updated":"2020-11-08T04:37:44.247Z","comments":true,"path":"2020/10/25/JS学习笔记-02/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/","excerpt":"循环 for for循环三个条件可省略，但如果无退出条件，则死循环。退出：break 12345678var x=0;for(;;)&#123; if(x&gt;100)&#123; break; &#125; x++;&#125;","text":"循环 for for循环三个条件可省略，但如果无退出条件，则死循环。退出：break 12345678var x=0;for(;;)&#123; if(x&gt;100)&#123; break; &#125; x++;&#125; for…in 用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三） 1234567891011121314151617181920212223//例一var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; console.log(key); //&#x27;name&#x27; &#x27;age&#x27; &#x27;school&#x27;&#125;//例二var arr=[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;];for(var i in arr)&#123; console.log(i); //‘0’，‘1’，‘2‘ /*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/ /*请注意，for ... in对Array的循环得到的是String而不是Number。*/&#125;//例三var arr=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];for(var i in arr)&#123; console.log(arr[i]); //&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;&#125; 要过滤继承属性，使用day01学的hasOwnProperty()方法实现。例如： ps：或者使用for...of，这也是为什么设计for...of的原因之一。 12345678910var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; if(o.hasOwnProperty(key))&#123; console.log(key); //不然会输出toString属性 &#125;&#125; hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性key」 练习 请利用循环遍历数组中的每个名字 123456789101112&#x27;use strict&#x27;; var arr = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;];//法1for(var key in arr)&#123; console.log(arr[key]);&#125;//法2var i=arr.length-1;while(i&gt;=0)&#123; console.log(arr[i]) i--;&#125; for…of for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。 for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象 参考 张鑫旭大佬的文章 Map和Set Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。 Map Map是一组「键值对」的结构，具有极快的查找速度。例： 123var m new Map([&#x27;Micheal&#x27;,95],[&#x27;Bob&#x27;,88],[&#x27;Tracy&#x27;,93])m.get(&#x27;Micheal&#x27;); //返回的是95！//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字 其他操作如下： 12345var m= new Map(); //新建空Mapm.set(&#x27;tang&#x27;,100); //添加新 key-valuem.set(&#x27;tang&#x27;,1); //覆盖上面的100，返回1m.has(&#x27;tang&#x27;); //返回truem.delete(&#x27;tang&#x27;); Set 与Map不同，Set只存「key」，不存「value」。key不能重复。 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, &#x27;3&#x27;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 注意数字3和字符串'3'是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;s.add(4);s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s &#x3D; new Set([1, 2, 3]);s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;s.delete(3);s; &#x2F;&#x2F; Set &#123;1, 2&#125; iterable &amp; for…of Array可以下标循环，但遍历Map 和Set就无法使用下标。为了统一集合类型，ES6引入了iterable类型，Array 、Map和Set 都属于iterable类型。 具有iterable类型的「集合」，可以通过for...of循环来遍历","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-01","slug":"JS学习笔记-01","date":"2020-10-25T10:05:55.000Z","updated":"2020-11-19T03:21:08.503Z","comments":true,"path":"2020/10/25/JS学习笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/","excerpt":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name","text":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name 变量 只能用var申明一次。没用var申明的变量：全局变量 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 strict模式 'use strict';强制通过var申明 二、字符串 多行字符串 由于多行字符串用\\n写起来费事，最新的ES6标准新增了如下方式表示： 123&#96;这是一个多行字符串&#96;; 模板字符串 很多变量连接时 1234var name &#x3D; &#39;小明&#39;;var age &#x3D; 20;var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;alert(message); 三、数组 indexOf() 搜索指定元素的位置 12345var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2 slice() 截取Array的部分元素，返回一个新的Array 123var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] slice()的起止参数包括开始索引，不包括结束索引 如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组 1234var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];var aCopy &#x3D; arr.slice();aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false push() 和 pop() push()插入数组尾部 pop()删除～ unshift() 和 shift() unshift()插入 头部第一 shift()删除头部第一 reverse() 数组的反转 splice() 修改数组的万能方法，格式为：从哪里开始，删除多少个，添加什么 12345678910var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只删除,不添加:arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只添加,不删除:arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;] concat() 连接两个数组。没有修改原数组，只是生成新数组 join() 把array里面的元素，用指定的字符连起来 123var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];arr.join(&#39;-&#39;);arr;返回的就是&#39;a-b&#39; ps：如果Array的元素不是字符串，则自动转化再拼接 三、对象 用[‘x’]访问（少用） 属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用.访问 1234var xiaohong &#x3D; &#123; name: &#39;小红&#39;, &#39;middle-school&#39;: &#39;No.1 Middle School&#39;&#125;; 123xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;xiaohong.name; &#x2F;&#x2F; &#39;小红&#39; ps：写代码尽量规范，尽量用.访问 由于对象是动态类型，因此可以随便给对象添加或修改属性 123456789101112var xiaoming&#x3D;&#123; name: &#39;小明&#39;&#125;;xiaoming.age; &#x2F;&#x2F;undefinedxiaoming.age&#x3D;18; &#x2F;&#x2F;添加了age属性delete xiaoming.age; &#x2F;&#x2F;删除name属性xiaoming.age; &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefineddelete xiaoming.name; &#x2F;&#x2F;删除namexiaoming.name; &#x2F;&#x2F;undefineddelete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined 检测属性存在性 用in操作符，返回布尔值 123456var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990,&#125;;&#x27;name&#x27; in xiaoming; // true&#x27;grade&#x27; in xiaoming; // false 注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用hasOwnProperty() 12345var xiaoming=&#123; name=&quot;小明&quot;;&#125;xiaoming.hasOwnProperty(&#x27;name&#x27;); //truexiaoming.hasOwnProperty(&#x27;toString&#x27;); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"正则表达式-01","slug":"正则表达式-01","date":"2020-10-25T09:57:31.000Z","updated":"2020-11-19T03:55:20.987Z","comments":true,"path":"2020/10/25/正则表达式-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/","excerpt":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符：","text":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符： 复杂例子：\\d&#123;3&#125;\\s+\\d&#123;3,8&#125;。 我们来从左到右解读一下： \\d&#123;3&#125;表示匹配3个数字，例如'010'； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配' '，'\\t\\t'等； \\d&#123;3,8&#125;表示3-8个数字，例如'1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\\'转义，所以，上面的正则是\\d&#123;3&#125;\\-\\d&#123;3,8&#125;。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线与$组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 使用 1234var re1=/ABC\\-001/var re2=new RegExp(&#x27;ABC\\\\-001&#x27;) //字符串的转义问题，字符串的两个\\\\实际上是一个\\。re1; // /ABC\\-001/re2; // /ABC\\-001/ 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 1&#39;a b c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;] 嗯，无法识别连续的空格，用正则表达式试试： 1&#39;a b c&#39;.split(&#x2F;\\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 无论多少个空格都可以正常分割。加入,试试： 1&#39;a,b, c d&#39;.split(&#x2F;[\\s\\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 再加入;试试： 1&#39;a,b;; c d&#39;.split(&#x2F;[\\s\\,\\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 用()表示的就是要提取的分组（Group）。比如： ^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re &#x3D; &#x2F;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x2F;;re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec(&#x27;19:05:30&#x27;); // [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： 12var re = /^(\\d+?)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 123var r1 = /test/g;// 等价于:var r2 = new RegExp(&#x27;test&#x27;, &#x27;g&#x27;); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 1234567891011121314151617var s = &#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;;var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // [&#x27;JavaScript&#x27;]re.lastIndex; // 10re.exec(s); // [&#x27;VBScript&#x27;]re.lastIndex; // 20re.exec(s); // [&#x27;JScript&#x27;]re.lastIndex; // 29re.exec(s); // [&#x27;ECMAScript&#x27;]re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"软件测试基础理论","slug":"软件测试笔记-01","date":"2020-10-20T14:24:10.000Z","updated":"2020-11-08T04:38:53.951Z","comments":true,"path":"2020/10/20/软件测试笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/","excerpt":"软件测试的分类 方法 黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「需求规格说明书」，检查程序的功能是否符合它的功能说明。 方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等 错误推测法：基于经验和直觉，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格…… 因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的联系、组合情况。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。因果图最终产生的是判定表。 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。 主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等","text":"软件测试的分类 方法 黑盒测试：不用考虑内部逻辑结构与特性，只需要按照「需求规格说明书」，检查程序的功能是否符合它的功能说明。 方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图分析法等 错误推测法：基于经验和直觉，推测软件系统中存在的错误，从而针对性地解决设计测试用例。例如：输入数据为0、输入前后空格…… 因果图：等价类与边界值注重考虑输入条件，但并未考虑输入条件的联系、组合情况。因此需要用一种适合描述多种条件的组合，来便于设计测试用例的工具。这就需要因果图。因果图最终产生的是判定表。 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。 主要技术：逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等 阶段 单元测试： 重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。 单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态数据流分析 单元测试方法：控制流测试、数据流测试、排错测试、分域测试 集成测试：重点测试「接口」 策略：自顶向下和自底向上 应关注： 系统测试 测试方法有：功能、安全、性能、兼容性、易用性、稳定性…… 验收测试 Alpha：用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。总是，A测试是在受控的环境下进行的。 Beta：与上相对。 方向 功能测试：看功能是否正常。 黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做） 性能测试：判断程序能做多好（与时间挂钩） 压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。 负载测试： 定义：数据在超负荷环境下运行，测试软件系统是否能够承担。这种超负荷主要指多并发用户。 理解：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟） 方法：认为生成大量数据，并利用工具模拟频繁并发访问 以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。 并发测试：一瞬间同一个程序在做同一件事情 从用户角度看性能：软件对用户操作的响应时间 系统管理员角度看： 系统的响应时间 系统运行服务器的状态，如cpu利用情况、内润使用情况等 系统是否能够实现拓展 系统支持多少用户访问 系统性能的瓶颈在哪里 系统是否支持7*24小时的业务访问 安全测试（了解）：防止攻击，例如ddos等 兼容性 状态 根据软件的状态划分的 静态：不会运行的软件，通过白盒测试看代码 动态：把软件运行起来测试 其他 冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试），仅对基本功能测试，保证软件跑得起来。 回归测试：回归bug，bug修改了，有没有检查。 测试流程 4个阶段：测试需求分析阶段、测试计划阶段、执行测试阶段、测试评估阶段。 需求分析阶段 主要是学习业务流程，提取功能点，把小功能提取出来，做成树状图。 阅读需求文档：产品经理用文档描述 查看产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。） 测试设计阶段 前三个由产品经理或者组长写，方法是：5W1H 测试计划：时间、人、资源的分配 测试方案 每个测试内容如何展开 采用什么测试计划 哪些内容先测 测试策略 哪些内容先测后测（先测功能还是兼容？） 开始和结束的标准是什么？ 测试用例（重点！重中之重！） 包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。 用例编号：唯一的 用例名称：言简意赅 前置条件：在执行用例前，软件必须要满足的条件 优先级：执行用例的时间要求紧急的等级 重要级：被测功能在软件中的重要等级 要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ） 测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方 测试执行阶段 搭建环境，执行冒烟测试，然后正式测试。 测试评估阶段 出测试报告，确认是否可以上线。 测试方法 等价类 通过少部分的值，代表大部分的情况。 有效等价类 满足条件的：0.01，0.02，200，199.99 无效等价类 不满足条件的：0，200.01 边界法 0，负数，+1，-1，本身，整数，非整数，字符 研发管理模型 作用：在开发中会经历很多过程，模型可以知道不同的工作流程。 瀑布流 从上往下，不可逆不可返回的流程。 V字型 左边是开发做的，右边是测试做的，二者一一对照。 w字型 测试与开发同步了。 软件的生命周期 是指软件的产生到报废的整个过程。包括可行性分析与项目计划，需求分析，概要设计和详细设计，编码，调试，维护七个阶段。 软件测试的生命周期 是指从测试项目计划建立到BUG提交的整个「测试过程」，包括测试计划，测试需求分析，测试用例编写，测试用例执行，BUG提交。","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-13T03:51:26.002Z","updated":"2020-11-08T04:39:03.719Z","comments":true,"path":"2020/10/13/hello-world/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"},{"name":"Python","slug":"智能闹钟/Python","permalink":"https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/Python/"},{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"linux","slug":"linux","permalink":"https://blog.tangspoon.cn/categories/linux/"},{"name":"troubleshooting","slug":"linux/troubleshooting","permalink":"https://blog.tangspoon.cn/categories/linux/troubleshooting/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/"},{"name":"自动化测试","slug":"troubleshooting/自动化测试","permalink":"https://blog.tangspoon.cn/categories/troubleshooting/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/categories/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"},{"name":"网络","slug":"网络","permalink":"https://blog.tangspoon.cn/categories/%E7%BD%91%E7%BB%9C/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.tangspoon.cn/tags/Python/"},{"name":"智能闹钟","slug":"智能闹钟","permalink":"https://blog.tangspoon.cn/tags/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"树莓派","slug":"树莓派","permalink":"https://blog.tangspoon.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"linux","slug":"linux","permalink":"https://blog.tangspoon.cn/tags/linux/"},{"name":"troubleshooting","slug":"troubleshooting","permalink":"https://blog.tangspoon.cn/tags/troubleshooting/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://blog.tangspoon.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.tangspoon.cn/tags/Hexo/"},{"name":"测试点","slug":"测试点","permalink":"https://blog.tangspoon.cn/tags/%E6%B5%8B%E8%AF%95%E7%82%B9/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.tangspoon.cn/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"},{"name":"网络基础","slug":"网络基础","permalink":"https://blog.tangspoon.cn/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]}