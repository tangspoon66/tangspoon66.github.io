{"meta":{"title":"tang's blog","subtitle":"做个善于记录的人","description":"热爱生活，践行极简，技术导向","author":"tang","url":"https://blog.tangspoon.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-13T06:57:39.553Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"/404.html","permalink":"https://blog.tangspoon.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-13T06:57:39.565Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"about/index.html","permalink":"https://blog.tangspoon.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-13T06:57:39.576Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"books/index.html","permalink":"https://blog.tangspoon.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-13T06:57:39.587Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"categories/index.html","permalink":"https://blog.tangspoon.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-13T06:57:39.599Z","updated":"2020-10-13T06:44:25.203Z","comments":true,"path":"links/index.html","permalink":"https://blog.tangspoon.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-13T06:57:39.610Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"repository/index.html","permalink":"https://blog.tangspoon.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-13T06:57:39.622Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"tags/index.html","permalink":"https://blog.tangspoon.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试宝典-01","slug":"面试宝典-01","date":"2020-10-27T05:29:07.000Z","updated":"2020-10-27T05:31:26.000Z","comments":true,"path":"2020/10/27/面试宝典-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/27/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8-01/","excerpt":"","text":"一、软件工程 1. 软件生命周期有哪些阶段？常见的软件生命周期模型有哪些？ 软件生命周期有：初始构思、需求分析、功能设计、内部设计、文档计划、测试计划、文档准备、集成、测试、维护、升级、再测试、逐步淘汰等。 常见模型有：瀑布模型、迭代模型、快速原型模型、螺旋模型。（1）瀑布是最常见的模型；（2）迭代约等于小型的瀑布流项目，每一次迭代都可以产生一个产品，这个产品是最终产品的一个子集；（3）快速原型模型是迅速构建一个可以运行的软件模型，以便理解和澄清问题；（4）而螺旋模型则大多用在大型管理软件系统中，具有前面三者没有的风险分析。 2. 什么是版本控制，常用的系统有哪些？ 是一种软体工程技巧，确保不同的人编辑的统一文档都能得到更新。 1）Git：分布式的版本控制系统。 2）SVN：subversion，分支管理系统。 二、测试模型 1. 常见的测试模型 1）V字型：这是一种古老的瀑布模型，反映了实际和测试之间的关系。局限:仅仅把测试过程作为编码之后的一个阶段，忽视了测试对需求分析,系统设计的验证，如果前面设计错误， 得一直到后期的验收测试才被发现，耗时耗力。 2）W型：测试与开发同时进行，在 V 模型的基础上，增加了在开发阶段的同步测试。局限：仍然不支持迭代，减少了一定错误发生率，但是需按照流水线进行设计、编码和测试 2. 请根据”V”模型分别概述测试人员在软件的需求定义阶段、设计阶段、编码阶段、系统集成阶段的「工作任务」及其相应「生成的文档」? 1）需求定义阶段：根据项目需求提取测试需求，形成「测试需求文档」；根据测试需求和项目计划生成「测试计划」。 2）设计阶段：根据测试需求拟定测试方案并形成「测试方案文档」；根据测试方案文档指定测试用例，并形成「测试用例文档」 3）编码阶段：执行测试并完善测试用例文档 4）系统集成阶段：测试总结报告，阶段问题统计报告，测试问题报告 三、测试计划 1. 编写测试计划的目的是？ 使测试工作顺利进行；使项目参与人员沟通更顺畅；使测试工作更系统（人与系统） 2. 测试计划编写六要素 5W1H（谁、时间、地点、做了什么事、为什么、怎么做的H） 3. 测试人员在软件开发过程中的任务是什么？ 寻找bug，衡量软件的品质，避免软件开发过程中的缺陷，关注用户体验。总的来说就是：确保软件质量。 四、测试种类 1. 请列出你所知道的「软件测试种类」，至少五项。 2. 黑盒测试和白盒测试的常用测试方法有？举个例子？ 1）黑盒：等价类划分法、边界值法、因果图法和错误猜测法 2）白盒：逻辑覆盖法、循环测试路径选择、基本路径测试 例子：在一次输入多个条件的完整性查询中。利用等价类划分法和边界分析法，首先利用等价类划分法，制定一个或多个结果是OK的测试用例，然后确认多个NG的测试用例。然后再用边界值分析法，对结果分别是OK和NG的测试用例进行拓展和补充。 3. 简述黑盒测试和白盒测试的优缺点？ 1）黑盒 优点：a. 比较简单，不用了解内部代码的实现；b. 从用户的角度出发，很容易知道用户会用到哪些功能，会遇到什么问题；c. 与软件内部无关；d. 在做软件自动化测试时较方便。 缺点：代码覆盖率较低；自动化测试的复用性较低。 2）白盒 优点：代码覆盖率高，提高代码质量，发现隐藏的问题。 缺点：a. 测试基于代码，只能测试开发人员的对与不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；b. 系统庞大时，测试开销会很大；c. 测试有很多路径，不可能测试完所有的路径。 4. 单元测试的策略有哪些，主要内容有？ 逻辑覆盖，循环覆盖，代码走查，静态数据流分析，代码评审，桌前检查，同行评审 5. 白盒测试逻辑覆盖有哪几种覆盖标准，覆盖率最高的是？ 语句覆盖，分支覆盖，条件覆盖，路径覆盖，分支条件覆盖。最高的是路径覆盖。 五、用例设计 1. 什么是测试用例，测试用例的基本要素？ 测试用例是为某个测试目标编写的一组输入、执行条件与预期结果，以便测试某个程序是否符合特定要求。 基本要素：测试索引，测试环境，测试输入，测试操作，预期结果，评价标准 2. 描述测试用例设计的完整过程 1）根据概要设计、需求文档、测试计划、测试方案细分出测试项 2）根据测试项，按照详细设计与测试方案中测试的覆盖率细分出测试子项 3）用测试设计方法（等价类划分，边界值，因果图等）编写测试用例 注意：用例一定要及时更新（补充与删除），要全面（考虑功能、性能、兼容性等） 3. 有个广告的纸杯子，请设计测试用例 基本功能测试（逻辑功能测试）。 1）硬度：是否达到设计标准。 装载能力:在杯子内分别装入少量的、半杯的、满杯的，看其装载量是否达到设计标准。 装载种类:开水(是否产生异味)、温水、冷水、冰水、咖啡。。 2）界面测试(UI 测试)。 看其形状、大小设计是否适合人方便拿起。 外观是否吸引人(广告嘛)，赏心悦目。 带广告的图案沾水受是否掉色、模糊。 3）易用性测试。 看其形状、大小设计是否适合人方便拿起。 残疾人士用此杯去喝水的容程度。 杯子设计是否上大下小，在运输过程中可以套在一起有效利用空间，在使用时也容易拿开。 4）稳定性测试（24 X 7 测试）。装入液体后记录其多少以后漏水。 5）安全性测试。杯子所用的材料(包括纸基、涂层和广告颜料)是否符合食品卫生标准，在内外温度等环境因素下是否会与所盛各种饮料相反应，而产生对人体有害的物质。 6）本地化测试。为国际化和本地化的需要，广告图案和文字是否在政治、宗教和文化方面具有广泛的适用性。 7）对设计的改进建议。“如果是一次性杯子，能否标示已使用(比如变色)”和“杯子是否有使用者标贴(多人使用时防止混淆)”。 4. 一个身份证号码输入框，怎么设计用例? 校验身份证号的规则有效性（地址码、生日编码、顺序码、校验码） 检验15位身份证和18位身份正好可用 校验末尾是x的情况 校验不足15位、16-17位和18位的情况 如果是必输项，空白时是否有提示与流程是否正常进行 如果不是必输项，校验不输入时流程能否正常进行 检验非数字的情况，是否会有正确提示信息（包括大小写字母，汉字，特殊字符与标点符号） 5. 登陆功能怎么设计测试用例？ 具体需求:有一个登录页面，有一个账号和一个密码输入框, 一个提交按钮。 此题的考察目的：1. 了解需求(测什么都是从了解需求开始)；2. 是否有设计 Test Case 的能力；3. 是否熟悉各种测试方法； 4. 是否有丰富的 Web 测试经验;；5. 是否了解 Web 开发。 了解需求：1. 登陆界面是弹出窗口式的，还是直接在网页里面；2. 账号长度和密码的强度要求（比如需要多少位、大小写敏感、特殊字符混搭）；3. 界面美观是否有特殊要求（是否要进行UI测试） 用例设计： 1）功能测试：Function Test 输入正确的账号密码，点击提交按钮，验证是否能正确登陆（正常输入） 输入错误的账号密码，验证登陆会失败，与给出相应的错误提示（错误输入） 登陆成功后能否正确跳转到正确界面 账号和密码如果太长或太短，应该怎么处理（安全性，密码太短都有提示） 账号和密码中，有特殊字符（比如空格）和其他非英文情况（是否做了顾虑） 账号和密码前后都有空格的处理 输入密码时，大写键盘有提示 密码是否加密显示 什么都不输，点击提交按钮，看提示信息 记住账号功能 登陆失败后，不能记录密码的功能 牵涉到验证码的，还要考虑验证难度是否过大，刷新或者换一个的按钮是否好用 登陆页面中的注册、忘记密码、登出、用另一账号等链接是否正确 2）界面测试：UI Test 布局是否合理，2个Testbox和1个按钮是否对其 Testbox和按钮的长度，高度是否符合要求 界面的设计风格是否与UI的设计风格统一 界面的文字简洁易懂，没有错别字 3）性能测试 Performance Test 打开登陆页面，需要几秒 输入正确的账号密码后，登陆成功跳转到新页面，不超过5秒 4）安全性测试 Security Test 登陆成功后生成的 Cookie 是否有 HttpOnly（降低脚本盗取风险） 账号密码是否通过加密的方式，发送到Web服务器 账号和密码的验证，应该是用服务器端验证，而不只是用客户端的JS分析 账号和密码的输入框，应该屏蔽SQL注入攻击 账号和密码的输入框，要禁止输入脚本（防止XSS攻击） 错误登陆的次数使用限制（防止暴力破解） 考虑是否支持多用户在同一机器上登陆 考虑一用户在多台机器登陆 5）可用性测试 Usability Test 是否可以用全键盘操作，是否有快捷键 输入账号，密码后回车，是否可以登陆 输入框是否可以用Tab切换 6）兼容性测试 Compatibility Test 主流浏览器功能是否正常 不同系统平台是否工作正常（Macos pc） 移动设备是否工作正常 不同分辨率 7）本地化测试 Localization Test 不同语言环境，页面显示是否正确 8）辅助性测试 高对比度下是否显示正常（视力不好的人）","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JS学习笔记-03","slug":"JS学习笔记-03","date":"2020-10-25T10:15:58.000Z","updated":"2020-10-25T10:17:13.246Z","comments":true,"path":"2020/10/25/JS学习笔记-03/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/","excerpt":"","text":"函数 定义函数 123456789//第一种function abs(x) &#123; &#125;//第二种var abs = function(x)&#123;&#125;/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/ 调用 调用函数时，按顺序传入参数。 JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数 123abs(10, &#x27;blablabla&#x27;); // 返回10abs(9, &#x27;haha&#x27;, &#x27;hehe&#x27;, null); // 返回9abs(); // 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免 arguments 获得调用者的所有参数，但不是一个Array 是一个关键字 只在函数内部起作用 1234567891011121314function foo(x) &#123; console.log(&#x27;x = &#x27; + x); // 10 for (var i=0; i&lt;arguments.length; i++) &#123; console.log(&#x27;arg &#x27; + i + &#x27; = &#x27; + arguments[i]); // 10, 20, 30 &#125;&#125;foo(10, 20, 30);/*x = 10arg 0 = 10arg 1 = 20arg 2 = 308*/ 要善于利用arguments判断传入参数多少的作用 rest参数 是ES6新增的特性，形式为：…变量名 作用：获取函数多余的参数 123456789101112131415161718//获取a，b之外的参数例子：function foo(a, b, ...rest) &#123; console.log(&#x27;a = &#x27; + a); console.log(&#x27;b = &#x27; + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined 因为b在参数中被定义了，要直接输出// Array [] 练习 用rest参数编写一个add()函数，用于接收任意个参数并返回她们的和。 12345678&#x27;use strict&#x27;;function sum(...rest)&#123; let sum=0; rest.forEach(function(elemnt)&#123; sum += element; &#125;); return sum;&#125; 定义一个计算圆面积的函数area_of_circle()，它有两个参数： r: 表示圆的半径； pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。 1234567891011121314&#x27;use strict&#x27;;function area_of_circle(r,pi)&#123; var area; if(arguments===1)&#123; area=Math.pow(r,2)*3.14; &#125;else&#123; area=Math.pow(r,2)*3.1416; &#125;&#125;//解构赋值function area_of_circle(r, pi)&#123; var[r,pi=3.14]=arguments; return pi*r*r;&#125; 变量作用域和解构赋值 变量提升 js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。 注意：只是变量的声明，并不是赋值。 块级作用域 ES6引入了新关键字 let，用let代替var可以声明一个块级作用域的变量。 12345678910&#x27;use strict&#x27;;function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; // SyntaxError: i += 1;&#125; 常量 ES6引入了一个const关键字来定义常量 12345&#x27;use strict&#x27;;const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 解构赋值 此知识点小点比较多，详细请看廖雪峰的官网 在ES6中，可以使用解构赋值，直接对多个变量同时赋值： 1var [x, y, z] = [&#x27;hello&#x27;, &#x27;JavaScript&#x27;, &#x27;ES6&#x27;]; 如果数组本身还有嵌套，只需要嵌套和层次对齐即可。 1var arr[x,[y,z]] = [1,[2,3]]; 从对象中取出其中几个属性的值，也可以用解构赋值 123456789101112131415161718var person=&#123; name: &#x27;tang&#x27;, tel: &#x27;12345&#x27;, age: 20, password: &#x27;S-12345&#x27;, address:&#123; city:&#x27;beijing&#x27;, street:No.1 Road, zipcode:&#x27;10000&#x27; &#125;&#125;;//把person的name和tel取出给var定义的name,telvar &#123;name,tel&#125;=person;console.log(&#x27;name=&#x27;+name+&#x27;,&#x27;+&#x27;tel=&#x27;+tel);/*name=tangtel=12345*/ 如果要对嵌套对象address里面的值进行赋值，也能用解构赋值： 1var &#123;name,address:&#123;city,street&#125;&#125;=person; 如果要使用的变量名和属性名不一致，可以用下面的语法获取： 123var &#123;name,password:id&#125;=person;//这里就是把password「属性」赋值给了变量id//注意：是把password这个属性赋值给了id，所以password不是一个变量 有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把&#123;开头的语句做块处理，= 不再合法。 123var x,y;&#123;x,y&#125;=&#123;x:100,y:300&#125;;//解决办法，用()括起来 方法 this关键字 this是一个特殊变量，始终指向当前对象。下面的例子就是this指向的对象是小明。 12345678var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:function()&#123; var y = new Date().getFullYear(); return y-this.birth; //当前对象为xiaoming &#125;&#125; 但想要把age方法里面的内容拆开写，要怎么办呢？ 123456789101112131415//写一个getAge()方法function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;//编写小明对象var xiaoming=&#123; ame:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;//情况一：xiaoming.age();//正常返回25//情况二：getAge; //NaN 为什么情况二返回的是NaN？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。 想要指向正确，必须用obj.xxx()的形式调用，也就是「对象.方法名」 that 我们先看看下面： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，this指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。 修复方法：使用that变量，在方法内部一开始就首先捕获this： 1234567891011121314&#x27;use strict&#x27;;var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990, age: function () &#123; var that = this; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age();//25 用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。 apply 可以指定函数的this指向哪个对象，apply(this要指定的对象 , Array函数本身的参数) 1234567891011function getAge()&#123; var y=new Date().getFullYear(); return y-this.birth;&#125;var xiaoming=&#123; name:&#x27;xiaoming&#x27;, birth:1990, age:getAge&#125;xiaoming.getAge();//25getAge.apply(xiaoming,[]); apply()把参数打包成Array再传入；call()把参数按顺序传入。二者功能类似。 例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下： 12Math.max.apply(null,[3,4,5]);Math.max.call(null,3,4,5); 高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。 所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。 1234567&#x27;use strict&#x27;;function add(x, y, f) &#123; //add函数的参数为x,y,f，而参数f是一个函数 return f(x) + f(y);&#125;var x = add(-5, 6, Math.abs); console.log(x);// 11 高阶函数将在下一篇博文详解","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-02","slug":"JS学习笔记-02","date":"2020-10-25T10:11:47.000Z","updated":"2020-10-25T10:12:58.998Z","comments":true,"path":"2020/10/25/JS学习笔记-02/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/","excerpt":"","text":"循环 for for循环三个条件可省略，但如果无退出条件，则死循环。退出：break 12345678var x=0;for(;;)&#123; if(x&gt;100)&#123; break; &#125; x++;&#125; for…in 用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三） 1234567891011121314151617181920212223//例一var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; console.log(key); //&#x27;name&#x27; &#x27;age&#x27; &#x27;school&#x27;&#125;//例二var arr=[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;];for(var i in arr)&#123; console.log(i); //‘0’，‘1’，‘2‘ /*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/ /*请注意，for ... in对Array的循环得到的是String而不是Number。*/&#125;//例三var arr=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;];for(var i in arr)&#123; console.log(arr[i]); //&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;&#125; 要过滤继承属性，使用day01学的hasOwnProperty()方法实现。例如： ps：或者使用for...of，这也是为什么设计for...of的原因之一。 12345678910var o=&#123; name: &#x27;小明&#x27;, age: 12, school: &#x27;js&#x27;&#125;for(var key in o)&#123; if(o.hasOwnProperty(key))&#123; console.log(key); //不然会输出toString属性 &#125;&#125; hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性key」 练习 请利用循环遍历数组中的每个名字 123456789101112&#x27;use strict&#x27;; var arr = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;];//法1for(var key in arr)&#123; console.log(arr[key]);&#125;//法2var i=arr.length-1;while(i&gt;=0)&#123; console.log(arr[i]) i--;&#125; for…of for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。 for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象 参考 张鑫旭大佬的文章 Map和Set Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。 Map Map是一组「键值对」的结构，具有极快的查找速度。例： 123var m new Map([&#x27;Micheal&#x27;,95],[&#x27;Bob&#x27;,88],[&#x27;Tracy&#x27;,93])m.get(&#x27;Micheal&#x27;); //返回的是95！//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字 其他操作如下： 12345var m= new Map(); //新建空Mapm.set(&#x27;tang&#x27;,100); //添加新 key-valuem.set(&#x27;tang&#x27;,1); //覆盖上面的100，返回1m.has(&#x27;tang&#x27;); //返回truem.delete(&#x27;tang&#x27;); Set 与Map不同，Set只存「key」，不存「value」。key不能重复。 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, &#x27;3&#x27;]);s; // Set &#123;1, 2, 3, &quot;3&quot;&#125; 注意数字3和字符串'3'是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4);s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;s.add(4);s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s &#x3D; new Set([1, 2, 3]);s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;s.delete(3);s; &#x2F;&#x2F; Set &#123;1, 2&#125; iterable &amp; for…of Array可以下标循环，但遍历Map 和Set就无法使用下标。为了统一集合类型，ES6引入了iterable类型，Array 、Map和Set 都属于iterable类型。 具有iterable类型的「集合」，可以通过for...of循环来遍历","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"JS学习笔记-01","slug":"JS学习笔记-01","date":"2020-10-25T10:05:55.000Z","updated":"2020-10-25T10:10:09.050Z","comments":true,"path":"2020/10/25/JS学习笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/","excerpt":"","text":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name 变量 只能用var申明一次。没用var申明的变量：全局变量 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 strict模式 'use strict';强制通过var申明 二、字符串 多行字符串 由于多行字符串用\\n写起来费事，最新的ES6标准新增了如下方式表示： 123&#96;这是一个多行字符串&#96;; 模板字符串 很多变量连接时 1234var name &#x3D; &#39;小明&#39;;var age &#x3D; 20;var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;alert(message); 三、数组 indexOf() 搜索指定元素的位置 12345var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2 slice() 截取Array的部分元素，返回一个新的Array 123var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] slice()的起止参数包括开始索引，不包括结束索引 如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组 1234var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];var aCopy &#x3D; arr.slice();aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false push() 和 pop() push()插入数组尾部 pop()删除～ unshift() 和 shift() unshift()插入 头部第一 shift()删除头部第一 reverse() 数组的反转 splice() 修改数组的万能方法，格式为：从哪里开始，删除多少个，添加什么 12345678910var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只删除,不添加:arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只添加,不删除:arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;] concat() 连接两个数组。没有修改原数组，只是生成新数组 join() 把array里面的元素，用指定的字符连起来 123var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];arr.join(&#39;-&#39;);arr;返回的就是&#39;a-b&#39; ps：如果Array的元素不是字符串，则自动转化再拼接 三、对象 用[‘x’]访问（少用） 属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用.访问 1234var xiaohong &#x3D; &#123; name: &#39;小红&#39;, &#39;middle-school&#39;: &#39;No.1 Middle School&#39;&#125;; 123xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;xiaohong.name; &#x2F;&#x2F; &#39;小红&#39; ps：写代码尽量规范，尽量用.访问 由于对象是动态类型，因此可以随便给对象添加或修改属性 123456789101112var xiaoming&#x3D;&#123; name: &#39;小明&#39;&#125;;xiaoming.age; &#x2F;&#x2F;undefinedxiaoming.age&#x3D;18; &#x2F;&#x2F;添加了age属性delete xiaoming.age; &#x2F;&#x2F;删除name属性xiaoming.age; &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefineddelete xiaoming.name; &#x2F;&#x2F;删除namexiaoming.name; &#x2F;&#x2F;undefineddelete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined 检测属性存在性 用in操作符，返回布尔值 123456var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990,&#125;;&#x27;name&#x27; in xiaoming; // true&#x27;grade&#x27; in xiaoming; // false 注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用hasOwnProperty() 12345var xiaoming=&#123; name=&quot;小明&quot;;&#125;xiaoming.hasOwnProperty(&#x27;name&#x27;); //truexiaoming.hasOwnProperty(&#x27;toString&#x27;); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"正则表达式-01","slug":"正则表达式-01","date":"2020-10-25T09:57:31.000Z","updated":"2020-10-25T09:59:44.323Z","comments":true,"path":"2020/10/25/正则表达式-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/","excerpt":"","text":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符： 复杂例子：\\d&#123;3&#125;\\s+\\d&#123;3,8&#125;。 我们来从左到右解读一下： \\d&#123;3&#125;表示匹配3个数字，例如'010'； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配' '，'\\t\\t'等； \\d&#123;3,8&#125;表示3-8个数字，例如'1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\\'转义，所以，上面的正则是\\d&#123;3&#125;\\-\\d&#123;3,8&#125;。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、开头，后接任意个由一个数字、字母或者下划线、开头，后接任意个由一个数字、字母或者下划线、开头，后接任意个由一个数字、字母或者下划线、组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 使用 1234var re1=/ABC\\-001/var re2=new RegExp(&#x27;ABC\\\\-001&#x27;) //字符串的转义问题，字符串的两个\\\\实际上是一个\\。re1; // /ABC\\-001/re2; // /ABC\\-001/ 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 1&#39;a b c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;] 嗯，无法识别连续的空格，用正则表达式试试： 1&#39;a b c&#39;.split(&#x2F;\\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 无论多少个空格都可以正常分割。加入,试试： 1&#39;a,b, c d&#39;.split(&#x2F;[\\s\\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 再加入;试试： 1&#39;a,b;; c d&#39;.split(&#x2F;[\\s\\,\\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 用()表示的就是要提取的分组（Group）。比如： ^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re &#x3D; &#x2F;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x2F;;re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec(&#x27;19:05:30&#x27;); // [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： 12var re = /^(\\d+?)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 123var r1 = /test/g;// 等价于:var r2 = new RegExp(&#x27;test&#x27;, &#x27;g&#x27;); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 1234567891011121314151617var s = &#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;;var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // [&#x27;JavaScript&#x27;]re.lastIndex; // 10re.exec(s); // [&#x27;VBScript&#x27;]re.lastIndex; // 20re.exec(s); // [&#x27;JScript&#x27;]re.lastIndex; // 29re.exec(s); // [&#x27;ECMAScript&#x27;]re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"MySQL-01","slug":"MySQL-01","date":"2020-10-21T06:37:29.000Z","updated":"2020-10-21T09:16:49.864Z","comments":true,"path":"2020/10/21/MySQL-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/21/MySQL-01/","excerpt":"","text":"单表 增 基本用法： select 用法是select 字段 from 表名 例如：select id,name from t_studeng表示从t_student表查找id到name的字段 where查询条件 1select *from t_student where age&#x3D;20 and xueli&#x3D;&#39;本科&#39;; 增 1insert into 表名(&#39;id&#39;,&#39;name&#39;,&#39;age&#39;) values(&#39;10&#39;,&#39;名字&#39;,&#39;20&#39;); 改 12345678update 表名set 字段1&#x3D;值1where 条件;例如：update t_studentset age&#x3D;20where id&#x3D;10; 删除 1delete from 表名 where id&#x3D;1; 多表联查 两个表 1select from t_student join t_class on t_class.id&#x3D;t_student.cid; 12A join B &#x3D; 表A+表Bon &#x3D; 表A与表B的连接点cid+表B的id（反正就是表A的尾部和表B头部相连） ​ 从上图可以看到，两张表关联起来后会出现cid和id和两个remark，这个查询结果显得不够精简。如何选择 关联后新表的部分数据呢？ 1select s.id,name,age,classname from t_student s join t_class c on s.cid&#x3D;c.id; ​ 注意，可以通过t_student s与t_class c的方式，把冗长的表名用简单的单词替代。另外，上面的s.id,name,classname，不用写成s.id,s.name,c.classname，因为合并后是以t_student的id做为主键的。 ​ select与from之间的内容，永远都作「条件」，from后面的永远为「表」或者「关联的新表」（用join连接），on为「连接点」。 三个表 可以在两个表的基础上，再在后面 join第三个表即可。 1select s.id,name,classname,chinese,math,english from t_student s join t_class c on s.cid&#x3D;c.id join t_grade g on c.id&#x3D;g.sid where math&gt;60; 数据库常用命令和实际应用 模糊查询 like 1select *from t_student where name like &#39;张%&#39;; 张%：表示张开头，那么%张则表示以张结尾。 排序 order by 12select *from t_student order by age; &#x2F;&#x2F;正序select *from t_student order by age desc; &#x2F;&#x2F;倒序 统计 count 1select count(*) from t_student; 拓展： 上图中显示的 count(*) 不太美观，可以通过 as 重命名（在终端的显示名） 1select count(*) as &#39;数量&#39; from t_student; &#x2F;&#x2F;as其实也可省略 min、max、sum 1select max(age) from t_student; 分组 group by 1select classname,max(age) from t_class c join t_student s on c.id&#x3D;s.id group by classname; 解释：先用 classname 来分组，然后再分组之后计算 max。 如果把上面的 age 去掉，就会出错。因为如果按照 classname 分成了两组，但是我还查询了很多个 age 等待着显示出来，也就是一组 classname 对应着多个 age，自然就出错了。 所以，其实分组就是说要在分组后，还要进行部分操作（min，max，sum，avg等）才行。 例二： 如果我要算不同年龄分别共有多少人？ 1select age,count(*) from t_student group by age;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"软件测试笔记-01","slug":"软件测试笔记-01","date":"2020-10-20T14:24:10.000Z","updated":"2020-10-25T10:18:34.555Z","comments":true,"path":"2020/10/20/软件测试笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/","excerpt":"","text":"什么是软件测试 是为了保障软件质量的，找出预期结果是否符合实际结果 软件测试的分类 方法 黑盒测试：看不到内部结构，只暴露外部接口。方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图等 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。主要技术有逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等 一个模块中的所有独立路径至少被测试一次。 所有逻辑值均需测试true和false两种情况。 检査程序的内部数据结构，保证其结构的有效性。 在取值的上、下边界及可操作范围内运行所有循环。 灰盒测试：相当于结合了以上两种 方向 功能测试：看功能是否正常。 黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做） 性能测试：判断程序能做多好（与时间挂钩） 压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。 负载测试：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟） 以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。 并发测试：一瞬间同一个程序在做同一件事情 安全测试（了解）：防止攻击，例如ddos等 阶段 单元测试： 重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。 单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态z1数据流分析 集成测试：重点测试「接口」 系统测试：功能、安全、性能、兼容性、易用性、稳定性…… 验收测试 对象 APP测试、Web测试、物联网、小程序……其实都是软件测试。所以重点还是上面的方法与方向。 状态 根据软件的状态划分的 静态：不会运行的软件，通过白盒测试看代码 动态：把软件运行起来测试 其他 冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试） 回归测试：回归bug，bug修改了，有没有检查。 Alpha测试：内测 Beta测试：公测 研发管理模型 作用：在开发中会经历很多过程，模型可以知道不同的工作流程。 瀑布流 从上往下，不可逆不可返回的流程。 V字型 左边是开发做的，右边是测试做的，二者一一对照。 w字型 测试与开发同步了。 测试流程 需求分析阶段 需求分析 需求文档：产品经理用文档描述 产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。） 口述 学习业务流程： 提取功能点：把小功能提取出来，做成树状图 编写需求分析说明书 测试设计阶段 前三个由产品经理或者组长写，方法是：5W1H 测试计划：时间、人、资源的分配 测试方案 每个测试内容如何展开 采用什么测试计划 哪些内容先测 测试策略 哪些内容先测后测（先测功能还是兼容？） 开始和结束的标准是什么？ 测试用例（重点！重中之重！） 包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。 用例编号：唯一的 用例名称：言简意赅 前置条件：在执行用例前，软件必须要满足的条件 优先级：执行用例的时间要求紧急的等级 重要级：被测功能在软件中的重要等级 要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ） 测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方 测试执行阶段 上面测试完后，得到了「测试用例」，接下来就要对用例进行执行了。 测试总结阶段 测试方法 等价类 通过少部分的值，代表大部分的情况。 有效等价类 满足条件的：0.01，0.02，200，199.99 无效等价类 不满足条件的：0，200.01 边界法 0，负数，+1，-1，本身，整数，非整数，字符 例如： 一个函数的入参是一个int类型，但是有效输入只有[0,100]范围的数，如果你要测试这个函数，你会选择以下哪组入参，是最全面且最精简的（ ） 可以测试越界的，这里可以使用 -1、101，数组的前两位 0、1，数组的最后两位 99、100，中部一位 67。可以测试所有情况。所以答案为：-1,0,1,67,99,100,101 场景法 …… 后续更新","categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-13T03:51:26.002Z","updated":"2020-10-13T03:51:26.002Z","comments":true,"path":"2020/10/13/hello-world/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"},{"name":"面试","slug":"面试","permalink":"https://blog.tangspoon.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]}