{"meta":{"title":"Mark my mind","subtitle":"做个善于记录的人","description":"","author":"tangspoon","url":"https://blog.tangspoon.cn","root":"/"},"pages":[{"title":"关于","date":"2020-10-13T06:57:39.565Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"about/index.html","permalink":"https://blog.tangspoon.cn/about/","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2020-10-13T06:57:39.553Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"/404.html","permalink":"https://blog.tangspoon.cn/404","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-13T06:57:39.599Z","updated":"2020-10-13T06:44:25.203Z","comments":true,"path":"links/index.html","permalink":"https://blog.tangspoon.cn/links/","excerpt":"","text":""},{"title":"分类","date":"2020-10-13T06:57:39.587Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"categories/index.html","permalink":"https://blog.tangspoon.cn/categories/","excerpt":"","text":""},{"title":"书单","date":"2020-10-13T06:57:39.576Z","updated":"2020-10-13T06:44:25.202Z","comments":false,"path":"books/index.html","permalink":"https://blog.tangspoon.cn/books/","excerpt":"","text":""},{"title":"标签","date":"2020-10-13T06:57:39.622Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"tags/index.html","permalink":"https://blog.tangspoon.cn/tags/","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-13T06:57:39.610Z","updated":"2020-10-13T06:44:25.203Z","comments":false,"path":"repository/index.html","permalink":"https://blog.tangspoon.cn/repository/","excerpt":"","text":""}],"posts":[{"title":"JS学习笔记-01","slug":"JS学习笔记-01","date":"2020-10-25T10:05:55.000Z","updated":"2020-10-25T10:10:09.050Z","comments":true,"path":"2020/10/25/JS学习笔记-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/","excerpt":"","text":"基础的语法不再赘述，只强调以前未接触过的。 一、数据类型和变量 对象 键值对组成 12345678var person = &#123; name: &#x27;Bob&#x27;, age: 20, tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;], city: &#x27;Beijing&#x27;, hasCar: true, zipcode: null&#125;; Person为对象，name、age为键，‘Bob’、20为值 获取对象的属性（怎么用对象的数据）：person.name 变量 只能用var申明一次。没用var申明的变量：全局变量 12var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串 strict模式 'use strict';强制通过var申明 二、字符串 多行字符串 由于多行字符串用\\n写起来费事，最新的ES6标准新增了如下方式表示： 123&#96;这是一个多行字符串&#96;; 模板字符串 很多变量连接时 1234var name &#x3D; &#39;小明&#39;;var age &#x3D; 20;var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;alert(message); 三、数组 indexOf() 搜索指定元素的位置 12345var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2 slice() 截取Array的部分元素，返回一个新的Array 123var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;] slice()的起止参数包括开始索引，不包括结束索引 如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组 1234var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];var aCopy &#x3D; arr.slice();aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false push() 和 pop() push()插入数组尾部 pop()删除～ unshift() 和 shift() unshift()插入 头部第一 shift()删除头部第一 reverse() 数组的反转 splice() 修改数组的万能方法，格式为：从哪里开始，删除多少个，添加什么 12345678910var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只删除,不添加:arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]&#x2F;&#x2F; 只添加,不删除:arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;] concat() 连接两个数组。没有修改原数组，只是生成新数组 join() 把array里面的元素，用指定的字符连起来 123var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];arr.join(&#39;-&#39;);arr;返回的就是&#39;a-b&#39; ps：如果Array的元素不是字符串，则自动转化再拼接 三、对象 用[‘x’]访问（少用） 属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用.访问 1234var xiaohong &#x3D; &#123; name: &#39;小红&#39;, &#39;middle-school&#39;: &#39;No.1 Middle School&#39;&#125;; 123xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;xiaohong.name; &#x2F;&#x2F; &#39;小红&#39; ps：写代码尽量规范，尽量用.访问 由于对象是动态类型，因此可以随便给对象添加或修改属性 123456789101112var xiaoming&#x3D;&#123; name: &#39;小明&#39;&#125;;xiaoming.age; &#x2F;&#x2F;undefinedxiaoming.age&#x3D;18; &#x2F;&#x2F;添加了age属性delete xiaoming.age; &#x2F;&#x2F;删除name属性xiaoming.age; &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefineddelete xiaoming.name; &#x2F;&#x2F;删除namexiaoming.name; &#x2F;&#x2F;undefineddelete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined 检测属性存在性 用in操作符，返回布尔值 123456var xiaoming = &#123; name: &#x27;小明&#x27;, birth: 1990,&#125;;&#x27;name&#x27; in xiaoming; // true&#x27;grade&#x27; in xiaoming; // false 注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用hasOwnProperty() 12345var xiaoming=&#123; name=&quot;小明&quot;;&#125;xiaoming.hasOwnProperty(&#x27;name&#x27;); //truexiaoming.hasOwnProperty(&#x27;toString&#x27;); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"}]},{"title":"正则表达式-01","slug":"正则表达式-01","date":"2020-10-25T09:57:31.000Z","updated":"2020-10-25T09:59:44.323Z","comments":true,"path":"2020/10/25/正则表达式-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/","excerpt":"","text":"简单 \\d 匹配数字 \\w 匹配字母 . 匹配所有 例如：00\\d 可以匹配000～009，00\\w 可以匹配00a～00z，\\w\\w 可以匹配 aa，\\w. 可以匹配 js、j1、j! 等 *表示任意个字符（包括0个） +表示至少一个字符 ?表示0个或1个字符 &#123;n&#125;表示n个字符 &#123;n,m&#125;表示n-m个字符： 复杂例子：\\d&#123;3&#125;\\s+\\d&#123;3,8&#125;。 我们来从左到右解读一下： \\d&#123;3&#125;表示匹配3个数字，例如'010'； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配' '，'\\t\\t'等； \\d&#123;3,8&#125;表示3-8个数字，例如'1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\\'转义，所以，上面的正则是\\d&#123;3&#125;\\-\\d&#123;3,8&#125;。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、开头，后接任意个由一个数字、字母或者下划线、开头，后接任意个由一个数字、字母或者下划线、开头，后接任意个由一个数字、字母或者下划线、组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。 使用 1234var re1=/ABC\\-001/var re2=new RegExp(&#x27;ABC\\\\-001&#x27;) //字符串的转义问题，字符串的两个\\\\实际上是一个\\。re1; // /ABC\\-001/re2; // /ABC\\-001/ 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 1&#39;a b c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;] 嗯，无法识别连续的空格，用正则表达式试试： 1&#39;a b c&#39;.split(&#x2F;\\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 无论多少个空格都可以正常分割。加入,试试： 1&#39;a,b, c d&#39;.split(&#x2F;[\\s\\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 再加入;试试： 1&#39;a,b;; c d&#39;.split(&#x2F;[\\s\\,\\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 用()表示的就是要提取的分组（Group）。比如： ^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： 123var re &#x3D; &#x2F;^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$&#x2F;;re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 提取子串非常有用。来看一个更凶残的例子： 12var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;re.exec(&#x27;19:05:30&#x27;); // [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;] 这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期： 1var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/; 对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 12var re = /^(\\d+)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： 12var re = /^(\\d+?)(0*)$/;re.exec(&#x27;102300&#x27;); // [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： 123var r1 = /test/g;// 等价于:var r2 = new RegExp(&#x27;test&#x27;, &#x27;g&#x27;); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： 1234567891011121314151617var s = &#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;;var re=/[a-zA-Z]+Script/g;// 使用全局匹配:re.exec(s); // [&#x27;JavaScript&#x27;]re.lastIndex; // 10re.exec(s); // [&#x27;VBScript&#x27;]re.lastIndex; // 20re.exec(s); // [&#x27;JScript&#x27;]re.lastIndex; // 29re.exec(s); // [&#x27;ECMAScript&#x27;]re.lastIndex; // 44re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"MySQL-01","slug":"MySQL-01","date":"2020-10-21T06:37:29.000Z","updated":"2020-10-21T09:16:49.864Z","comments":true,"path":"2020/10/21/MySQL-01/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/21/MySQL-01/","excerpt":"","text":"单表 增 基本用法： select 用法是select 字段 from 表名 例如：select id,name from t_studeng表示从t_student表查找id到name的字段 where查询条件 1select *from t_student where age&#x3D;20 and xueli&#x3D;&#39;本科&#39;; 增 1insert into 表名(&#39;id&#39;,&#39;name&#39;,&#39;age&#39;) values(&#39;10&#39;,&#39;名字&#39;,&#39;20&#39;); 改 12345678update 表名set 字段1&#x3D;值1where 条件;例如：update t_studentset age&#x3D;20where id&#x3D;10; 删除 1delete from 表名 where id&#x3D;1; 多表联查 两个表 1select from t_student join t_class on t_class.id&#x3D;t_student.cid; 12A join B &#x3D; 表A+表Bon &#x3D; 表A与表B的连接点cid+表B的id（反正就是表A的尾部和表B头部相连） ​ 从上图可以看到，两张表关联起来后会出现cid和id和两个remark，这个查询结果显得不够精简。如何选择 关联后新表的部分数据呢？ 1select s.id,name,age,classname from t_student s join t_class c on s.cid&#x3D;c.id; ​ 注意，可以通过t_student s与t_class c的方式，把冗长的表名用简单的单词替代。另外，上面的s.id,name,classname，不用写成s.id,s.name,c.classname，因为合并后是以t_student的id做为主键的。 ​ select与from之间的内容，永远都作「条件」，from后面的永远为「表」或者「关联的新表」（用join连接），on为「连接点」。 三个表 可以在两个表的基础上，再在后面 join第三个表即可。 1select s.id,name,classname,chinese,math,english from t_student s join t_class c on s.cid&#x3D;c.id join t_grade g on c.id&#x3D;g.sid where math&gt;60; 数据库常用命令和实际应用 模糊查询 like 1select *from t_student where name like &#39;张%&#39;; 张%：表示张开头，那么%张则表示以张结尾。 排序 order by 12select *from t_student order by age; &#x2F;&#x2F;正序select *from t_student order by age desc; &#x2F;&#x2F;倒序 统计 count 1select count(*) from t_student; 拓展： 上图中显示的 count(*) 不太美观，可以通过 as 重命名（在终端的显示名） 1select count(*) as &#39;数量&#39; from t_student; &#x2F;&#x2F;as其实也可省略 min、max、sum 1select max(age) from t_student; 分组 group by 1select classname,max(age) from t_class c join t_student s on c.id&#x3D;s.id group by classname; 解释：先用 classname 来分组，然后再分组之后计算 max。 如果把上面的 age 去掉，就会出错。因为如果按照 classname 分成了两组，但是我还查询了很多个 age 等待着显示出来，也就是一组 classname 对应着多个 age，自然就出错了。 所以，其实分组就是说要在分组后，还要进行部分操作（min，max，sum，avg等）才行。 例二： 如果我要算不同年龄分别共有多少人？ 1select age,count(*) from t_student group by age;","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"}]},{"title":"软件测试01-基础知识","slug":"软件测试01-基础知识","date":"2020-10-20T14:24:10.000Z","updated":"2020-10-21T12:15:39.386Z","comments":true,"path":"2020/10/20/软件测试01-基础知识/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9501-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"什么是软件测试 是为了保障软件质量的，找出预期结果是否符合实际结果 软件测试的分类 方法 黑盒测试：看不到内部结构，只暴露外部接口。方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图等 白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。主要技术有逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等 一个模块中的所有独立路径至少被测试一次。 所有逻辑值均需测试true和false两种情况。 检査程序的内部数据结构，保证其结构的有效性。 在取值的上、下边界及可操作范围内运行所有循环。 灰盒测试：相当于结合了以上两种 方向 功能测试：看功能是否正常。 黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做） 性能测试：判断程序能做多好（与时间挂钩） 压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。 负载测试：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟） 以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。 并发测试：一瞬间同一个程序在做同一件事情 安全测试（了解）：防止攻击，例如ddos等 阶段 单元测试： 重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。 单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态z1数据流分析 集成测试：重点测试「接口」 系统测试：功能、安全、性能、兼容性、易用性、稳定性…… 验收测试 对象 APP测试、Web测试、物联网、小程序……其实都是软件测试。所以重点还是上面的方法与方向。 状态 根据软件的状态划分的 静态：不会运行的软件，通过白盒测试看代码 动态：把软件运行起来测试 其他 冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试） 回归测试：回归bug，bug修改了，有没有检查。 Alpha测试：内测 Beta测试：公测 研发管理模型 作用：在开发中会经历很多过程，模型可以知道不同的工作流程。 瀑布流 从上往下，不可逆不可返回的流程。 V字型 左边是开发做的，右边是测试做的，二者一一对照。 w字型 测试与开发同步了。 测试流程 需求分析阶段 需求分析 需求文档：产品经理用文档描述 产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。） 口述 学习业务流程： 提取功能点：把小功能提取出来，做成树状图 编写需求分析说明书 测试设计阶段 前三个由产品经理或者组长写，方法是：5W1H 测试计划：时间、人、资源的分配 测试方案 每个测试内容如何展开 采用什么测试计划 哪些内容先测 测试策略 哪些内容先测后测（先测功能还是兼容？） 开始和结束的标准是什么？ 测试用例（重点！重中之重！） 包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。 用例编号：唯一的 用例名称：言简意赅 前置条件：在执行用例前，软件必须要满足的条件 优先级：执行用例的时间要求紧急的等级 重要级：被测功能在软件中的重要等级 要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ） 测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方 测试执行阶段 上面测试完后，得到了「测试用例」，接下来就要对用例进行执行了。 测试总结阶段 测试方法 等价类 通过少部分的值，代表大部分的情况。 有效等价类 满足条件的：0.01，0.02，200，199.99 无效等价类 不满足条件的：0，200.01 边界法 0，负数，+1，-1，本身，整数，非整数，字符 例如： 一个函数的入参是一个int类型，但是有效输入只有[0,100]范围的数，如果你要测试这个函数，你会选择以下哪组入参，是最全面且最精简的（ ） 可以测试越界的，这里可以使用 -1、101，数组的前两位 0、1，数组的最后两位 99、100，中部一位 67。可以测试所有情况。所以答案为：-1,0,1,67,99,100,101 场景法 …… 后续更新","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-13T03:51:26.002Z","updated":"2020-10-13T03:51:26.002Z","comments":true,"path":"2020/10/13/hello-world/","link":"","permalink":"https://blog.tangspoon.cn/2020/10/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/categories/JavaScript/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/categories/MySQL/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.tangspoon.cn/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.tangspoon.cn/tags/MySQL/"},{"name":"软件测试","slug":"软件测试","permalink":"https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}]}