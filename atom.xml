<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tang&#39;s blog</title>
  
  <subtitle>做个善于记录的人</subtitle>
  <link href="https://blog.tangspoon.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.tangspoon.cn/"/>
  <updated>2020-10-27T16:56:34.425Z</updated>
  <id>https://blog.tangspoon.cn/</id>
  
  <author>
    <name>tang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人理解TCP/IP</title>
    <link href="https://blog.tangspoon.cn/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/"/>
    <id>https://blog.tangspoon.cn/2020/10/28/%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3TCP:IP/</id>
    <published>2020-10-27T16:53:05.000Z</published>
    <updated>2020-10-27T16:56:34.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文学习参考文章：<a href="https://www.odaily.com/post/5133541">https://www.odaily.com/post/5133541</a></p></blockquote><h2 id="tcpip是什么"><a class="markdownIt-Anchor" href="#tcpip是什么"></a> TCP/IP是什么？</h2><p>TCP/IP不只是只有TCP、IP两个协议，其实是互联网相关的各类协议族的总称。包括：TCP，UDP，IP，FTP，ICMP，SMTP……</p><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201027172813069.png" alt="image-20201027172813069" /></p><blockquote><p>不同的协议层对数据包有不同的称谓，在传输层叫做段 (segment)，在网络层叫做数据报 (datagram)，在链路层叫做帧 (frame)。</p></blockquote><h2 id="tcpip的分层管理"><a class="markdownIt-Anchor" href="#tcpip的分层管理"></a> TCP/IP的分层管理</h2><p>TCP/IP参考模型：网络接口层、网络层、传输层和应用层。<img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/tcp_osi.jpg" alt="tcp_osi" style="zoom:80%;" /></p><p>网络上很多会从下往上理解，但从上往下会更符合普通用户的理解。</p><ul><li><p>应用层：这一层的任务是：将接收到的数据包按照「协议」解读成各种类型的数据，然后把这些数据打包传到下一层：传输层。协议有：HTTP、FTP、SMTP、Telnet、NFS、RIP等。</p><p>例如：我要发一封邮件，就要用SMTP协议把数据包解读，传给传输层帮我传输。</p></li><li><p>传输层（TCP层）：这层的任务是：确保分割的单元在另一端正确地到达，它建立端口到端口的连接。用TCP/UDP协议，把应用层传来的数据进行分割成以数据报文段为单位的数据包交给下一层（网络层）。（这是在「网络」中两台机器互相传数据。）</p></li><li><p>网络层（IP层）：这层的任务是把传输层的数据，在众多的路由器中「找到路」，传给下一层。</p><p>该层常见的协议有：IP，ICMP，ARP，RARP</p></li><li><p>网络接口层（数据连接+物理层）：负责传输「局域网」的数据。这层使用什么协议取决于所使用的无力网络：如果物理网是LAN，那么通常使用的是以太网协议以及他的变体。</p><p>两台主机之间是通过网卡进行发送和接受数据的，**以太网在「子网」内以广播的形式发送数据。**光靠MAC地址并不能让两台主机通信，因为如果两台主机不在同一子网，以太网协议就不能用了。这时需要通过网路层来区分每台主机所在的网络是哪个子网。</p></li></ul><p>上面的整个流程举个例子：我向我朋友发一封邮件，内容为“你好！”，这时候在「应用层」就使用SMTP协议对邮件内容进行打包整理，传给「传输层」，用TCP/UDP协议来切割数据（传输的过程都是在网络中进行的，不是局域网）。可是数据都要传去哪里呢？这件事交给「网络层」（IP），它会选择一条路径把交到离你最近的路由器上，再由光线传到我们家里的广猫中，这个时候就交给「网络接口层的协议」发挥作用了，在局域网中把广猫的数据通过网线或wifi发送到我们的电脑网卡中开始接收。</p><h2 id="tcp-udp与其他"><a class="markdownIt-Anchor" href="#tcp-udp与其他"></a> TCP、UDP与其他</h2><p>TCP协议：面向连接的、基于字节流的、可靠的传输层通信协议</p><ul><li><p>面向连接：需要经过三次握手后，client与servers端才会开始进行数据的传输（但我握手过程中传送的包不包含任何数据）</p></li><li><p>稳定可靠：能把数据准确可靠地传给对方，简单来说就是，它把数据切成一个个数据包，从第一只数据包开始传，传送成功就翻倍，发现失败就地爬起来，从绊倒的那只数据包重新开始，周而复始。</p></li><li><p>基于字节流服务：把大块数据分割成以报文段为单位的数据包进行管理。</p></li></ul><p>UDP、ARP、RARP概念相对简单，具体可以参考文章：<a href="https://www.odaily.com/post/5133541">一文看懂互联网TCP/UDP协议</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文学习参考文章：&lt;a href=&quot;https://www.odaily.com/post/5133541&quot;&gt;https://www.odaily.com/post/5133541&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;tcp</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.tangspoon.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络基础" scheme="https://blog.tangspoon.cn/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS学习笔记-03</title>
    <link href="https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/"/>
    <id>https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-03/</id>
    <published>2020-10-25T10:15:58.000Z</published>
    <updated>2020-10-25T10:17:13.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3><h4 id="定义函数"><a class="markdownIt-Anchor" href="#定义函数"></a> 定义函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在这种方式下，function (x) &#123; ... &#125;是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。*/</span></span><br></pre></td></tr></table></figure><h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4><p>调用函数时，按顺序传入参数。</p><blockquote><p>JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>, <span class="string">&#x27;blablabla&#x27;</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(<span class="number">9</span>, <span class="string">&#x27;haha&#x27;</span>, <span class="string">&#x27;hehe&#x27;</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></span><br><span class="line">abs(); <span class="comment">// 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。用typeof方法可以避免</span></span><br></pre></td></tr></table></figure><h4 id="arguments"><a class="markdownIt-Anchor" href="#arguments"></a> arguments</h4><ul><li>获得调用者的所有参数，但不是一个<code>Array</code></li><li>是一个关键字</li><li>只在函数内部起作用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;x = &#x27;</span> + x); <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;arg &#x27;</span> + i + <span class="string">&#x27; = &#x27;</span> + <span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x = 10</span></span><br><span class="line"><span class="comment">arg 0 = 10</span></span><br><span class="line"><span class="comment">arg 1 = 20</span></span><br><span class="line"><span class="comment">arg 2 = 308</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>要善于利用<code>arguments</code>判断传入参数多少的作用</p></blockquote><h4 id="rest参数"><a class="markdownIt-Anchor" href="#rest参数"></a> rest参数</h4><blockquote><p>是ES6新增的特性，形式为：…变量名</p></blockquote><p>作用：获取函数多余的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取a，b之外的参数例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a = &#x27;</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b = &#x27;</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = undefined 因为b在参数中被定义了，要直接输出</span></span><br><span class="line"><span class="comment">// Array []</span></span><br></pre></td></tr></table></figure><h3 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h3><ol><li><p>用<code>rest</code>参数编写一个<code>add()</code>函数，用于接收任意个参数并返回她们的和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span>;</span><br><span class="line">    rest.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elemnt</span>)</span>&#123;</span><br><span class="line">      sum += element;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个计算圆面积的函数<code>area_of_circle()</code>，它有两个参数：</p><ul><li>r: 表示圆的半径；</li><li>pi: 表示π的值，如果不传，则默认3.14，若有参数传入，则为3.1416。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r,pi</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> area;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>===<span class="number">1</span>)&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.14</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    area=<span class="built_in">Math</span>.pow(r,<span class="number">2</span>)*<span class="number">3.1416</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area_of_circle</span>(<span class="params">r, pi</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span>[r,pi=<span class="number">3.14</span>]=<span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> pi*r*r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量作用域和解构赋值"><a class="markdownIt-Anchor" href="#变量作用域和解构赋值"></a> 变量作用域和解构赋值</h3><h4 id="变量提升"><a class="markdownIt-Anchor" href="#变量提升"></a> 变量提升</h4><p>js函数定义有个特点，会先扫描函数体，然后把所有变量的「声明」提到函数顶部。</p><blockquote><p>注意：只是变量的声明，并不是赋值。</p></blockquote><h4 id="块级作用域"><a class="markdownIt-Anchor" href="#块级作用域"></a> 块级作用域</h4><p>ES6引入了新关键字 <code>let</code>，用<code>let</code>代替<code>var</code>可以声明一个块级作用域的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SyntaxError:</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h4><p>ES6引入了一个<code>const</code>关键字来定义常量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></span><br><span class="line">PI; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h4 id="解构赋值"><a class="markdownIt-Anchor" href="#解构赋值"></a> 解构赋值</h4><blockquote><p>此知识点小点比较多，详细请看<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808">廖雪峰的官网</a></p></blockquote><ul><li>在ES6中，可以使用解构赋值，直接对多个变量同时赋值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;ES6&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>如果数组本身还有嵌套，只需要嵌套和层次对齐即可。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[x,[y,z]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br></pre></td></tr></table></figure><ul><li>从对象中取出其中几个属性的值，也可以用解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  name: <span class="string">&#x27;tang&#x27;</span>,</span><br><span class="line">  tel: <span class="string">&#x27;12345&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  password: <span class="string">&#x27;S-12345&#x27;</span>,</span><br><span class="line">  address:&#123;</span><br><span class="line">  city:<span class="string">&#x27;beijing&#x27;</span>,</span><br><span class="line">  street:No<span class="number">.1</span> Road,</span><br><span class="line">  zipcode:<span class="string">&#x27;10000&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把person的name和tel取出给var定义的name,tel</span></span><br><span class="line"><span class="keyword">var</span> &#123;name,tel&#125;=person;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name=&#x27;</span>+name+<span class="string">&#x27;,&#x27;</span>+<span class="string">&#x27;tel=&#x27;</span>+tel);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name=tang</span></span><br><span class="line"><span class="comment">tel=12345</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>如果要对嵌套对象address里面的值进行赋值，也能用解构赋值：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">address</span>:&#123;city,street&#125;&#125;=person;</span><br></pre></td></tr></table></figure><ul><li>如果要使用的变量名和属性名不一致，可以用下面的语法获取：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;name,<span class="attr">password</span>:id&#125;=person;</span><br><span class="line"><span class="comment">//这里就是把password「属性」赋值给了变量id</span></span><br><span class="line"><span class="comment">//注意：是把password这个属性赋值给了id，所以password不是一个变量</span></span><br></pre></td></tr></table></figure><ul><li>有时候，变量在前面已经被「声明」过，再次赋值会出错。因为js引擎会把<code>&#123;</code>开头的语句做块处理，<code>=</code> 不再合法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x,y;</span><br><span class="line">&#123;x,y&#125;=&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">300</span>&#125;;</span><br><span class="line"><span class="comment">//解决办法，用()括起来</span></span><br></pre></td></tr></table></figure><h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3><h4 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h4><p><code>this</code>是一个特殊变量，始终指向当前对象。下面的例子就是<code>this</code>指向的对象是小明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y-<span class="built_in">this</span>.birth; <span class="comment">//当前对象为xiaoming</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但想要把age方法里面的内容拆开写，要怎么办呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写一个getAge()方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写小明对象</span></span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  ame:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况一：</span></span><br><span class="line">xiaoming.age();<span class="comment">//正常返回25</span></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line">getAge; <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>为什么情况二返回的是<code>NaN</code>？因为getAge()在对象xiaoming外，所以指向的是全局对象（window）。</p></blockquote><p>想要指向正确，<strong>必须用<code>obj.xxx()</code>的形式调用</strong>，也就是「对象.方法名」</p><h4 id="that"><a class="markdownIt-Anchor" href="#that"></a> that</h4><p>我们先看看下面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - <span class="built_in">this</span>.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>line14的调用方法是正确的，但是为什么还是出错呢？原因是：在某个函数内部定义的函数（也就是第二层的函数），在strict模式下，<code>this</code>指向undefined，非strict模式下，指向window。反正就是不指向当前对象xiaoming。</p><p><strong>修复方法：使用<code>that</code>变量，在方法内部一开始就首先捕获<code>this</code>：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age();<span class="comment">//25</span></span><br></pre></td></tr></table></figure><blockquote><p>用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p></blockquote><h4 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> apply</h4><p>可以指定函数的<code>this</code>指向哪个对象，apply(this要指定的对象 , <code>Array</code>函数本身的参数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">  <span class="keyword">return</span> y-<span class="built_in">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name:<span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">  birth:<span class="number">1990</span>,</span><br><span class="line">  age:getAge</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.getAge();<span class="comment">//25</span></span><br><span class="line">getAge.apply(xiaoming,[]);</span><br></pre></td></tr></table></figure><p><code>apply()</code>把参数打包成Array再传入；<code>call()</code>把参数按顺序传入。二者功能类似。</p><p>例如：调用Math.max来判断3，4，5谁大，分别实现的方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h3><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么「一个函数就可以接收另一个函数作为参数」，这种函数就称之为高阶函数。</p><blockquote><p>所谓传入函数作为参数，其实就是把这个地址传给了另外一个函数，让另外一个函数拥有操作这个函数的权利。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;  <span class="comment">//add函数的参数为x,y,f，而参数f是一个函数</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = add(<span class="number">-5</span>, <span class="number">6</span>, <span class="built_in">Math</span>.abs); </span><br><span class="line"><span class="built_in">console</span>.log(x);<span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p><strong>高阶函数将在下一篇博文详解</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数&quot;&gt;&lt;/a&gt; 函数&lt;/h3&gt;
&lt;h4 id=&quot;定义函数&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#定义函数&quot;&gt;&lt;/a&gt; 定义函数&lt;/h4&gt;
&lt;fig</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS学习笔记-02</title>
    <link href="https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/"/>
    <id>https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</id>
    <published>2020-10-25T10:11:47.000Z</published>
    <updated>2020-10-25T10:12:58.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h3><h4 id="for"><a class="markdownIt-Anchor" href="#for"></a> for</h4><p><code>for</code>循环三个条件可省略，但如果无退出条件，则死循环。退出：break</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="forin"><a class="markdownIt-Anchor" href="#forin"></a> for…in</h4><p>用处：主要服务于「对象（key）」，能枚举数组的索引与值（例二、例三）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一</span></span><br><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">//&#x27;name&#x27;  &#x27;age&#x27;  &#x27;school&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//‘0’，‘1’，‘2‘</span></span><br><span class="line">  <span class="comment">/*为什么输出0，1，2？？因为数组也是对象，只是把下标当作key，元素是value。forin输出的是key，所以就012*/</span></span><br><span class="line">  <span class="comment">/*请注意，for ... in对Array的循环得到的是String而不是Number。*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例三</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]); <span class="comment">//&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要过滤继承属性，使用day01学的<code>hasOwnProperty()</code>方法实现。例如：</p><p>ps：或者使用<code>for...of</code>，这也是为什么设计<code>for...of</code>的原因之一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o=&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  school: <span class="string">&#x27;js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> o)&#123;</span><br><span class="line">  <span class="keyword">if</span>(o.hasOwnProperty(key))&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">//不然会输出toString属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>hasOwnProperty()是「对象」使用的「方法」，所以是o.hasOwnProperty()，而方法处理的是「对象里面的属性<code>key</code>」</li></ul></blockquote><h4 id="练习"><a class="markdownIt-Anchor" href="#练习"></a> 练习</h4><p>请利用循环遍历数组中的每个名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>; </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Bart&#x27;</span>, <span class="string">&#x27;Lisa&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>];</span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">var</span> i=arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forof"><a class="markdownIt-Anchor" href="#forof"></a> for…of</h3><blockquote><ul><li><p>for…in 循环主要是为了「遍历对象」（列出里面有什么属性。ps：不列value）而生，不适用于遍历数组。</p></li><li><p>for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象</p></li></ul></blockquote><p>参考 <a href="https://www.zhangxinxu.com/wordpress/2018/08/for-in-es6-for-of/">张鑫旭大佬的文章</a></p><h3 id="map和set"><a class="markdownIt-Anchor" href="#map和set"></a> Map和Set</h3><blockquote><p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p></blockquote><h4 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h4><p><code>Map</code>是一组「键值对」的结构，具有极快的查找速度。例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="string">&#x27;Micheal&#x27;</span>,<span class="number">95</span>],[<span class="string">&#x27;Bob&#x27;</span>,<span class="number">88</span>],[<span class="string">&#x27;Tracy&#x27;</span>,<span class="number">93</span>])</span><br><span class="line">m.get(<span class="string">&#x27;Micheal&#x27;</span>); <span class="comment">//返回的是95！</span></span><br><span class="line"><span class="comment">//注意⚠️ [&#x27;x&#x27;,y]中的x是键，y才是值，我们要get的是值，不是键值对的名字</span></span><br></pre></td></tr></table></figure><p>其他操作如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m= <span class="keyword">new</span> <span class="built_in">Map</span>();  <span class="comment">//新建空Map</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">100</span>);  <span class="comment">//添加新 key-value</span></span><br><span class="line">m.set(<span class="string">&#x27;tang&#x27;</span>,<span class="number">1</span>);  <span class="comment">//覆盖上面的100，返回1</span></span><br><span class="line">m.has(<span class="string">&#x27;tang&#x27;</span>);  <span class="comment">//返回true</span></span><br><span class="line">m.delete(<span class="string">&#x27;tang&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h4><p>与<code>Map</code>不同，Set只存「key」，不存「value」。key不能重复。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure><p>重复元素在<code>Set</code>中自动被过滤：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>注意数字<code>3</code>和字符串<code>'3'</code>是不同的元素。</p><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure><h3 id="iterable-forof"><a class="markdownIt-Anchor" href="#iterable-forof"></a> iterable &amp; for…of</h3><blockquote><p><code>Array</code>可以下标循环，但遍历<code>Map</code> 和<code>Set</code>就无法使用下标。为了统一集合类型，ES6引入了<code>iterable</code>类型，<code>Array</code> 、<code>Map</code>和<code>Set</code> 都属于<code>iterable</code>类型。</p></blockquote><p>具有<code>iterable</code>类型的「集合」，可以通过<code>for...of</code>循环来遍历</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;循环&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#循环&quot;&gt;&lt;/a&gt; 循环&lt;/h3&gt;
&lt;h4 id=&quot;for&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#for&quot;&gt;&lt;/a&gt; for&lt;/h4&gt;
&lt;p&gt;&lt;cod</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS学习笔记-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/25/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</id>
    <published>2020-10-25T10:05:55.000Z</published>
    <updated>2020-10-25T10:10:09.050Z</updated>
    
    <content type="html"><![CDATA[<p>基础的语法不再赘述，只强调以前未接触过的。</p><h3 id="一-数据类型和变量"><a class="markdownIt-Anchor" href="#一-数据类型和变量"></a> 一、数据类型和变量</h3><ol><li></li></ol><h5 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h5><p>键值对组成</p>   <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="code">    name: &#x27;Bob&#x27;,</span></span><br><span class="line"><span class="code">    age: 20,</span></span><br><span class="line"><span class="code">    tags: [&#x27;js&#x27;, &#x27;web&#x27;, &#x27;mobile&#x27;],</span></span><br><span class="line"><span class="code">    city: &#x27;Beijing&#x27;,</span></span><br><span class="line"><span class="code">    hasCar: true,</span></span><br><span class="line"><span class="code">    zipcode: null</span></span><br><span class="line"><span class="code">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><p>Person为<code>对象</code>，name、age为<code>键</code>，‘Bob’、20为<code>值</code></p></li><li><p>获取对象的属性（怎么用对象的数据）：<a href="http://person.name">person.name</a></p></li></ul><ol start="2"><li><h5 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h5><p>只能用<code>var</code>申明一次。没用<code>var</code>申明的变量：全局变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure></li><li><h5 id="strict模式"><a class="markdownIt-Anchor" href="#strict模式"></a> strict模式</h5><p><code>'use strict';</code>强制通过<code>var</code>申明</p></li></ol><h3 id="二-字符串"><a class="markdownIt-Anchor" href="#二-字符串"></a> 二、字符串</h3><ol><li><h5 id="多行字符串"><a class="markdownIt-Anchor" href="#多行字符串"></a> 多行字符串</h5><p>由于多行字符串用<code>\n</code>写起来费事，最新的ES6标准新增了如下方式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#96;这是一个</span><br><span class="line">多行</span><br><span class="line">字符串&#96;;</span><br></pre></td></tr></table></figure></li><li><h5 id="模板字符串"><a class="markdownIt-Anchor" href="#模板字符串"></a> 模板字符串</h5><p>很多变量连接时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;小明&#39;;</span><br><span class="line">var age &#x3D; 20;</span><br><span class="line">var message &#x3D; &#96;你好, $&#123;name&#125;, 你今年$&#123;age&#125;岁了!&#96;;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure></li></ol><h3 id="三-数组"><a class="markdownIt-Anchor" href="#三-数组"></a> 三、数组</h3><ol><li><h5 id="indexof"><a class="markdownIt-Anchor" href="#indexof"></a> indexOf()</h5><p>搜索指定元素的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];</span><br><span class="line">arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0</span><br><span class="line">arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1</span><br><span class="line">arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2</span><br></pre></td></tr></table></figure></li><li><h5 id="slice"><a class="markdownIt-Anchor" href="#slice"></a> slice()</h5><p>截取Array的部分元素，返回一个新的Array</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br></pre></td></tr></table></figure><ul><li><code>slice()</code>的起止参数包括开始索引，不包括结束索引</li><li>如果不给任何参数，它就会从头到位截取所有元素。可应用于：复制数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">var aCopy &#x3D; arr.slice();</span><br><span class="line">aCopy; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br><span class="line">aCopy &#x3D;&#x3D;&#x3D; arr; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li><li><h5 id="push-和-pop"><a class="markdownIt-Anchor" href="#push-和-pop"></a> push() 和 pop()</h5><ul><li><code>push()</code>插入数组尾部</li><li><code>pop()</code>删除～</li></ul></li><li><h5 id="unshift-和-shift"><a class="markdownIt-Anchor" href="#unshift-和-shift"></a> unshift() 和 shift()</h5><ul><li><code>unshift()</code>插入 头部第一</li><li><code>shift()</code>删除头部第一</li></ul></li><li><h5 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> reverse()</h5><p>数组的反转</p></li><li><h5 id="splice"><a class="markdownIt-Anchor" href="#splice"></a> splice()</h5><p><em><strong>修改数组的万能方法</strong></em>，格式为：从哪里开始，删除多少个，添加什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure></li><li><h5 id="concat"><a class="markdownIt-Anchor" href="#concat"></a> concat()</h5><p>连接两个数组。没有修改原数组，只是生成新数组</p></li><li><h5 id="join"><a class="markdownIt-Anchor" href="#join"></a> join()</h5><p>把<code>array</code>里面的元素，用指定的字符连起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[&#39;a&#39;,&#39;b&#39;];</span><br><span class="line">arr.join(&#39;-&#39;);</span><br><span class="line">arr;返回的就是&#39;a-b&#39;</span><br></pre></td></tr></table></figure><p>ps：如果Array的元素不是字符串，则自动转化再拼接</p></li></ol><h3 id="三-对象"><a class="markdownIt-Anchor" href="#三-对象"></a> 三、对象</h3><ol><li><p>用[‘x’]访问（少用）</p><p>属性名（键）如果不是有效的变量名，包含了特殊字符时，不能用<code>.</code>访问</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xiaohong &#x3D; &#123;</span><br><span class="line">    name: &#39;小红&#39;,</span><br><span class="line">    &#39;middle-school&#39;: &#39;No.1 Middle School&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaohong[&#39;middle-school&#39;]; &#x2F;&#x2F; &#39;No.1 Middle School&#39;</span><br><span class="line">xiaohong[&#39;name&#39;]; &#x2F;&#x2F; &#39;小红&#39;</span><br><span class="line">xiaohong.name; &#x2F;&#x2F; &#39;小红&#39;</span><br></pre></td></tr></table></figure><p><strong>ps：写代码尽量规范，尽量用<code>.</code>访问</strong></p><ol start="2"><li><p>由于对象是动态类型，因此可以随便给对象添加或修改属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming&#x3D;&#123;</span><br><span class="line">name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F;undefined</span><br><span class="line">xiaoming.age&#x3D;18;  &#x2F;&#x2F;添加了age属性</span><br><span class="line">delete xiaoming.age;  &#x2F;&#x2F;删除name属性</span><br><span class="line">xiaoming.age;  &#x2F;&#x2F;因为line6又把line5添加的删除了，所以还是undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.name; &#x2F;&#x2F;删除name</span><br><span class="line">xiaoming.name; &#x2F;&#x2F;undefined</span><br><span class="line"></span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F;删除不存在的属性，还是undefined</span><br></pre></td></tr></table></figure></li><li><p>检测属性存在性</p><ul><li>用<code>in</code>操作符，返回布尔值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;grade&#x27;</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>注意，in检测的结果可以使从上继承的属性，例如toString，要想检测是否自身拥有，使用<code>hasOwnProperty()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming=&#123;</span><br><span class="line">  name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//true</span></span><br><span class="line">xiaoming.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基础的语法不再赘述，只强调以前未接触过的。&lt;/p&gt;
&lt;h3 id=&quot;一-数据类型和变量&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-数据类型和变量&quot;&gt;&lt;/a&gt; 一、数据类型和变量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 </summary>
      
    
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/</id>
    <published>2020-10-25T09:57:31.000Z</published>
    <updated>2020-10-25T09:59:44.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单"><a class="markdownIt-Anchor" href="#简单"></a> 简单</h3><ul><li><code>\d</code> 匹配数字</li><li><code>\w</code> 匹配字母</li><li><code>.</code> 匹配所有</li></ul><p>例如：<code>00\d</code> 可以匹配000～009，<code>00\w</code> 可以匹配00a～00z，<code>\w\w</code> 可以匹配 aa，<code>\w.</code> 可以匹配 js、j1、j! 等</p><ul><li><code>*</code>表示任意个字符（包括0个）</li><li><code>+</code>表示至少一个字符</li><li><code>?</code>表示0个或1个字符</li><li><code>&#123;n&#125;</code>表示n个字符</li><li><code>&#123;n,m&#125;</code>表示n-m个字符：</li></ul><p>复杂例子：<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code>。</p><p>我们来从左到右解读一下：</p><ol><li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>'010'</code>；</li><li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code>，<code>'\t\t'</code>等；</li><li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>'1234567'</code>。</li></ol><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>'010-12345'</code>这样的号码呢？由于<code>'-'</code>是特殊字符，在正则表达式中，要用<code>'\'</code>转义，所以，上面的正则是<code>\d&#123;3&#125;\-\d&#123;3,8&#125;</code>。</p><h3 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'js2015'</code>等等；</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">开</mi><mi mathvariant="normal">头</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">母</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">划</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">开头，后接任意个由一个数字、字母或者下划线、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">头</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">母</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">划</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">、</span></span></span></span>组成的字符串，也就是JavaScript允许的变量名；</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul><p><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>'JavaScript'</code>、<code>'Javascript'</code>、<code>'javaScript'</code>或者<code>'javascript'</code>。</p><p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p><p>你可能注意到了，<code>js</code>也可以匹配<code>'jsp'</code>，但是加上<code>^js$</code>就变成了整行匹配，就只能匹配<code>'js'</code>了。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1=<span class="regexp">/ABC\-001/</span></span><br><span class="line"><span class="keyword">var</span> re2=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>)  <span class="comment">//字符串的转义问题，字符串的两个\\实际上是一个\。</span></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><h3 id="切分字符串"><a class="markdownIt-Anchor" href="#切分字符串"></a> 切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure><p>嗯，无法识别连续的空格，用正则表达式试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure><p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure><p>再加入<code>;</code>试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p><h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3><p>用<code>()</code>表示的就是要提取的分组（Group）。比如：</p><p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line">re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line">re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p><p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p><p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p><p>提取子串非常有用。来看一个更凶残的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;19:05:30&#x27;</span>); <span class="comment">// [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span></span><br></pre></td></tr></table></figure><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure><p>对于<code>'2-30'</code>，<code>'4-31'</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h3 id="贪婪匹配"><a class="markdownIt-Anchor" href="#贪婪匹配"></a> 贪婪匹配</h3><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="全局搜索"><a class="markdownIt-Anchor" href="#全局搜索"></a> 全局搜索</h3><p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br></pre></td></tr></table></figure><p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p><p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简单&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简单&quot;&gt;&lt;/a&gt; 简单&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; 匹配数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w&lt;/code&gt; 匹配字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/tags/JavaScript/"/>
    
    <category term="正则表达式" scheme="https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/21/MySQL-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/21/MySQL-01/</id>
    <published>2020-10-21T06:37:29.000Z</published>
    <updated>2020-10-27T05:57:35.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单表"><a class="markdownIt-Anchor" href="#单表"></a> 单表</h3><h4 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h4><ul><li><p>基本用法：</p><p><code>select</code> 用法是<code>select 字段 from 表名</code></p><p>例如：<code>select id,name from t_studeng</code>表示从t_student表查找id到name的字段</p></li><li><p><code>where</code>查询条件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student where age&#x3D;20 and xueli&#x3D;&#39;本科&#39;;</span><br></pre></td></tr></table></figure><h4 id="增-2"><a class="markdownIt-Anchor" href="#增-2"></a> 增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(&#39;id&#39;,&#39;name&#39;,&#39;age&#39;) values(&#39;10&#39;,&#39;名字&#39;,&#39;20&#39;);</span><br></pre></td></tr></table></figure><h4 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 字段1&#x3D;值1</span><br><span class="line">where 条件;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">update t_student</span><br><span class="line">set age&#x3D;20</span><br><span class="line">where id&#x3D;10;</span><br></pre></td></tr></table></figure><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where id&#x3D;1;</span><br></pre></td></tr></table></figure><hr /><h3 id="多表联查"><a class="markdownIt-Anchor" href="#多表联查"></a> 多表联查</h3><h4 id="两个表"><a class="markdownIt-Anchor" href="#两个表"></a> 两个表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from t_student join t_class on t_class.id&#x3D;t_student.cid;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A join B &#x3D; 表A+表B</span><br><span class="line">on &#x3D; 表A与表B的连接点cid+表B的id（反正就是表A的尾部和表B头部相连）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/Xnip2020-10-20_23-56-04.jpg" alt="Xnip2020-10-20_23-56-04" /></p><p>​从上图可以看到，两张表关联起来后会出现cid和id和两个remark，这个查询结果显得不够精简。如何选择 关联后新表的部分数据呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,name,age,classname from  t_student s join t_class c on s.cid&#x3D;c.id;</span><br></pre></td></tr></table></figure><p>​注意，可以通过<code>t_student s</code>与<code>t_class c</code>的方式，把冗长的表名用简单的单词替代。另外，上面的<code>s.id,name,classname</code>，不用写成<code>s.id,s.name,c.classname</code>，因为合并后是以<code>t_student</code>的<code>id</code>做为主键的。</p><p>​<code>select</code>与<code>from</code>之间的内容，永远都作「条件」，<code>from</code>后面的永远为「表」或者「关联的新表」（用<code>join</code>连接），<code>on</code>为「连接点」。</p><h4 id="三个表"><a class="markdownIt-Anchor" href="#三个表"></a> 三个表</h4><p>可以在两个表的基础上，再在后面 <code>join</code>第三个表即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,name,classname,chinese,math,english from t_student s join t_class c on s.cid&#x3D;c.id join t_grade g on c.id&#x3D;g.sid where math&gt;60; </span><br></pre></td></tr></table></figure><hr /><h3 id="数据库常用命令和实际应用"><a class="markdownIt-Anchor" href="#数据库常用命令和实际应用"></a> 数据库常用命令和实际应用</h3><h4 id="模糊查询-like"><a class="markdownIt-Anchor" href="#模糊查询-like"></a> 模糊查询 like</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student where name like &#39;张%&#39;;</span><br></pre></td></tr></table></figure><p><strong>张%：表示张开头，那么%张则表示以张结尾。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201021152158159.png" alt="image-20201021152158159" /></p><h4 id="排序-order-by"><a class="markdownIt-Anchor" href="#排序-order-by"></a> 排序 order by</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student order by age; &#x2F;&#x2F;正序</span><br><span class="line">select *from t_student order by age desc; &#x2F;&#x2F;倒序</span><br></pre></td></tr></table></figure><h4 id="统计-count"><a class="markdownIt-Anchor" href="#统计-count"></a> 统计 count</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from t_student;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201021153643998.png" alt="image-20201021153643998" /></p><p><strong>拓展：</strong></p><p>上图中显示的 <code>count(*)</code> 不太美观，可以通过 <code>as</code> 重命名（在终端的显示名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as &#39;数量&#39; from t_student; &#x2F;&#x2F;as其实也可省略</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201021153944803.png" alt="image-20201021153944803" /></p><h4 id="min-max-sum"><a class="markdownIt-Anchor" href="#min-max-sum"></a> min、max、sum</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(age) from t_student;</span><br></pre></td></tr></table></figure><h4 id="分组-group-by"><a class="markdownIt-Anchor" href="#分组-group-by"></a> 分组 group by</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select classname,max(age) from t_class c join t_student s on c.id&#x3D;s.id group by classname;</span><br></pre></td></tr></table></figure><ul><li><p>解释：先用 classname 来分组，然后再分组之后计算 max。</p><p>如果把上面的 age 去掉，就会出错。因为如果按照 classname 分成了两组，但是我还查询了很多个 age 等待着显示出来，也就是一组 classname 对应着多个 age，自然就出错了。</p><p>所以，其实分组就是说要在分组后，还要进行部分操作（min，max，sum，avg等）才行。</p></li><li><p>例二：</p><p>如果我要算不同年龄分别共有多少人？</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age,count(*) from t_student group by age;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/tangspoon66.github.io@master/uPic/image-20201021164254139.png" alt="image-20201021164254139" /></p><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;单表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单表&quot;&gt;&lt;/a&gt; 单表&lt;/h3&gt;
&lt;h4 id=&quot;增&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#增&quot;&gt;&lt;/a&gt; 增&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://blog.tangspoon.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.tangspoon.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B0-01/</id>
    <published>2020-10-20T14:24:10.000Z</published>
    <updated>2020-10-25T10:18:34.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是软件测试"><a class="markdownIt-Anchor" href="#什么是软件测试"></a> 什么是软件测试</h3><p>是为了保障软件质量的，找出预期结果是否符合实际结果</p><hr /><h3 id="软件测试的分类"><a class="markdownIt-Anchor" href="#软件测试的分类"></a> 软件测试的分类</h3><h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4><ul><li>黑盒测试：看不到内部结构，只暴露外部接口。方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图等</li><li>白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。主要技术有逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等<ul><li>一个模块中的所有独立路径至少被测试一次。</li><li>所有逻辑值均需测试true和false两种情况。</li><li>检査程序的内部数据结构，保证其结构的有效性。</li><li>在取值的上、下边界及可操作范围内运行所有循环。</li></ul></li><li>灰盒测试：相当于结合了以上两种</li></ul><h4 id="方向"><a class="markdownIt-Anchor" href="#方向"></a> 方向</h4><ul><li><p>功能测试：看功能是否正常。</p><blockquote><p>黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做）</p></blockquote></li><li><p>性能测试：判断程序能做多好（与时间挂钩）</p><ul><li><p>压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。</p></li><li><p>负载测试：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟）</p><blockquote><p>以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。</p></blockquote></li><li><p>并发测试：一瞬间同一个程序在做同一件事情</p></li></ul></li><li><p>安全测试（了解）：防止攻击，例如ddos等</p></li></ul><h4 id="阶段"><a class="markdownIt-Anchor" href="#阶段"></a> 阶段</h4><ul><li>单元测试：<ul><li>重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。</li><li>单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态z1数据流分析</li></ul></li><li>集成测试：重点测试「接口」</li><li>系统测试：功能、安全、性能、兼容性、易用性、稳定性……</li><li>验收测试</li></ul><h4 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h4><p>APP测试、Web测试、物联网、小程序……其实都是软件测试。所以重点还是上面的方法与方向。</p><h4 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h4><p>根据软件的状态划分的</p><ul><li>静态：不会运行的软件，通过白盒测试看代码</li><li>动态：把软件运行起来测试</li></ul><h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4><ul><li>冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试）</li><li>回归测试：回归bug，bug修改了，有没有检查。</li><li>Alpha测试：内测</li><li>Beta测试：公测</li></ul><hr /><h3 id="研发管理模型"><a class="markdownIt-Anchor" href="#研发管理模型"></a> 研发管理模型</h3><blockquote><p>作用：在开发中会经历很多过程，模型可以知道不同的工作流程。</p></blockquote><h4 id="瀑布流"><a class="markdownIt-Anchor" href="#瀑布流"></a> 瀑布流</h4><p>从上往下，不可逆不可返回的流程。</p><h4 id="v字型"><a class="markdownIt-Anchor" href="#v字型"></a> V字型</h4><p>左边是开发做的，右边是测试做的，二者一一对照。</p><h4 id="w字型"><a class="markdownIt-Anchor" href="#w字型"></a> w字型</h4><p>测试与开发同步了。</p><hr /><h3 id="测试流程"><a class="markdownIt-Anchor" href="#测试流程"></a> 测试流程</h3><h4 id="需求分析阶段"><a class="markdownIt-Anchor" href="#需求分析阶段"></a> 需求分析阶段</h4><ul><li>需求分析<ul><li>需求文档：产品经理用文档描述</li><li>产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。）</li><li>口述</li></ul></li><li>学习业务流程：</li><li>提取功能点：把小功能提取出来，做成树状图</li><li>编写需求分析说明书</li></ul><h4 id="测试设计阶段"><a class="markdownIt-Anchor" href="#测试设计阶段"></a> 测试设计阶段</h4><blockquote><p>前三个由产品经理或者组长写，方法是：5W1H</p></blockquote><ul><li><p>测试计划：时间、人、资源的分配</p></li><li><p>测试方案</p><ul><li>每个测试内容如何展开</li><li>采用什么测试计划</li><li>哪些内容先测</li></ul></li><li><p>测试策略</p><ul><li>哪些内容先测后测（先测功能还是兼容？）</li><li>开始和结束的标准是什么？</li></ul></li><li><p><strong>测试用例（重点！重中之重！）</strong></p><p>包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。</p><ul><li><p>用例编号：唯一的</p></li><li><p>用例名称：言简意赅</p></li><li><p>前置条件：在执行用例前，软件必须要满足的条件</p></li><li><p>优先级：执行用例的时间要求紧急的等级</p></li><li><p>重要级：被测功能在软件中的重要等级</p></li></ul><p>要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ）</p></li></ul><blockquote><p>测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方</p></blockquote><h4 id="测试执行阶段"><a class="markdownIt-Anchor" href="#测试执行阶段"></a> 测试执行阶段</h4><p>上面测试完后，得到了「测试用例」，接下来就要对用例进行执行了。</p><h4 id="测试总结阶段"><a class="markdownIt-Anchor" href="#测试总结阶段"></a> 测试总结阶段</h4><hr /><h3 id="测试方法"><a class="markdownIt-Anchor" href="#测试方法"></a> 测试方法</h3><h4 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h4><p>通过少部分的值，代表大部分的情况。</p><ul><li><p>有效等价类</p><p>满足条件的：0.01，0.02，200，199.99</p></li><li><p>无效等价类</p><p>不满足条件的：0，200.01</p></li></ul><h4 id="边界法"><a class="markdownIt-Anchor" href="#边界法"></a> 边界法</h4><p>0，负数，+1，-1，本身，整数，非整数，字符</p><p>例如： 一个函数的入参是一个int类型，但是有效输入只有[0,100]范围的数，如果你要测试这个函数，你会选择以下哪组入参，是最全面且最精简的（   ）</p><p>可以测试越界的，这里可以使用 -1、101，数组的前两位 0、1，数组的最后两位 99、100，中部一位 67。可以测试所有情况。所以答案为：-1,0,1,67,99,100,101</p><h4 id="场景法"><a class="markdownIt-Anchor" href="#场景法"></a> 场景法</h4><p>……</p><blockquote><p>后续更新</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是软件测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是软件测试&quot;&gt;&lt;/a&gt; 什么是软件测试&lt;/h3&gt;
&lt;p&gt;是为了保障软件质量的，找出预期结果是否符合实际结果&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;软件测试的分类&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="软件测试" scheme="https://blog.tangspoon.cn/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.tangspoon.cn/2020/10/13/hello-world/"/>
    <id>https://blog.tangspoon.cn/2020/10/13/hello-world/</id>
    <published>2020-10-13T03:51:26.002Z</published>
    <updated>2020-10-13T03:51:26.002Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
