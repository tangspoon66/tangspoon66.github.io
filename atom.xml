<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mark my mind</title>
  
  <subtitle>做个善于记录的人</subtitle>
  <link href="https://blog.tangspoon.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.tangspoon.cn/"/>
  <updated>2020-10-25T09:59:44.323Z</updated>
  <id>https://blog.tangspoon.cn/</id>
  
  <author>
    <name>tangspoon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-01/</id>
    <published>2020-10-25T09:57:31.000Z</published>
    <updated>2020-10-25T09:59:44.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单"><a class="markdownIt-Anchor" href="#简单"></a> 简单</h3><ul><li><code>\d</code> 匹配数字</li><li><code>\w</code> 匹配字母</li><li><code>.</code> 匹配所有</li></ul><p>例如：<code>00\d</code> 可以匹配000～009，<code>00\w</code> 可以匹配00a～00z，<code>\w\w</code> 可以匹配 aa，<code>\w.</code> 可以匹配 js、j1、j! 等</p><ul><li><code>*</code>表示任意个字符（包括0个）</li><li><code>+</code>表示至少一个字符</li><li><code>?</code>表示0个或1个字符</li><li><code>&#123;n&#125;</code>表示n个字符</li><li><code>&#123;n,m&#125;</code>表示n-m个字符：</li></ul><p>复杂例子：<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code>。</p><p>我们来从左到右解读一下：</p><ol><li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>'010'</code>；</li><li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code>，<code>'\t\t'</code>等；</li><li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>'1234567'</code>。</li></ol><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>'010-12345'</code>这样的号码呢？由于<code>'-'</code>是特殊字符，在正则表达式中，要用<code>'\'</code>转义，所以，上面的正则是<code>\d&#123;3&#125;\-\d&#123;3,8&#125;</code>。</p><h3 id="进阶"><a class="markdownIt-Anchor" href="#进阶"></a> 进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'js2015'</code>等等；</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">开</mi><mi mathvariant="normal">头</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">由</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">母</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">划</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">开头，后接任意个由一个数字、字母或者下划线、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">头</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">由</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">母</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">划</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">、</span></span></span></span>组成的字符串，也就是JavaScript允许的变量名；</li><li><code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul><p><code>A|B</code>可以匹配A或B，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>'JavaScript'</code>、<code>'Javascript'</code>、<code>'javaScript'</code>或者<code>'javascript'</code>。</p><p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p><p>你可能注意到了，<code>js</code>也可以匹配<code>'jsp'</code>，但是加上<code>^js$</code>就变成了整行匹配，就只能匹配<code>'js'</code>了。</p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1=<span class="regexp">/ABC\-001/</span></span><br><span class="line"><span class="keyword">var</span> re2=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>)  <span class="comment">//字符串的转义问题，字符串的两个\\实际上是一个\。</span></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><h3 id="切分字符串"><a class="markdownIt-Anchor" href="#切分字符串"></a> 切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#39; &#39;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;&#39;, &#39;&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure><p>嗯，无法识别连续的空格，用正则表达式试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a b   c&#39;.split(&#x2F;\s+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br></pre></td></tr></table></figure><p>无论多少个空格都可以正常分割。加入<code>,</code>试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a,b, c  d&#39;.split(&#x2F;[\s\,]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure><p>再加入<code>;</code>试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;a,b;; c  d&#39;.split(&#x2F;[\s\,\;]+&#x2F;); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br></pre></td></tr></table></figure><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p><h3 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h3><p>用<code>()</code>表示的就是要提取的分组（Group）。比如：</p><p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var re &#x3D; &#x2F;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x2F;;</span><br><span class="line">re.exec(&#39;010-12345&#39;); &#x2F;&#x2F; [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;]</span><br><span class="line">re.exec(&#39;010 12345&#39;); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p><p><code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。</p><p><code>exec()</code>方法在匹配失败时返回<code>null</code>。</p><p>提取子串非常有用。来看一个更凶残的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;19:05:30&#x27;</span>); <span class="comment">// [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span></span><br></pre></td></tr></table></figure><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure><p>对于<code>'2-30'</code>，<code>'4-31'</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h3 id="贪婪匹配"><a class="markdownIt-Anchor" href="#贪婪匹配"></a> 贪婪匹配</h3><p>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span></span><br></pre></td></tr></table></figure><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">&#x27;102300&#x27;</span>); <span class="comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="全局搜索"><a class="markdownIt-Anchor" href="#全局搜索"></a> 全局搜索</h3><p>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br></pre></td></tr></table></figure><p>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JavaScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;VBScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;JScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// [&#x27;ECMAScript&#x27;]</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><p>全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p><p>正则表达式还可以指定<code>i</code>标志，表示忽略大小写，<code>m</code>标志，表示执行多行匹配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简单&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简单&quot;&gt;&lt;/a&gt; 简单&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; 匹配数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w&lt;/code&gt; 匹配字母&lt;/li&gt;
&lt;li&gt;&lt;code&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://blog.tangspoon.cn/tags/JavaScript/"/>
    
    <category term="正则表达式" scheme="https://blog.tangspoon.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-01</title>
    <link href="https://blog.tangspoon.cn/2020/10/21/MySQL-01/"/>
    <id>https://blog.tangspoon.cn/2020/10/21/MySQL-01/</id>
    <published>2020-10-21T06:37:29.000Z</published>
    <updated>2020-10-21T09:16:49.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单表"><a class="markdownIt-Anchor" href="#单表"></a> 单表</h3><h4 id="增"><a class="markdownIt-Anchor" href="#增"></a> 增</h4><ul><li><p>基本用法：</p><p><code>select</code> 用法是<code>select 字段 from 表名</code></p><p>例如：<code>select id,name from t_studeng</code>表示从t_student表查找id到name的字段</p></li><li><p><code>where</code>查询条件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student where age&#x3D;20 and xueli&#x3D;&#39;本科&#39;;</span><br></pre></td></tr></table></figure><h4 id="增-2"><a class="markdownIt-Anchor" href="#增-2"></a> 增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(&#39;id&#39;,&#39;name&#39;,&#39;age&#39;) values(&#39;10&#39;,&#39;名字&#39;,&#39;20&#39;);</span><br></pre></td></tr></table></figure><h4 id="改"><a class="markdownIt-Anchor" href="#改"></a> 改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 字段1&#x3D;值1</span><br><span class="line">where 条件;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">update t_student</span><br><span class="line">set age&#x3D;20</span><br><span class="line">where id&#x3D;10;</span><br></pre></td></tr></table></figure><h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where id&#x3D;1;</span><br></pre></td></tr></table></figure><hr /><h3 id="多表联查"><a class="markdownIt-Anchor" href="#多表联查"></a> 多表联查</h3><h4 id="两个表"><a class="markdownIt-Anchor" href="#两个表"></a> 两个表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from t_student join t_class on t_class.id&#x3D;t_student.cid;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A join B &#x3D; 表A+表B</span><br><span class="line">on &#x3D; 表A与表B的连接点cid+表B的id（反正就是表A的尾部和表B头部相连）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/blog_pics@master/uPic/Xnip2020-10-20_23-56-04.jpg" alt="Xnip2020-10-20_23-56-04" /></p><p>​从上图可以看到，两张表关联起来后会出现cid和id和两个remark，这个查询结果显得不够精简。如何选择 关联后新表的部分数据呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,name,age,classname from  t_student s join t_class c on s.cid&#x3D;c.id;</span><br></pre></td></tr></table></figure><p>​注意，可以通过<code>t_student s</code>与<code>t_class c</code>的方式，把冗长的表名用简单的单词替代。另外，上面的<code>s.id,name,classname</code>，不用写成<code>s.id,s.name,c.classname</code>，因为合并后是以<code>t_student</code>的<code>id</code>做为主键的。</p><p>​<code>select</code>与<code>from</code>之间的内容，永远都作「条件」，<code>from</code>后面的永远为「表」或者「关联的新表」（用<code>join</code>连接），<code>on</code>为「连接点」。</p><h4 id="三个表"><a class="markdownIt-Anchor" href="#三个表"></a> 三个表</h4><p>可以在两个表的基础上，再在后面 <code>join</code>第三个表即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s.id,name,classname,chinese,math,english from t_student s join t_class c on s.cid&#x3D;c.id join t_grade g on c.id&#x3D;g.sid where math&gt;60; </span><br></pre></td></tr></table></figure><hr /><h3 id="数据库常用命令和实际应用"><a class="markdownIt-Anchor" href="#数据库常用命令和实际应用"></a> 数据库常用命令和实际应用</h3><h4 id="模糊查询-like"><a class="markdownIt-Anchor" href="#模糊查询-like"></a> 模糊查询 like</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student where name like &#39;张%&#39;;</span><br></pre></td></tr></table></figure><p><strong>张%：表示张开头，那么%张则表示以张结尾。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/blog_pics@master/uPic/image-20201021152158159.png" alt="image-20201021152158159" /></p><h4 id="排序-order-by"><a class="markdownIt-Anchor" href="#排序-order-by"></a> 排序 order by</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select *from t_student order by age; &#x2F;&#x2F;正序</span><br><span class="line">select *from t_student order by age desc; &#x2F;&#x2F;倒序</span><br></pre></td></tr></table></figure><h4 id="统计-count"><a class="markdownIt-Anchor" href="#统计-count"></a> 统计 count</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from t_student;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/blog_pics@master/uPic/image-20201021153643998.png" alt="image-20201021153643998" /></p><p><strong>拓展：</strong></p><p>上图中显示的 <code>count(*)</code> 不太美观，可以通过 <code>as</code> 重命名（在终端的显示名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as &#39;数量&#39; from t_student; &#x2F;&#x2F;as其实也可省略</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/blog_pics@master/uPic/image-20201021153944803.png" alt="image-20201021153944803" /></p><h4 id="min-max-sum"><a class="markdownIt-Anchor" href="#min-max-sum"></a> min、max、sum</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(age) from t_student;</span><br></pre></td></tr></table></figure><h4 id="分组-group-by"><a class="markdownIt-Anchor" href="#分组-group-by"></a> 分组 group by</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select classname,max(age) from t_class c join t_student s on c.id&#x3D;s.id group by classname;</span><br></pre></td></tr></table></figure><ul><li><p>解释：先用 classname 来分组，然后再分组之后计算 max。</p><p>如果把上面的 age 去掉，就会出错。因为如果按照 classname 分成了两组，但是我还查询了很多个 age 等待着显示出来，也就是一组 classname 对应着多个 age，自然就出错了。</p><p>所以，其实分组就是说要在分组后，还要进行部分操作（min，max，sum，avg等）才行。</p></li><li><p>例二：</p><p>如果我要算不同年龄分别共有多少人？</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age,count(*) from t_student group by age;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tangspoon66/blog_pics@master/uPic/image-20201021164254139.png" alt="image-20201021164254139" /></p><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;单表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单表&quot;&gt;&lt;/a&gt; 单表&lt;/h3&gt;
&lt;h4 id=&quot;增&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#增&quot;&gt;&lt;/a&gt; 增&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://blog.tangspoon.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.tangspoon.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>软件测试01-基础知识</title>
    <link href="https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9501-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://blog.tangspoon.cn/2020/10/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%9501-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-10-20T14:24:10.000Z</published>
    <updated>2020-10-21T12:15:39.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是软件测试"><a class="markdownIt-Anchor" href="#什么是软件测试"></a> 什么是软件测试</h3><p>是为了保障软件质量的，找出预期结果是否符合实际结果</p><hr /><h3 id="软件测试的分类"><a class="markdownIt-Anchor" href="#软件测试的分类"></a> 软件测试的分类</h3><h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4><ul><li>黑盒测试：看不到内部结构，只暴露外部接口。方法和技术有：等价类划分法、边界值分析法、错误推测法和因果图等</li><li>白盒测试：全面了解程序内部逻辑结构、对所有逻辑路径进行测试。穷举路径测试。测试者必须检查程序的内部结构，从检查程序的「逻辑」着手，得出测试数据。主要技术有逻辑覆盖测试（语句覆盖、路径覆盖、判断覆盖、条件覆盖、判断-条件覆盖）、基本路径测试等<ul><li>一个模块中的所有独立路径至少被测试一次。</li><li>所有逻辑值均需测试true和false两种情况。</li><li>检査程序的内部数据结构，保证其结构的有效性。</li><li>在取值的上、下边界及可操作范围内运行所有循环。</li></ul></li><li>灰盒测试：相当于结合了以上两种</li></ul><h4 id="方向"><a class="markdownIt-Anchor" href="#方向"></a> 方向</h4><ul><li><p>功能测试：看功能是否正常。</p><blockquote><p>黑盒=功能？不。黑盒测试只是在功能测试时的一种方法。换句话说，我在做功能测试时，能用黑白灰三种方法去做）</p></blockquote></li><li><p>性能测试：判断程序能做多好（与时间挂钩）</p><ul><li><p>压力测试：发现性能瓶颈。服务员做测试软件，我扣工资，给他点压力，看还正常工作不。</p></li><li><p>负载测试：「持续」保持高强度的工作，能持续多长时间。（一般用峰值80%～90%模拟）</p><blockquote><p>以上有何区别？压力测试：最多能举多少哑铃；负载测试：看你能举多久。</p></blockquote></li><li><p>并发测试：一瞬间同一个程序在做同一件事情</p></li></ul></li><li><p>安全测试（了解）：防止攻击，例如ddos等</p></li></ul><h4 id="阶段"><a class="markdownIt-Anchor" href="#阶段"></a> 阶段</h4><ul><li>单元测试：<ul><li>重点测试「方法、函数、类」（换句话说就是测试代码）是指对软件中的「最小可测试单元」进行检查和验证，所以全局测试不算是单元测试。</li><li>单元测试的策略：逻辑覆盖、循环覆盖、同行评审、桌前检查、代码走查、代码评审、静态z1数据流分析</li></ul></li><li>集成测试：重点测试「接口」</li><li>系统测试：功能、安全、性能、兼容性、易用性、稳定性……</li><li>验收测试</li></ul><h4 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h4><p>APP测试、Web测试、物联网、小程序……其实都是软件测试。所以重点还是上面的方法与方向。</p><h4 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h4><p>根据软件的状态划分的</p><ul><li>静态：不会运行的软件，通过白盒测试看代码</li><li>动态：把软件运行起来测试</li></ul><h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4><ul><li>冒烟测试：测试前的测试，非正式测试流程的测试（预发布测试）</li><li>回归测试：回归bug，bug修改了，有没有检查。</li><li>Alpha测试：内测</li><li>Beta测试：公测</li></ul><hr /><h3 id="研发管理模型"><a class="markdownIt-Anchor" href="#研发管理模型"></a> 研发管理模型</h3><blockquote><p>作用：在开发中会经历很多过程，模型可以知道不同的工作流程。</p></blockquote><h4 id="瀑布流"><a class="markdownIt-Anchor" href="#瀑布流"></a> 瀑布流</h4><p>从上往下，不可逆不可返回的流程。</p><h4 id="v字型"><a class="markdownIt-Anchor" href="#v字型"></a> V字型</h4><p>左边是开发做的，右边是测试做的，二者一一对照。</p><h4 id="w字型"><a class="markdownIt-Anchor" href="#w字型"></a> w字型</h4><p>测试与开发同步了。</p><hr /><h3 id="测试流程"><a class="markdownIt-Anchor" href="#测试流程"></a> 测试流程</h3><h4 id="需求分析阶段"><a class="markdownIt-Anchor" href="#需求分析阶段"></a> 需求分析阶段</h4><ul><li>需求分析<ul><li>需求文档：产品经理用文档描述</li><li>产品原型：简单模拟画出的软件图（最原始的软件，比V1.0还要前的那种。）</li><li>口述</li></ul></li><li>学习业务流程：</li><li>提取功能点：把小功能提取出来，做成树状图</li><li>编写需求分析说明书</li></ul><h4 id="测试设计阶段"><a class="markdownIt-Anchor" href="#测试设计阶段"></a> 测试设计阶段</h4><blockquote><p>前三个由产品经理或者组长写，方法是：5W1H</p></blockquote><ul><li><p>测试计划：时间、人、资源的分配</p></li><li><p>测试方案</p><ul><li>每个测试内容如何展开</li><li>采用什么测试计划</li><li>哪些内容先测</li></ul></li><li><p>测试策略</p><ul><li>哪些内容先测后测（先测功能还是兼容？）</li><li>开始和结束的标准是什么？</li></ul></li><li><p><strong>测试用例（重点！重中之重！）</strong></p><p>包括：用例编号，用例名称，前置条件，优先级，重要级，测试数据，测试步骤，预期结果，实际结果。</p><ul><li><p>用例编号：唯一的</p></li><li><p>用例名称：言简意赅</p></li><li><p>前置条件：在执行用例前，软件必须要满足的条件</p></li><li><p>优先级：执行用例的时间要求紧急的等级</p></li><li><p>重要级：被测功能在软件中的重要等级</p></li></ul><p>要先从测试方法讲起（这里的测试方法与上面的测试方法不一样，此处的～是一种具体的方法，相当于1+1=2、2+2=4这种具体怎么应用；而上面的方法是相当于加减乘除一样的测试思路 ）</p></li></ul><blockquote><p>测试方法有：等价类、边界值、场景法。是用来设计测试用例的。详细见下方</p></blockquote><h4 id="测试执行阶段"><a class="markdownIt-Anchor" href="#测试执行阶段"></a> 测试执行阶段</h4><p>上面测试完后，得到了「测试用例」，接下来就要对用例进行执行了。</p><h4 id="测试总结阶段"><a class="markdownIt-Anchor" href="#测试总结阶段"></a> 测试总结阶段</h4><hr /><h3 id="测试方法"><a class="markdownIt-Anchor" href="#测试方法"></a> 测试方法</h3><h4 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h4><p>通过少部分的值，代表大部分的情况。</p><ul><li><p>有效等价类</p><p>满足条件的：0.01，0.02，200，199.99</p></li><li><p>无效等价类</p><p>不满足条件的：0，200.01</p></li></ul><h4 id="边界法"><a class="markdownIt-Anchor" href="#边界法"></a> 边界法</h4><p>0，负数，+1，-1，本身，整数，非整数，字符</p><p>例如： 一个函数的入参是一个int类型，但是有效输入只有[0,100]范围的数，如果你要测试这个函数，你会选择以下哪组入参，是最全面且最精简的（   ）</p><p>可以测试越界的，这里可以使用 -1、101，数组的前两位 0、1，数组的最后两位 99、100，中部一位 67。可以测试所有情况。所以答案为：-1,0,1,67,99,100,101</p><h4 id="场景法"><a class="markdownIt-Anchor" href="#场景法"></a> 场景法</h4><p>……</p><blockquote><p>后续更新</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是软件测试&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是软件测试&quot;&gt;&lt;/a&gt; 什么是软件测试&lt;/h3&gt;
&lt;p&gt;是为了保障软件质量的，找出预期结果是否符合实际结果&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;软件测试的分类&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="软件测试" scheme="https://blog.tangspoon.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.tangspoon.cn/2020/10/13/hello-world/"/>
    <id>https://blog.tangspoon.cn/2020/10/13/hello-world/</id>
    <published>2020-10-13T03:51:26.002Z</published>
    <updated>2020-10-13T03:51:26.002Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
