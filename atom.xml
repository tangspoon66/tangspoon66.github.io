<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ThompsonTang&#39;s blog</title>
  
  <subtitle>判断得与失的时限大概要拉长一些，或许是一辈子</subtitle>
  <link href="https://blog.tangspoon.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.tangspoon.cn/"/>
  <updated>2022-02-14T06:28:30.867Z</updated>
  <id>https://blog.tangspoon.cn/</id>
  
  <author>
    <name>ThompsonTang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原创｜自建房没有丰巢？自己造一个！｜打造智能快递柜</title>
    <link href="https://blog.tangspoon.cn/2022/02/14/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%87%AA%E5%BB%BA%E6%88%BF%E6%B2%A1%E6%9C%89%E4%B8%B0%E5%B7%A2%EF%BC%9F%E8%87%AA%E5%B7%B1%E9%80%A0%E4%B8%80%E4%B8%AA%EF%BC%81%EF%BD%9C%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/"/>
    <id>https://blog.tangspoon.cn/2022/02/14/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%87%AA%E5%BB%BA%E6%88%BF%E6%B2%A1%E6%9C%89%E4%B8%B0%E5%B7%A2%EF%BC%9F%E8%87%AA%E5%B7%B1%E9%80%A0%E4%B8%80%E4%B8%AA%EF%BC%81%EF%BD%9C%E6%89%93%E9%80%A0%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/</id>
    <published>2022-02-14T02:51:58.000Z</published>
    <updated>2022-02-14T06:28:30.867Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126161032850.png" alt="image-20220126161032850" /></p><p>前些日子家里装修，网购了好多好多东西。但城中村里没有类似丰巢那样的投递柜（对，我这条村真的没有），放在村里的代收点1块一个小件，2块一个大件，比丰巢还贵？而且感觉要跑超过500m去那个快递很麻烦。所以，我为什么不能自己造一个“丰巢”呢？</p><a id="more"></a><p><img src="https://picbed.tangspoon.cn/uPic/image-20220126161110667.png" alt="image-20220126161110667" /></p><p>物料：</p><p>香橙派、USB继电器、5v电磁锁、单门柜子。</p><h2 id="一-思路"><a class="markdownIt-Anchor" href="#一-思路"></a> 一、思路</h2><p>投递员扫描二维码进入网页，填密码，打开柜子。所以项目主要分为两部分：</p><ol><li>软件：验证密码和控制电磁锁的系统</li><li>硬件：托管系统的硬件，电磁锁</li></ol><p>系统实际上就只有一个密码校验功能，很简单。用flask写超级快。</p><p>硬件部分我选择了香橙派托管flask网页，内网穿透让在外网的投递员访问系统，配合USB继电器来控制电磁锁的开关。</p><h2 id="二-硬件"><a class="markdownIt-Anchor" href="#二-硬件"></a> 二、硬件</h2><h3 id="1-香橙派zero-512mb"><a class="markdownIt-Anchor" href="#1-香橙派zero-512mb"></a> 1. 香橙派zero 512mb</h3><p>闲鱼70包邮</p><h3 id="2-电磁锁"><a class="markdownIt-Anchor" href="#2-电磁锁"></a> 2. 电磁锁</h3><p>购买5v的即可</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150623931.png" alt="image-20220126150623931" /></p><h3 id="3-usb继电器"><a class="markdownIt-Anchor" href="#3-usb继电器"></a> 3. USB继电器</h3><p>优点：免驱、5V供电、商家提供详细说明</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150308608.png" alt="image-20220126150308608" /></p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220126150521278.png" alt="image-20220126150521278" /></p><h2 id="三-软件系统"><a class="markdownIt-Anchor" href="#三-软件系统"></a> 三、软件系统</h2><p><img src="https://picbed.tangspoon.cn/uPic/image-20220103113637980.png" alt="image-20220103113637980" /></p><h3 id="1-flask-主程序-apppy"><a class="markdownIt-Anchor" href="#1-flask-主程序-apppy"></a> 1. flask 主程序 <a href="http://app.py">app.py</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for</span><br><span class="line"><span class="keyword">import</span> decrypt</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;result&#x27;</span>,</span><br><span class="line">                                password=password))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/result&#x27;, methods=[&#x27;GET&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span>():</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        encrypt_text = f.read()</span><br><span class="line">    password = request.args.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> password == decrypt.decrypt_data(encrypt_text):</span><br><span class="line">        os.system(<span class="string">&#x27;bash /root/express_system/open.sh&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&quot;correct.html&quot;</span>,</span><br><span class="line">                               password=password)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;error.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>, port=<span class="number">8443</span>)</span><br></pre></td></tr></table></figure><p>注意：上面 line20 要放<code>password.txt</code>的绝对路径</p><h3 id="2-opensh"><a class="markdownIt-Anchor" href="#2-opensh"></a> 2. <a href="http://open.sh">open.sh</a></h3><p>插入usb电磁继电器之后，香橙派会识别出USB设备。我购买的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo -n -e &quot;\xA0\x01\x01\xA2&quot; &gt;&#x2F;dev&#x2F;ttyUSB0</span><br><span class="line">sleep 0.5s</span><br><span class="line">echo -n -e &quot;\xA0\x01\x00\xA1&quot; &gt;&#x2F;dev&#x2F;ttyUSB0</span><br></pre></td></tr></table></figure><h3 id="3-decryptpy"><a class="markdownIt-Anchor" href="#3-decryptpy"></a> 3. <a href="http://decrypt.py">decrypt.py</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不用做任何修改</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> PKCS1_cipher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">key_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(key_file) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        key = RSA.importKey(data)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_data</span>(<span class="params">encrypt_msg</span>):</span></span><br><span class="line">    private_key = get_key(<span class="string">&#x27;xxxx/xxxx/rsa_private_key.pem&#x27;</span>)</span><br><span class="line">    cipher = PKCS1_cipher.new(private_key)</span><br><span class="line">    back_text = cipher.decrypt(base64.b64decode(encrypt_msg), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> back_text.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意：line15 填写绝对路径</p><h3 id="4-每周更换密码并发送到微信-randpwdweeklypy"><a class="markdownIt-Anchor" href="#4-每周更换密码并发送到微信-randpwdweeklypy"></a> 4. 每周更换密码并发送到微信 <a href="http://randPwdWeekly.py">randPwdWeekly.py</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> PKCS1_cipher</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此脚本设置每周执行一次</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span>(<span class="params">key_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(key_file) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        key = RSA.importKey(data)</span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt_data</span>(<span class="params">msg</span>):</span></span><br><span class="line">    public_key = get_key(<span class="string">&#x27;rsa_public_key.pem&#x27;</span>)</span><br><span class="line">    cipher = PKCS1_cipher.new(public_key)</span><br><span class="line">    encrypt_text = base64.b64encode(cipher.encrypt(bytes(msg.encode(<span class="string">&quot;utf8&quot;</span>))))</span><br><span class="line">    <span class="keyword">return</span> encrypt_text.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server_url = <span class="string">&#x27;https://sctapi.ftqq.com/xxxxxxxx.send&#x27;</span></span><br><span class="line">    randPwd = str(random.randint(<span class="number">100000</span>, <span class="number">1000000</span>))</span><br><span class="line">    print(randPwd)</span><br><span class="line">    <span class="comment"># server酱发送到wechat</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;智能快递柜密码已更新!!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;desp&#x27;</span>: <span class="string">&#x27;新密码是：&#x27;</span> + randPwd</span><br><span class="line">    &#125;</span><br><span class="line">    requests.post(server_url, params=data)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password2.txt&#x27;</span>, <span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(randPwd)</span><br><span class="line">    encrypt_data(randPwd)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/password.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(encrypt_data(randPwd))</span><br></pre></td></tr></table></figure><p>注意：<code>line24</code> 要改成自己的server酱的<code>key</code></p><h3 id="5-生成rsa的两种key-creatersa_keypy"><a class="markdownIt-Anchor" href="#5-生成rsa的两种key-creatersa_keypy"></a> 5. 生成RSA的两种key  createRSA_Key.py</h3><p>该脚本只执行一次即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只用一次！！</span></span><br><span class="line"></span><br><span class="line">random_generator = Random.new().read</span><br><span class="line">rsa = RSA.generate(<span class="number">2048</span>, random_generator)</span><br><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">private_key = rsa.exportKey()</span><br><span class="line">print(private_key.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">public_key = rsa.publickey().exportKey()</span><br><span class="line">print(public_key.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/rsa_private_key.pem&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(private_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/root/express_system/rsa_public_key.pem&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(public_key)</span><br></pre></td></tr></table></figure><h2 id="四-项目运行"><a class="markdownIt-Anchor" href="#四-项目运行"></a> 四、项目运行</h2><h3 id="1-获取项目"><a class="markdownIt-Anchor" href="#1-获取项目"></a> 1. 获取项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tangspoon66&#x2F;express_sys.git</span><br></pre></td></tr></table></figure><h3 id="2-安装flask"><a class="markdownIt-Anchor" href="#2-安装flask"></a> 2. 安装flask</h3><p>参考：<a href="https://blog.tangspoon.cn/2020/12/26/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-Hello/">Flask 学习笔记 - Hello</a></p><h3 id="3-flask后台运行"><a class="markdownIt-Anchor" href="#3-flask后台运行"></a> 3. flask后台运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S express_sys</span><br></pre></td></tr></table></figure><p>在新弹出的screen里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python &#x2F;root&#x2F;express_sys&#x2F;app.py</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有screen</span><br><span class="line">screen -ls</span><br><span class="line"># 返回screen</span><br><span class="line">screen -d screen</span><br></pre></td></tr></table></figure></blockquote><p>随后可以关闭会话窗口，flask项目还是可以访问的。</p><h3 id="4-配置内网穿透frp"><a class="markdownIt-Anchor" href="#4-配置内网穿透frp"></a> 4. 配置内网穿透frp</h3><p>参考：<a href="https://blog.tangspoon.cn/2021/12/24/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BD%9C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B9%E7%9B%AE/">frp 内网穿透怎么用？｜访问内网 web 项目</a></p><h3 id="5-flask-和-frp开机自启"><a class="markdownIt-Anchor" href="#5-flask-和-frp开机自启"></a> 5. flask 和 frp开机自启</h3><p>参考：<a href="https://blog.tangspoon.cn/2022/01/04/linux%E4%BD%BF%E7%94%A8supervisor%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/">linux 使用 supervisor 实现开机自启</a></p><h3 id="6-还需要更改一些绝对路径之类的"><a class="markdownIt-Anchor" href="#6-还需要更改一些绝对路径之类的"></a> 6. 还需要更改一些绝对路径之类的。</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220126161032850.png&quot; alt=&quot;image-20220126161032850&quot; /&gt;&lt;/p&gt;
&lt;p&gt;前些日子家里装修，网购了好多好多东西。但城中村里没有类似丰巢那样的投递柜（对，我这条村真的没有），放在村里的代收点1块一个小件，2块一个大件，比丰巢还贵？而且感觉要跑超过500m去那个快递很麻烦。所以，我为什么不能自己造一个“丰巢”呢？&lt;/p&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://blog.tangspoon.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
    <category term="Flask" scheme="https://blog.tangspoon.cn/tags/Flask/"/>
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
    <category term="OrangePi" scheme="https://blog.tangspoon.cn/tags/OrangePi/"/>
    
  </entry>
  
  <entry>
    <title>macOS重装Homebrew</title>
    <link href="https://blog.tangspoon.cn/2022/02/12/macOS%E5%AE%89%E8%A3%85aira2%E5%AF%BC%E8%87%B4Homebrew%E5%8F%97%E6%8D%9F%EF%BD%9C%E4%BF%AE%E5%A4%8D/"/>
    <id>https://blog.tangspoon.cn/2022/02/12/macOS%E5%AE%89%E8%A3%85aira2%E5%AF%BC%E8%87%B4Homebrew%E5%8F%97%E6%8D%9F%EF%BD%9C%E4%BF%AE%E5%A4%8D/</id>
    <published>2022-02-12T07:25:49.000Z</published>
    <updated>2022-02-14T06:33:40.806Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220205152726453.png" alt="image-20220205152726453" style="zoom:50%;" /><p>Homebrew可谓是macOS的大杀器，aira2是下载届的大杀器。前两天安装aria2的时候，出现了openssl版本错误的问题，我就使用<code>brew install openssl</code>的命令升级到<code>openssl3</code>，结果越搞越乱，到最后直接brew命令都是用不了。刚好能不能通过重新安装brew来解决问题？可是一系列问题随之出现。</p><a id="more"></a><h2 id="一-解决方法一"><a class="markdownIt-Anchor" href="#一-解决方法一"></a> 一、解决方法一</h2><p>使用官方命令重装Homebrew，无法连接到github。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;HEAD&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20220205153314436.png" alt="image-20220205153314436" /></p><blockquote><p>curl: (7) Failed to connect to <a href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> port 443: Connection refused</p></blockquote><p>更换了阿里云的源也无法解决问题。</p><p>最后bilibili一个up主<code>mintimate</code>，他自己写了一个自动安装脚本，一下子帮我完美解决问题。</p><p>mintimate的blog地址：<a href="https://mintimate.cn/2020/04/05/Homebrew/">https://mintimate.cn/2020/04/05/Homebrew/</a></p><img src="https://picbed.tangspoon.cn/uPic/image-20220205153750700.png" alt="image-20220205153750700" style="zoom:50%;" /><h2 id="一-解决方法二"><a class="markdownIt-Anchor" href="#一-解决方法二"></a> 一、解决方法二</h2><p>详情请查看：<a href="https://blog.tangspoon.cn/2022/02/05/macOS%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%8C%E8%A7%A3%E5%86%B3curl%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/">macOS 让终端走代理，解决 curl 失败问题</a></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220205152726453.png&quot; alt=&quot;image-20220205152726453&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;p&gt;Homebrew可谓是macOS的大杀器，aira2是下载届的大杀器。前两天安装aria2的时候，出现了openssl版本错误的问题，我就使用&lt;code&gt;brew install openssl&lt;/code&gt;的命令升级到&lt;code&gt;openssl3&lt;/code&gt;，结果越搞越乱，到最后直接brew命令都是用不了。刚好能不能通过重新安装brew来解决问题？可是一系列问题随之出现。&lt;/p&gt;</summary>
    
    
    
    <category term="macOS" scheme="https://blog.tangspoon.cn/categories/macOS/"/>
    
    
    <category term="troubleshooting" scheme="https://blog.tangspoon.cn/tags/troubleshooting/"/>
    
    <category term="macOS" scheme="https://blog.tangspoon.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-06｜算法-排序</title>
    <link href="https://blog.tangspoon.cn/2022/02/12/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-06%EF%BD%9C%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.tangspoon.cn/2022/02/12/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-06%EF%BD%9C%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</id>
    <published>2022-02-12T06:45:23.000Z</published>
    <updated>2022-02-12T06:51:16.829Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220212144332679.png" alt="image-20220212144332679" style="zoom:85%;" /><p>冒泡、选择、插入、快速排序</p><a id="more"></a><blockquote><h3 id="排序算法的稳定性"><a class="markdownIt-Anchor" href="#排序算法的稳定性"></a> 排序算法的稳定性</h3><p>排序算法的稳定性是指，在排序过程中，值相同的元素间的相对位置跟排序前的相对位置是一样的。举个例子，排序前一个数组为{3, 2, 1, 2’, 4}，我们用2’来区分第二个2和第一个2，假如是稳定的排序算法，它的结果一定是这样{1, 2, 2’, 3, 4}，而如果不稳定的算法，它的结果有可能是这样{1, 2’, 2, 3, 4}。</p><p>为什么我们要强调稳定性呢？举个例子，假如我们需要排序一个订单，需要按照时间和价格进行升序排序，首先会先将所有订单按时间升序排序，然后再进行价格的升序排序，假如价格排序不是一个稳定的排序，那么订单的时间就有可能不会按升序排列，所以在特定情况下，排序算法的稳定性是一个比较重要的考虑因素。</p><p>作者：特雷西多士<br />链接：<a href="https://juejin.cn/post/6844903966514348040">https://juejin.cn/post/6844903966514348040</a><br />来源：稀土掘金<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id="一-冒泡排序"><a class="markdownIt-Anchor" href="#一-冒泡排序"></a> 一、冒泡排序</h3><blockquote><p>参考：<a href="https://github.com/facert/python-data-structure-cn/tree/master/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2">https://github.com/facert/python-data-structure-cn/tree/master/5.排序和搜索</a></p></blockquote><p>「冒泡」这个命名十分形象：越小的元素会逐渐冒泡到数列的前端。</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220211111950717.png" alt="image-20220211111950717" /></p><p>缺点：低效</p><ul><li>每个数据都得经过若干次交换才能找到自己的位置。特别是对于大号靠前的数据。</li><li>假如数组在冒泡排序的途中已经排好了正确的顺序，算法还是会迭代到最后一个元素，浪费性能和时间。</li></ul><p>优点：稳定性好</p><p>因为只有当两个数不相等时才会交换，所以例如像5和5`这样的（前后不一样，值一样）是不会交换的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">data</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> data[i]&gt;data[i+<span class="number">1</span>]:</span><br><span class="line">                data[i],data[i+<span class="number">1</span>]=data[i+<span class="number">1</span>],data[i]</span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">bubbleSrot(data)</span><br><span class="line">print(<span class="string">&#x27;冒泡排序：&#x27;</span>, data)</span><br></pre></td></tr></table></figure><h3 id="二-选择排序"><a class="markdownIt-Anchor" href="#二-选择排序"></a> 二、选择排序</h3><blockquote><p>参考：<a href="https://github.com/facert/python-data-structure-cn/tree/master/5.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2">https://github.com/facert/python-data-structure-cn/tree/master/5.排序和搜索</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span>(<span class="params">data</span>):</span></span><br><span class="line"><span class="keyword">for</span> now_len <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">    temp_location=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> now_location <span class="keyword">in</span> range(<span class="number">1</span>,now_len+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[now_location]&gt;data[temp_location]:</span><br><span class="line">                temp_location=now_location</span><br><span class="line">                </span><br><span class="line">data[temp_location],data[now_location]=data[now_location],data[temp_location]</span><br><span class="line">     </span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">bubbleSrot(data)</span><br><span class="line">print(<span class="string">&#x27;选择排序：&#x27;</span>, data)  </span><br></pre></td></tr></table></figure><h3 id="三-插入排序"><a class="markdownIt-Anchor" href="#三-插入排序"></a> 三、插入排序</h3><p>目前个人觉得最好理解的教程是Derrick Sherril这位YouTuber</p><blockquote><p><a href="https://www.youtube.com/watch?v=byHi41L9vTM">https://www.youtube.com/watch?v=byHi41L9vTM</a></p></blockquote><p>直接上代码，狗都能看懂。其实就是当数列前一个大于后一个的时候，两个数字交换。但为了持续比较，需要在一个<code>while</code>里面不断判断，每次<code>i-1</code>就可以遍历前面的<code>unsorted</code>的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(data)):</span><br><span class="line">        <span class="keyword">while</span> data[i<span class="number">-1</span>]&gt;data[i] <span class="keyword">and</span> i &gt; <span class="number">0</span>:</span><br><span class="line">            data[i<span class="number">-1</span>],data[i] = data[i], data[i<span class="number">-1</span>]</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line">insertSrot(data)</span><br><span class="line">print(<span class="string">&#x27;插入排序：&#x27;</span>, data) </span><br></pre></td></tr></table></figure><h3 id="四-快速排序递归排序"><a class="markdownIt-Anchor" href="#四-快速排序递归排序"></a> 四、快速排序（递归排序）</h3><p>快速排序的最简单解释同样来自Derrick Sherril</p><blockquote><p>解学武之快速排序：<a href="https://www.youtube.com/watch?v=kFeXwkgnQ9U">https://www.youtube.com/watch?v=kFeXwkgnQ9U</a></p></blockquote><p>以随便一个数为标准，Derrick用了最后一个。提取出标准数，遍历数组剩下的值，比标准数小的放在左边，大的在右。然后一直递归下去就可以。结束条件是不用比较的最小规模：当数组只剩下1个或0个的时候。这时我们直接返回长度只有1个或0个的数组即可。</p><p>另外有个讲算法很详细的网站：</p><blockquote><p><a href="http://data.biancheng.net/view/117.html">http://data.biancheng.net/view/117.html</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    length = len(data)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = data.pop()</span><br><span class="line"></span><br><span class="line">    items_bigger = []</span><br><span class="line">    items_smaller = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> item &lt; pivot:</span><br><span class="line">            items_smaller.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items_bigger.append(item)</span><br><span class="line">    <span class="keyword">return</span> quickSort(items_smaller) + [pivot] + quickSort(items_bigger)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">99</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;快速排序：&#x27;</span>, quickSort(data))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-其他"><a class="markdownIt-Anchor" href="#五-其他"></a> 五、其他</h3><p>其他还有归并排序和希尔排序。日后在Coursera的Data Structrues课程中再深入学习。</p><blockquote><p><a href="https://www.coursera.org/learn/python-data?action=enroll">https://www.coursera.org/learn/python-data?action=enroll</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220212144332679.png&quot; alt=&quot;image-20220212144332679&quot; style=&quot;zoom:85%;&quot; /&gt;
&lt;p&gt;冒泡、选择、插入、快速排序&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>frp内网穿透怎么用？｜访问内网web项目</title>
    <link href="https://blog.tangspoon.cn/2022/02/11/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BD%9C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B9%E7%9B%AE/"/>
    <id>https://blog.tangspoon.cn/2022/02/11/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%EF%BD%9C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-02-11T12:16:13.000Z</published>
    <updated>2022-02-14T06:31:54.514Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211224213850815.png" alt="image-20211224213850815" style="zoom:35%;" /><p>想做一个智能快递柜，想法是快递员扫码进入网页，输入信息验证成功后，香橙派就控制打开电磁锁。因为对esp和MQTT协议不熟悉，所以只能选择香橙派+内网穿透曲线救国的方式实现效果。当然，成本也会高很多。（esp几块钱，香橙派二手70+）</p><a id="more"></a><h2 id="一-服务端"><a class="markdownIt-Anchor" href="#一-服务端"></a> 一、服务端</h2><p>服务端应用在vps。（如果是arm系统，需要更改wget的地址）</p><h3 id="1-拉取源代码修改配置"><a class="markdownIt-Anchor" href="#1-拉取源代码修改配置"></a> 1. 拉取源代码&amp;修改配置</h3><p>（我这个是0.38版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.38.0&#x2F;frp_0.38.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line">mv frp_0.38.0_linux_amd64 frps</span><br><span class="line">cd frps</span><br><span class="line">vim frps.ini</span><br></pre></td></tr></table></figure><img src="https://picbed.tangspoon.cn/uPic/image-20211224202926625.png" alt="image-20211224202926625" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">dashboard_port &#x3D; 7500</span><br><span class="line">bind_port &#x3D; 7000</span><br><span class="line">vhost_http_port &#x3D; 8443</span><br></pre></td></tr></table></figure><p><code>bind_port</code>：server端和client端对接端口</p><p><code>dashboard_port</code>：frp面板端口</p><p><code>vhost_http_port</code>：http服务端口</p><h3 id="2-放行端口"><a class="markdownIt-Anchor" href="#2-放行端口"></a> 2. 放行端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 8443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 7000 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 7500 -j ACCEPT</span><br><span class="line">iptables-save &gt; &#x2F;etc&#x2F;iptables.up.rules</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br></pre></td></tr></table></figure><h3 id="3-启动"><a class="markdownIt-Anchor" href="#3-启动"></a> 3. 启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frps -c .&#x2F;frps.ini &gt; frps.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><code>nohup</code>：可以把frps后台启动</p><blockquote><p>关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关闭frp</span><br><span class="line">ps -aux|grep frp| grep -v grep</span><br><span class="line"># 找出进程id xxx</span><br><span class="line">kill -9 xxx</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://picbed.tangspoon.cn/uPic/image-20211224211757919.png" alt="image-20211224211757919" /></p><h2 id="二-客户端"><a class="markdownIt-Anchor" href="#二-客户端"></a> 二、客户端</h2><p>同样也要下载0.38版本（要和服务端相同）</p><p>macOS下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_darwin_amd64.tar.gz">frp_0.38.0_darwin_amd64.tar.gz</a></p><p>linux下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz">frp_0.38.0_linux_amd64.tar.gz</a></p><p>Windows下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_windows_amd64.zip">frp_0.38.0_windows_amd64.zip</a></p><p>树莓派/香橙派下载：<a href="https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_arm.tar.gz">frp_0.38.0_linux_arm.tar.gz</a></p><p><strong>我这里以macOS版演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.38.0&#x2F;frp_0.38.0_darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.38.0_darwin_amd64.tar.gz</span><br><span class="line">mv frp_0.38.0_darwin_amd64 frpc</span><br><span class="line">cd frpc</span><br><span class="line">vim frpc.ini</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; xxxxx</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">type &#x3D; http</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 8443</span><br><span class="line">use_encryption &#x3D; false</span><br><span class="line">use_compression &#x3D; true</span><br><span class="line">custom_domains &#x3D; frp.xxxx.cn</span><br></pre></td></tr></table></figure><p><code>server_addr</code>：是服务端的ip，也就是vps的ip</p><p><code>server_port</code>：要和服务端填写的<code>bind_port</code>一致</p><p><code>local_port</code>：要和服务端填写的<code>vhost_http_port</code>一致</p><p><code>custom_domains</code>：服务端的ip/域名</p><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup .&#x2F;frpc -c .&#x2F;frpc.ini &gt; frpc.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20211224211909398.png" alt="image-20211224211909398" /></p><h3 id="三-面板"><a class="markdownIt-Anchor" href="#三-面板"></a> 三、面板</h3><p>访问地址：ip:7500</p><p>访问不了可能是没有放行端口</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211224212321698.png" alt="image-20211224212321698" /></p><p><strong>有个HTTP服务证明内网穿透已经成功</strong></p><hr /><p>⚠️注意：内网web项目端口要和<code>vhost_http_port</code>保持一致</p><p><strong>实例</strong></p><p>使用<code>webpy</code>框架建立个demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装webpy</span><br><span class="line">python3 -m pip install web.py&#x3D;&#x3D;0.61</span><br></pre></td></tr></table></figure><p>在电脑桌面新建个<code>test.py</code>项目，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import web</span><br><span class="line">import logging</span><br><span class="line"> </span><br><span class="line">urls&#x3D;(&#39;&#x2F;&#39;, &#39;Index&#39;)</span><br><span class="line"> </span><br><span class="line">logging.basicConfig(level&#x3D;logging.NOTSET)</span><br><span class="line"> </span><br><span class="line">app &#x3D; web.application(urls, globals())</span><br><span class="line"> </span><br><span class="line">class Index:</span><br><span class="line">    def GET(self):</span><br><span class="line">        logging.info(&#39;你好世界&#39;)</span><br><span class="line">        web.header(&#39;Content-Type&#39;, &#39;text&#x2F;html;charset&#x3D;UTF-8&#39;)</span><br><span class="line">        return &#39;你好世界&#39;</span><br><span class="line"> </span><br><span class="line">def notfound():</span><br><span class="line">    return web.notfound(&quot;Sorry, the page you were looking for was not found.&quot;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.notfound &#x3D; notfound;</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>运行web项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py <span class="number">8443</span></span><br></pre></td></tr></table></figure><p>⚠️注意：标明要8443端口</p><p>浏览器访问 ip:8443</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211224213434793.png" alt="image-20211224213434793" /></p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211224213708050.png" alt="image-20211224213708050" /></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211224213850815.png&quot; alt=&quot;image-20211224213850815&quot; style=&quot;zoom:35%;&quot; /&gt;
&lt;p&gt;想做一个智能快递柜，想法是快递员扫码进入网页，输入信息验证成功后，香橙派就控制打开电磁锁。因为对esp和MQTT协议不熟悉，所以只能选择香橙派+内网穿透曲线救国的方式实现效果。当然，成本也会高很多。（esp几块钱，香橙派二手70+）&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    <category term="智能快递柜" scheme="https://blog.tangspoon.cn/categories/linux/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-04｜复习</title>
    <link href="https://blog.tangspoon.cn/2022/02/09/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-04%EF%BD%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.tangspoon.cn/2022/02/09/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-04%EF%BD%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-02-09T10:46:32.000Z</published>
    <updated>2022-02-09T10:48:24.150Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p><p>标准库：os、random、time、datetime</p><a id="more"></a><h2 id="一-os模块"><a class="markdownIt-Anchor" href="#一-os模块"></a> 一、os模块</h2><p>os模块是提供的接口可以实现跨平台访问。但有些例外。</p><h3 id="1-系统相关"><a class="markdownIt-Anchor" href="#1-系统相关"></a> 1. 系统相关</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.name <span class="comment"># 查看当前操作系统的命令，win--&gt;nt linux--&gt;posix</span></span><br><span class="line">os.environ <span class="comment"># 获取环境变量</span></span><br></pre></td></tr></table></figure><h3 id="2-文件和目录操作"><a class="markdownIt-Anchor" href="#2-文件和目录操作"></a> 2. 文件和目录操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd() <span class="comment">## 来获取当前工作目录</span></span><br><span class="line">os.chdir(<span class="string">&#x27;dirname&#x27;</span>) <span class="comment">## 相当于shell下的cd，改变当前脚本的目录</span></span><br><span class="line">os.remove(<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line">os.rename(<span class="string">&#x27;oldname&#x27;</span>,<span class="string">&#x27;new&#x27;</span>)</span><br><span class="line">os.listdir(<span class="string">&#x27;dirname&#x27;</span>)</span><br><span class="line">os.path.abspath(<span class="string">&#x27;dirname&#x27;</span>) <span class="comment">## 返回绝对路</span></span><br></pre></td></tr></table></figure><h3 id="3-执行命令"><a class="markdownIt-Anchor" href="#3-执行命令"></a> 3. 执行命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;command&#x27;</span>)</span><br><span class="line">os.popen(<span class="string">&#x27;command&#x27;</span>)</span><br></pre></td></tr></table></figure><p>两者区别是，前者指返回一个状态码，没有任何其他输出内容。后者会返回command的结果。比如我要执行<code>ls</code>这样的shell命令，就需要时候后者。</p><h2 id="二-random"><a class="markdownIt-Anchor" href="#二-random"></a> 二、random</h2><p>生成随机函数。该模块有在智能快递柜项目中应用：生成六位随机密码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 0～1浮点数</span></span><br><span class="line">random.random()</span><br><span class="line"><span class="comment">#2 指定范围浮点数</span></span><br><span class="line">random.uniform(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="comment">#3 指定范围整数</span></span><br><span class="line">random.randint(<span class="number">10</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">#4 固定间隔的随机数</span></span><br><span class="line">random.randrange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#5 在固定的sequence中随机生成</span></span><br><span class="line">random.choice([<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;cdd&#x27;</span>])</span><br><span class="line"><span class="comment">#6 打乱列表元素</span></span><br><span class="line">ll=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line">print(ll)</span><br><span class="line"><span class="comment">#5 切片返回随机固定长度</span></span><br><span class="line">random.sample(<span class="string">&#x27;list&#x27;</span>,num)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：#6中不能直接<code>print('random.shuffle(list)')</code>，该库的作用是打乱列表元素，是直接作用于改变列表的，并不会有任何返回值。</p><h3 id="三-time时间模块"><a class="markdownIt-Anchor" href="#三-time时间模块"></a> 三、time时间模块</h3><p>只支持到2038年，需要更换到datetime。</p><p>在python中有三种方式来表示时间：时间戳、格式化时间字符串、结构化时间。</p><h3 id="1-时间戳"><a class="markdownIt-Anchor" href="#1-时间戳"></a> 1. 时间戳</h3><p>时间戳在<a href="https://blog.tangspoon.cn/2021/12/06/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%BD%AC%E5%8F%91B%E7%AB%99UP%E4%B8%BB%E5%8A%A8%E6%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1python%E8%84%9A%E6%9C%AC/">《原创｜转发B站UP主动态到微信python脚本》</a>有相关应用，可以通过<code>time.time()</code>获得。获得时间戳后可有用<code>time.localtime(time.time())</code>来转化为结构化时间。</p><img src="https://picbed.tangspoon.cn/uPic/image-20220209155458114.png" alt="image-20220209155458114" style="zoom:50%;" /><p>时间戳可做算术运算：计算程序运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">t1=time.time()</span><br><span class="line">func()</span><br><span class="line">t2=time.time()</span><br><span class="line">print(t2-t1)</span><br></pre></td></tr></table></figure><h3 id="2-结构化时间struct_time"><a class="markdownIt-Anchor" href="#2-结构化时间struct_time"></a> 2. 结构化时间(struct_time)</h3><p>一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code></p><p>注意：<code>time.localtime()</code>的作用是格式化时间戳为本地时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lt = time.localtime()</span><br><span class="line">print(lt[:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># (2022, 2, 9)</span></span><br></pre></td></tr></table></figure><h3 id="3-格式化时间字符串"><a class="markdownIt-Anchor" href="#3-格式化时间字符串"></a> 3. 格式化时间字符串</h3><p>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>类似的方式即可获得格式化时间的字符串。</p><p>比如我用<code>time.localtime(time.time())</code>获得了具有结构化时间，现在我要格式化成我想要的时间格式：20220101，我可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct_time&#x3D;time.localtime(time.time())</span><br><span class="line">time.strftime(&#39;%Y%m%d&#39;,struct_time)</span><br></pre></td></tr></table></figure><h3 id="4-反向格式化"><a class="markdownIt-Anchor" href="#4-反向格式化"></a> 4. 反向格式化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="string">&#x27;20220901&#x27;</span></span><br><span class="line">st=time.strptime(t,<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line"><span class="comment">#输出time.struct_time(tm_year=2022, tm_mon=9, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=244, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure><p>注意：<code>t</code>和<code>st</code>里面的格式必须相同。比如<code>t</code>的年月日使用<code>-</code>隔开，那么<code>%Y-%m</code></p><h3 id="四-datetime"><a class="markdownIt-Anchor" href="#四-datetime"></a> 四、datetime</h3><p>time和datetime的区别：前者到1970～2038年，后者比前者高级了不少，可以理解为是对前者进行了封装，提供了更多的实用函数。</p><p>主要包含有几个类别：</p><ul><li><ol><li>time：只关注时间</li></ol></li><li><ol start="2"><li>date：只关注日期</li></ol></li><li><ol start="3"><li>datetime：以上两者都有</li></ol></li><li><ol start="4"><li>timedelta：计算时间跨度</li></ol></li><li><ol start="5"><li>tzinfo：时区</li></ol></li></ul><p>注意：几个类别都是属于datetime模块的函数，都需要导入使用。</p><p>实际使用中，用的比较多的是<code>3</code>和<code>4</code>，<code>1、2</code>和<code>3</code>并没有太大区别，也就是说基本可以取代。</p><p>所以，我上面图片中的代码其实可以更好的优化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过time.time()获得当前时间戳,通过fromtimestamp转换成date</span></span><br><span class="line">dt=date.fromtimestamp(time.time())</span><br><span class="line">print(dt.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png&quot; alt=&quot;image-20211208153223437&quot; /&gt;&lt;/p&gt;
&lt;p&gt;标准库：os、random、time、datetime&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>macOS让终端走代理，解决curl失败问题</title>
    <link href="https://blog.tangspoon.cn/2022/02/09/macOS%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%8C%E8%A7%A3%E5%86%B3curl%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.tangspoon.cn/2022/02/09/macOS%E8%AE%A9%E7%BB%88%E7%AB%AF%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%8C%E8%A7%A3%E5%86%B3curl%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-09T07:59:28.000Z</published>
    <updated>2022-02-14T06:29:47.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220205160123197.png" alt="image-20220205160123197" /></p><a id="more"></a><p>前提是你得有代理</p><p>我使用的是<code>ClashX.app</code>软件，可以看到HTTP端口是7892</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220205155421631.png" alt="image-20220205155421631" /></p><p>那么我们要让终端走HTTP代理，在终端执行下面的代码即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7892;export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7892</span><br></pre></td></tr></table></figure><p>注意：只是在当前页面终端页面有效。</p><p>测试是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ip.gs</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20220205155734830.png" alt="image-20220205155734830" /></p><p>现在就应该可以<code>curl</code>github的内容了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220205160123197.png&quot; alt=&quot;image-20220205160123197&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="macOS" scheme="https://blog.tangspoon.cn/categories/macOS/"/>
    
    
    <category term="macOS" scheme="https://blog.tangspoon.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-07｜数据结构</title>
    <link href="https://blog.tangspoon.cn/2022/02/05/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-07%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.tangspoon.cn/2022/02/05/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-07%EF%BD%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-02-05T13:32:51.000Z</published>
    <updated>2022-02-14T06:32:47.776Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220212213658145.png" alt="image-20220212213658145" style="zoom:50%;" /><p>栈、单链表。</p><p>会进修 Coursera 的 Data Structures 课程，日后完善丰富。</p><a id="more"></a><blockquote><ol><li>学习数据结构的好助手：<a href="https://pythontutor.com/">Python Tutor</a>。可以展示python代码的每一步执行。</li><li>非常好的博客：<a href="https://nemo.cool/254.html">多种数据结构的python实现形式</a></li><li><a href="https://github.com/facert/python-data-structure-cn/tree/master/3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.21.%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8%EF%BC%9A%E9%93%BE%E8%A1%A8">python-data-structrue-cn</a></li><li><a href="https://codingdict.com/article/4850">CodingDict的Python数据结构</a></li></ol></blockquote><p>理解：数据结构：数据以哪种方式、组织形式存储在电脑中，每一种储存方式都有其特点。</p><p>在设计一个程序/模块前，通常需要选择好数据结构，然后再设计算法。举个不太恰当的例子：我在做网易云闹钟时，需要储存<code>uid</code>和<code>url</code>，使用列表存储和读取都比较缓慢，但使用字典就非常快速的。（列表是数据结构「序列」的一种类型，而字典则是一种「可变形容器」。关于数据类型和数据结构的区别可详细查看知乎的提问：<a href="https://www.zhihu.com/question/21165020">「数据结构」和「数据类型」两个概念的本质，区别与联系</a>。里面一位叫「沈兄」的回答很好理解。）</p><h2 id="一-栈"><a class="markdownIt-Anchor" href="#一-栈"></a> 一、栈</h2><img src="https://picbed.tangspoon.cn/uPic/image-20220210102612544.png" alt="image-20220210102612544" style="zoom: 50%;" /><ul><li>也叫后进先出表</li><li>栈顶top：插入删除操作的顶端</li><li>栈底bottom</li><li>栈元素个数为0时：空栈</li><li>插入：push</li><li>删除：pop</li><li>时间复杂度为O（1）</li></ul><p>我们用python来构造出栈这个数据结构：进栈、出栈、查看最顶元素、判断是否为空、返回栈的大小。</p><p>实现原理就是用数组以左为基点，逆时针旋转90度，结合数组的append和pop操作，就是一个栈了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, limit=<span class="number">10</span></span>):</span></span><br><span class="line">        self.stack = []  <span class="comment"># 存放元素</span></span><br><span class="line">        self.limit = limit  <span class="comment"># 栈容量极限</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, data</span>):</span>  <span class="comment"># 判断栈是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack) &gt;= self.limit:</span><br><span class="line">            print(<span class="string">&#x27;StackOverflowError&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.stack.append(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&#x27;pop from an empty stack&#x27;</span>)  <span class="comment"># 空栈不能被弹出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span>  <span class="comment"># 查看堆栈的最上面的元素</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span>  <span class="comment"># 判断栈是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> bool(self.stack)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span>  <span class="comment"># 返回栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br></pre></td></tr></table></figure><p>题目：根据栈的结构特点，检查括号是否完全匹配。</p><p>我们可以利用「左括号」进栈，在遍历到「右括号」时，就出栈。括号匹配的情况是：当pop完最后一个元素后，栈是empty的，这种情况就是True的。括号不匹配有两种情况：左括号&gt;右括号，左括号&lt;右括号。第一种栈is not empty的时候就是不匹配的。第二种当栈is empty的时候括号不匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接上面的stack代码。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">balanced_parenthesses</span>(<span class="params">parenthesses</span>):</span></span><br><span class="line">stack=Stack(len(parenthesses))</span><br><span class="line">    <span class="keyword">for</span> parenthess <span class="keyword">in</span> parenthesses:</span><br><span class="line">        <span class="keyword">if</span> parenthess==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.push(parenthess)</span><br><span class="line">        <span class="keyword">elif</span> parenthess==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> stack.is_empty:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> stack.is_empty </span><br><span class="line"><span class="comment"># 如果True就是对称的。对称的情况是左括号刚好被pop完，没有右括号了，直接跳出循环判断是否为空即可。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    examples = [<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;((())&#x27;</span>, <span class="string">&#x27;()))&#x27;</span>]</span><br><span class="line">    print(<span class="string">&#x27;Balanced parentheses demonstration:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> examples:</span><br><span class="line">        print(example + <span class="string">&#x27;: &#x27;</span> + str(balanced_parentheses(example)))</span><br></pre></td></tr></table></figure><h2 id="二-链表"><a class="markdownIt-Anchor" href="#二-链表"></a> 二、链表</h2><h3 id="1-单链表"><a class="markdownIt-Anchor" href="#1-单链表"></a> 1. 单链表</h3><blockquote><p>参考：<a href="https://blog.csdn.net/chenmozhe22/article/details/108751941">Python—链表基础（小白入门系列）—节点 &amp; 单向链表</a></p></blockquote><h4 id="链表组成"><a class="markdownIt-Anchor" href="#链表组成"></a> 链表组成</h4><p>链表实际上由两部分组成：head 和 节点node。head永远指向第一个node；node由元素和下一节点的指向next两部分组成。</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220212155951415.png" alt="image-20220212155951415" /></p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220212155924559.png" alt="image-20220212155924559" /></p><h4 id="链表的用处优势和劣势"><a class="markdownIt-Anchor" href="#链表的用处优势和劣势"></a> 链表的用处（优势和劣势）</h4><p>对于列表，是一块大的连续内存空间，每次初始化都需要开辟一大块内存，空间利用率低。更重要的是，插入一个元素，所有其他元素的位置都变了。所以在插入、删除元素的时候效率比较低。</p><p>优势：</p><ul><li>链表是非连续的内存空间，每个节点单独存在自己的内存空间，通过指针指向下一个节点。</li><li>如果在某个地方插入一个节点，只需要改变指针的指向即可，不用其他元素都变动。</li></ul><p>劣势：</p><ul><li>每次查找一个元素，都必须从头指针开始一个一个往下查找。</li><li>如果中间某个节点指向断开，那错误节点后面的所有其他节点就都找不到了。</li></ul><p>从上面可以看出，插入数据 链表胜于列表。</p><p>我们在明白了链表的组成之后，我们用python来实现实现该数据结构。</p><h4 id="node节点的理解"><a class="markdownIt-Anchor" href="#node节点的理解"></a> node节点的理解</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造一个node类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleNode</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="comment"># item存放数据元素</span></span><br><span class="line">        self.item=item</span><br><span class="line">        <span class="comment"># next是下一个节点node的指向</span></span><br><span class="line">    self.next=<span class="literal">None</span></span><br></pre></td></tr></table></figure><p>我们尝试利用链表的原理，来应用一下next的指向</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node1 = singleNode(<span class="number">5</span>)</span><br><span class="line">node2 = singleNode(<span class="number">8</span>)</span><br><span class="line">node1.next = node2</span><br><span class="line">print(node1.item) <span class="comment"># 5</span></span><br><span class="line">print(node1.next.item) <span class="comment"># 8</span></span><br><span class="line">print(node2) </span><br></pre></td></tr></table></figure><p>由<code>line5</code>输出8，可以知道我们是可以通过<code>node1</code>来实现<code>node2</code>的输出的，表示链接成功。</p><p><code>line3</code>的作用很重要：把<code>node1</code>指向<code>node2</code>。其实就是把<code>node2</code>的内存地址赋值给<code>node1.next</code>。</p><h4 id="添加节点的真实过程"><a class="markdownIt-Anchor" href="#添加节点的真实过程"></a> 添加节点的真实过程</h4><p>链表对象具有的功能必须有：添加节点。但添加节点应该是先把新元素指向给<code>node1</code>，然后再把<code>head</code>移动到新元素上。如果先移动<code>head</code>，新的元素还没有指向<code>node1</code>，这时候指向已经断裂了。</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220212170801427.png" alt="image-20220212170801427" /></p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220212170828666.png" alt="image-20220212170828666" /></p><p>下面我们开始定义链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleLinkedlist</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="comment"># 新node</span></span><br><span class="line">        node = singleNode(item)</span><br><span class="line">        <span class="comment"># 先把新的链接域指向头及节点，也就是__head的指向位置</span></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        <span class="comment"># 将链表的头__head指向新节点</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_first_node</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = singleLinkedlist()</span><br><span class="line">s.add(<span class="number">6</span>)</span><br><span class="line">s.add(<span class="number">1</span>)</span><br><span class="line">fn=s.get_first_node()</span><br><span class="line">print(fn.item)</span><br></pre></td></tr></table></figure><p>有些概念要明确：在设计程序时，我们应该以程序最小规模来思考设计。我们设计<code>add()</code>方法，链表的最小规模是一个节点都没有。所以<code>add()</code>方法可以这样思考：在创建了一个新node之后，就先处理这个node的指向next（不然就断了连接），也就是指向下一个<strong>node的地址：其实就是head</strong>。然后移动head指向node的地址。</p><h4 id="链表的其他方法"><a class="markdownIt-Anchor" href="#链表的其他方法"></a> 链表的其他方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment"># 判断是否为空</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.__head=<span class="literal">None</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 计算长度</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">       count=<span class="number">0</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           count+=<span class="number">1</span></span><br><span class="line">           cur=cur.next <span class="comment"># cur.next代表下一个元素，所以这个操作代表着__head的后移</span></span><br><span class="line">           </span><br><span class="line">       <span class="keyword">return</span> count</span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 遍历链表的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">travel</span>(<span class="params">self</span>):</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           print(cur.item)</span><br><span class="line">           cur=cur.next</span><br><span class="line">           </span><br><span class="line">   <span class="comment"># 在末尾添加节点</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self</span>):</span></span><br><span class="line">       node=singleLinkedlist()</span><br><span class="line">       <span class="keyword">if</span> self.is_empty():</span><br><span class="line">           self.__head=node</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cur=self.__haed</span><br><span class="line">           <span class="keyword">while</span> cur.next!=<span class="literal">None</span>: <span class="comment"># 最后一个node的node.next是None</span></span><br><span class="line">               cur=cur.next</span><br><span class="line">           cur.next=node</span><br><span class="line"><span class="comment"># 插入节点</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,pos,item</span>):</span></span><br><span class="line">       <span class="comment"># 若指定位置pos为第一个元素之前，则执行头部插入，也就是一开始写的add操作</span></span><br><span class="line">       <span class="keyword">if</span> pos&lt;=<span class="number">0</span>:</span><br><span class="line">           self.add(item)</span><br><span class="line">       <span class="keyword">elif</span> pos&gt;(self.length()<span class="number">-1</span>): <span class="comment"># 尾部</span></span><br><span class="line">           self.pop(item)</span><br><span class="line">       <span class="keyword">else</span>: <span class="comment"># 中部</span></span><br><span class="line">           node = singleLinkedlist(item)</span><br><span class="line">           cur=self.__head</span><br><span class="line">           count=<span class="number">0</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">while</span> count&lt;(pos<span class="number">-1</span>):</span><br><span class="line">               count+=<span class="number">1</span></span><br><span class="line">               cur=cur.next</span><br><span class="line">               </span><br><span class="line">           node.next=cur.next <span class="comment"># 先把新node指向pos的后一个数,也就是cur.next</span></span><br><span class="line">           cur.next=node <span class="comment"># 然后再把在pos的node指向新node</span></span><br><span class="line">   <span class="comment"># 查找    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,item</span>):</span></span><br><span class="line">       cur=self.__head</span><br><span class="line">       <span class="keyword">while</span> cur!=<span class="literal">None</span>:</span><br><span class="line">           <span class="keyword">if</span> cur.item==item:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">           cur=cur.next</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>由上面可以总结出几种操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cur=self.head</span><br><span class="line"><span class="comment"># cur.next 代表的是下一个node的一个整体</span></span><br><span class="line"><span class="comment"># head 代表当前的node</span></span><br><span class="line"><span class="comment"># 指针移动</span></span><br><span class="line">cur=cur.next <span class="comment"># 直接后一个的节点的地址传给了cur，这就达到了指针后移的目的。</span></span><br></pre></td></tr></table></figure><h3 id="2-双链表"><a class="markdownIt-Anchor" href="#2-双链表"></a> 2. 双链表</h3><blockquote><p>参考：<a href="https://blog.csdn.net/chenmozhe22/article/details/108772812">Python—链表基础（小白入门系列）—节点 &amp; 双向链表</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220212213658145.png&quot; alt=&quot;image-20220212213658145&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;p&gt;栈、单链表。&lt;/p&gt;
&lt;p&gt;会进修 Coursera 的 Data Structures 课程，日后完善丰富。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-05｜查漏补缺</title>
    <link href="https://blog.tangspoon.cn/2022/02/05/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-05%EF%BD%9C%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
    <id>https://blog.tangspoon.cn/2022/02/05/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-05%EF%BD%9C%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</id>
    <published>2022-02-05T10:49:26.000Z</published>
    <updated>2022-02-14T06:29:43.280Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323-20220209184953475.png" alt="image-20211208153223437" /></p><p>数据类型和变量、递归、切片、range</p><a id="more"></a><h2 id="一-基础"><a class="markdownIt-Anchor" href="#一-基础"></a> 一、基础</h2><h3 id="1-数据类型和变量"><a class="markdownIt-Anchor" href="#1-数据类型和变量"></a> 1. 数据类型和变量</h3><h4 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h4><p>对于很大的数，可以用100_000_000表示</p><h4 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h4><p>会出现四舍五入的情况</p><h4 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h4><ul><li><p>转义字符：\ +需要转的字符。例如我要在’ '里输出&quot;&quot;，\&quot;即可</p></li><li><p><strong>r’ '内部的不会被转义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;111&#x27;</span><span class="string">r&#x27;\t&#x27;</span><span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line"><span class="comment"># 111\t1111</span></span><br></pre></td></tr></table></figure></li><li><p>多行输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;&#x27;&#x27;第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行</span></span><br><span class="line">第二行</span><br><span class="line">第三行</span><br></pre></td></tr></table></figure><h4 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h4><p>变量在内存中的表示</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220208141522481.png" alt="image-20220208141522481" /></p><p><img src="https://picbed.tangspoon.cn/uPic/image-20220208141533655.png" alt="image-20220208141533655" /></p></li></ul><h3 id="2-编码"><a class="markdownIt-Anchor" href="#2-编码"></a> 2. 编码</h3><p>ASCII是美国一开始设计计算机制定的，用不了其他语言。Unicode可以解决所有语言的编码问题，但是长度是固定的。UTF-8是可变的，可以节省许多空间。</p><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就要转化为UTF-8编码。所以在当你打开一个txt文件时，计算机会把UTF-8的文件转换为Unicode的，然后交给内存处理，当编辑完成后，再转换为UTF-8保存到硬盘。</p><h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4><h5 id="s"><a class="markdownIt-Anchor" href="#s"></a> %s</h5><p>最方便的格式化方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;name:%s,age:%s&#x27;</span> %(<span class="string">&#x27;tang&#x27;</span>,<span class="number">25</span>))</span><br></pre></td></tr></table></figure><p>在python中，当<code>%</code>是个普通字符时，需要加多一个%来显示。例如我需要输出<code>7%</code>时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;%s%%&#x27;</span> %<span class="number">7</span>)</span><br></pre></td></tr></table></figure><h5 id="f-string"><a class="markdownIt-Anchor" href="#f-string"></a> f-string</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f&#x27;&#123;变量&#125;&#x27;</span></span><br><span class="line">r=<span class="number">3</span></span><br><span class="line">s=<span class="number">22</span>*r</span><br><span class="line">print(<span class="string">f&#x27;r is:<span class="subst">&#123;r&#125;</span>,s is:<span class="subst">&#123;s&#125;</span>)</span></span><br></pre></td></tr></table></figure><p>#####保留小数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.1f 一位</span><br><span class="line">.2f 两位</span><br></pre></td></tr></table></figure><h3 id="3-list和tuple"><a class="markdownIt-Anchor" href="#3-list和tuple"></a> 3. list和tuple</h3><h4 id="list的增删改"><a class="markdownIt-Anchor" href="#list的增删改"></a> list的增删改</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加</span></span><br><span class="line">list.append()</span><br><span class="line">list.insert(i,string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">list.pop() <span class="comment">#删除最后一个</span></span><br><span class="line">list.pop(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">list[i]=string</span><br></pre></td></tr></table></figure><h4 id="tuple的特性"><a class="markdownIt-Anchor" href="#tuple的特性"></a> tuple的特性</h4><ul><li>不能更改</li><li>优点：安全。能用tuple即用tuple</li></ul><p>不过注意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t=(<span class="number">1</span>) <span class="comment">#代表的是整数1，不是tuple只有1这个元素</span></span><br><span class="line"><span class="comment">#正确表示应该是在后面加个逗号</span></span><br><span class="line">t=(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p>可变的tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t&#x3D;(1,2,[&#39;a&#39;,&#39;b&#39;])</span><br><span class="line">t[2][0]&#x3D;&#39;A&#39;</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure><h4 id="dict和set"><a class="markdownIt-Anchor" href="#dict和set"></a> dict和set</h4><p>具体在《草根学python》复习中查看。</p><h3 id="4运算符"><a class="markdownIt-Anchor" href="#4运算符"></a> 4.运算符</h3><h4 id="身份运算符-is-is-not"><a class="markdownIt-Anchor" href="#身份运算符-is-is-not"></a> 身份运算符 is 、is not</h4><p>判断两个表示符是不是引用自同一个对象，就像<code>id(x)==id(y)</code>一个道理。</p><p>而<code>==</code>则是判断两个<code>值</code>是否相等。</p><h2 id="二-函数-递归"><a class="markdownIt-Anchor" href="#二-函数-递归"></a> 二、函数-递归</h2><p>递归知识重复执行操作的方法。只需要理解到最小规模的逻辑，设计出等价关系式即可。</p><p>递归的特征：自己调用自己，有一定的结束条件，效率不高</p><p>斐波函数</p><blockquote><p>1,1,2,3,5,8,13</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非递归方法（普通循环）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">        temp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = temp</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"><span class="comment"># 核心思想就是把a,b从第一位开始，整体向后移一位。a=b，b=temp就可以实现整体向后移的目的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="comment">## 结束条件</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib2(n<span class="number">-2</span>)+fib2(n<span class="number">-1</span>) <span class="comment">## 等价关系式</span></span><br><span class="line">     </span><br></pre></td></tr></table></figure><p>可以看到两种算法的思想是不一样的。非递归方法需要抽象出一定的规律，根据这个规律来设计算法。比如上面的a,b整体向后移，根据这个规律来设计出用一个temp来储存后面b需要的数据。而递归的思想是指设计出口和缩小规模的逻辑，具体后面怎么实现不管。比如上面我们只需要想清楚是前一个数+后一个数即可，那么我们就可以直接设计出<code>fib(n-1)+fib(n-2)</code>这种超级简约的算法。</p><p>关于递归的最好理解是来自知乎的一篇文章：<a href="https://www.zhihu.com/question/31412436">对于递归有没有什么好的理解方法？</a></p><blockquote><h3 id="递归的三大要素"><a class="markdownIt-Anchor" href="#递归的三大要素"></a> 递归的三大要素</h3><p><strong>第一要素：明确你这个函数想要干什么</strong></p><p><strong>第二要素：寻找递归结束条件</strong></p><p>当n=1或者n=2时的一些特殊情况</p><p><strong>第三要素：找出函数的等价关系式</strong>(最难)</p><p>求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少</p></blockquote><h2 id="三-高级特性"><a class="markdownIt-Anchor" href="#三-高级特性"></a> 三、高级特性</h2><h3 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h3><p>应用于<code>list</code>和<code>tuple</code>取部分元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list&#x3D;[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>取前面三个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[0,3]</span><br></pre></td></tr></table></figure><p>取倒数第一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[-1]</span><br></pre></td></tr></table></figure><p>取倒数两个（就是从<code>-2</code>一直到最后）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[-2:]</span><br></pre></td></tr></table></figure><p>前十个，每两个取一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[:<span class="number">10</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>所有数，每5个取一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(l[::5])</span><br></pre></td></tr></table></figure><h2 id="四-range"><a class="markdownIt-Anchor" href="#四-range"></a> 四、range()</h2><p>range(start,stop,step)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(100,0,-1) # 从100倒数回0，每次步进1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323-20220209184953475.png&quot; alt=&quot;image-20211208153223437&quot; /&gt;&lt;/p&gt;
&lt;p&gt;数据类型和变量、递归、切片、range&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>The following packages have unmet dependencies: Depends: xxx but is to be installed</title>
    <link href="https://blog.tangspoon.cn/2022/01/26/The-following-packages-have-unmet-dependencies-Depends-xxx-but-is-to-be-installed/"/>
    <id>https://blog.tangspoon.cn/2022/01/26/The-following-packages-have-unmet-dependencies-Depends-xxx-but-is-to-be-installed/</id>
    <published>2022-01-26T06:47:20.000Z</published>
    <updated>2022-02-09T06:16:58.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20220126144850057.png" alt="image-20220126144850057" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> libxml2-dev : Depends: libxml2 (&#x3D; 2.9.3+dfsg1-1ubuntu0.7) but 2.9.4+dfsg1-7+deb10u2 is to be installed</span><br><span class="line">E: Unable to correct problems, you have held broken packages.</span><br></pre></td></tr></table></figure><p>今天在安装shairplay的时候出现了以上问题</p><p>原因是以来版本不一样</p><p>解决方法很简单——卸载、重装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt remove libxml2-dev</span><br><span class="line">apt install libxml2-dev</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220126144850057.png&quot; alt=&quot;image-20220126144850057&quot; /&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight pla</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
    <category term="troubleshooting" scheme="https://blog.tangspoon.cn/tags/troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>linux使用supervisor实现开机自启</title>
    <link href="https://blog.tangspoon.cn/2022/01/04/linux%E4%BD%BF%E7%94%A8supervisor%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/"/>
    <id>https://blog.tangspoon.cn/2022/01/04/linux%E4%BD%BF%E7%94%A8supervisor%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/</id>
    <published>2022-01-04T06:39:02.000Z</published>
    <updated>2022-02-09T06:31:47.927Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20220104144501685.png" alt="image-20220104144501685" style="zoom:30%;" /><p>智能快递柜项目需要flask和内网穿透实现开机自启，使用supervisor非常方便。</p><a id="more"></a><p>相关Introduce在<a href="http://supervisord.org/introduction.html#overview">官网</a>有，这里只记录在<strong>香橙派</strong>armbian环境下的使用方法。</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><h3 id="查看项目安装位置"><a class="markdownIt-Anchor" href="#查看项目安装位置"></a> 查看项目安装位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis supervisor</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20220104145552053.png" alt="image-20220104145552053" /></p><h3 id="配置conf"><a class="markdownIt-Anchor" href="#配置conf"></a> 配置conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;supervisor</span><br><span class="line"># 新建log方便下面使用</span><br><span class="line">touch supervisor.log</span><br><span class="line">vim supervisor.conf</span><br></pre></td></tr></table></figure><p>在文件最后添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[program:xxx]</span><br><span class="line">command&#x3D;xxxxxxx                                                  </span><br><span class="line">autostart&#x3D;true                                                                        </span><br><span class="line">autorestart&#x3D;true                                                             </span><br><span class="line">stdout_logfile &#x3D; &#x2F;etc&#x2F;supervisor&#x2F;supervisor.log</span><br><span class="line">startsecs &#x3D; 5</span><br><span class="line">stopwaitsecs&#x3D;0</span><br></pre></td></tr></table></figure><p><code>line1</code>: 填写项目名称（例如我的是express_system）</p><p><code>line2</code>：执行脚本的命令（例如我的是python /root/express_system/app.py）</p><p><code>autostart</code>：在 supervisord 启动的时候也自动启动</p><p><code>autorestart</code>：程序异常退出后自动重启</p><p><code>startsecs</code>：启动 5 秒后没有异常退出，就当作已经正常启动了</p><p><code>stopwaitsecs</code>：停止等待时间</p><h3 id="重启"><a class="markdownIt-Anchor" href="#重启"></a> 重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><h2 id="supervisor其他命令"><a class="markdownIt-Anchor" href="#supervisor其他命令"></a> supervisor其他命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 输入查看自启程序的状态</span><br><span class="line">supervisorctl</span><br><span class="line"></span><br><span class="line">#关闭所有任务</span><br><span class="line">supervisorctl shutdown</span><br><span class="line"></span><br><span class="line"># 启动某个进</span><br><span class="line">supervisorctl start programxxx</span><br><span class="line"></span><br><span class="line"># 重启某个进程</span><br><span class="line">supervisorctl restart programxxx</span><br><span class="line"></span><br><span class="line"># 停止全部进程 注：start、restart、stop都不会载入最新的配置文件</span><br><span class="line">supervisorctl stop all</span><br><span class="line"></span><br><span class="line"># 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。</span><br><span class="line">supervisorctl reload</span><br><span class="line"></span><br><span class="line"># 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。</span><br><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20220104144501685.png&quot; alt=&quot;image-20220104144501685&quot; style=&quot;zoom:30%;&quot; /&gt;
&lt;p&gt;智能快递柜项目需要flask和内网穿透实现开机自启，使用supervisor非常方便。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    <category term="智能快递柜" scheme="https://blog.tangspoon.cn/categories/linux/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
    <category term="supervisor" scheme="https://blog.tangspoon.cn/tags/supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Flask-学习笔记02-模版与表单</title>
    <link href="https://blog.tangspoon.cn/2021/12/27/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E6%A8%A1%E7%89%88%E4%B8%8E%E8%A1%A8%E5%8D%95/"/>
    <id>https://blog.tangspoon.cn/2021/12/27/Flask-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E6%A8%A1%E7%89%88%E4%B8%8E%E8%A1%A8%E5%8D%95/</id>
    <published>2021-12-27T09:22:41.000Z</published>
    <updated>2022-02-09T06:32:33.164Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20201226170026026.png" alt="image-20201226170026026" style="zoom:50%;" /><p>应用于智能快递柜的密码校验web</p><a id="more"></a><p>最简单的flask项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><h2 id="一-模版"><a class="markdownIt-Anchor" href="#一-模版"></a> 一、模版</h2><p>在flask项目内新建一个<code>templates</code>文件夹放置html，新建static文件夹放置css。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211227172852877.png" alt="image-20211227172852877" style="zoom:50%;" /><h3 id="1-html"><a class="markdownIt-Anchor" href="#1-html"></a> 1. html</h3><p>在视图函数<code>return</code>就行，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;xxx.html&#x27;</span>,params)</span><br><span class="line"><span class="comment"># params为传递给html页面的参数</span></span><br></pre></td></tr></table></figure><h3 id="2-css"><a class="markdownIt-Anchor" href="#2-css"></a> 2. css</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在html <span class="tag">&lt;<span class="name">head</span>&gt;</span>内添加：</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-参数"><a class="markdownIt-Anchor" href="#3-参数"></a> 3. 参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,name=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>,port=<span class="number">8443</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二-表单"><a class="markdownIt-Anchor" href="#二-表单"></a> 二、表单</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>智能快递柜<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;static&#x27;,filename=&#x27;style.css&#x27;) &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">action</span>=<span class="string">&quot;result&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>请联系收件人<span class="tag">&lt;<span class="name">br</span>&gt;</span>获取密码<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;确认&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关注body内部：</p><p><code>action</code>：post请求重定向到<code>result路由</code></p><p><code>input name</code>：input的name一定要写，用于app.py获取input里的值。</p><p><code>form action</code>：处理form数据的路由页面（视图函数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method==<span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;result&#x27;</span>),password=password)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(&#x27;/result&#x27;,methods=&#x27;GET&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span>():</span></span><br><span class="line">    pwd=<span class="string">&#x27;123&#x27;</span></span><br><span class="line">    password=request.args.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> password==pwd:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;correct.html&#x27;</span>,password=password)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;error.html&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其实整个流程很好理解：首先路由<code>'/'</code>首先渲染index.html，然后得先获取input里面的值，也就是<code>request.form[]</code>。当我们submit之后，<code>POST请求</code>得把我们获取到<code>input的值</code> <code>return</code>到新的路由<code>result</code>页面中，这就是<code>redirect(url_for(),args)</code>的作用。然后新的路由页面，得接收POST过来的信息，所以method是<code>GET</code>，获取信息的方法是<code>request.args.get['args']</code>。所以我们在html里的form的action中，必须得明确我们要把信息提交到那个路由<code>/result</code></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20201226170026026.png&quot; alt=&quot;image-20201226170026026&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;p&gt;应用于智能快递柜的密码校验web&lt;/p&gt;</summary>
    
    
    
    <category term="智能快递柜" scheme="https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/"/>
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/%E6%99%BA%E8%83%BD%E5%BF%AB%E9%80%92%E6%9F%9C/Python/"/>
    
    
    <category term="Flask" scheme="https://blog.tangspoon.cn/tags/Flask/"/>
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解决｜UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe8 in position 0: ordinal not in range(128)</title>
    <link href="https://blog.tangspoon.cn/2021/12/18/%E8%A7%A3%E5%86%B3%EF%BD%9CUnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-0-ordinal-not-in-range-128/"/>
    <id>https://blog.tangspoon.cn/2021/12/18/%E8%A7%A3%E5%86%B3%EF%BD%9CUnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-0-ordinal-not-in-range-128/</id>
    <published>2021-12-18T04:31:04.000Z</published>
    <updated>2022-02-09T06:17:55.388Z</updated>
    
    <content type="html"><![CDATA[<p>换成python3即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除&#x2F;usr&#x2F;bin目录下的python link文件</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line"># 删除后再建立新的链接关系：</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;换成python3即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
    <category term="troubleshooting" scheme="https://blog.tangspoon.cn/tags/troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>Debian开启crontab日志</title>
    <link href="https://blog.tangspoon.cn/2021/12/18/Debian%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/"/>
    <id>https://blog.tangspoon.cn/2021/12/18/Debian%E5%BC%80%E5%90%AFcrontab%E6%97%A5%E5%BF%97/</id>
    <published>2021-12-18T03:37:39.000Z</published>
    <updated>2021-12-24T13:46:01.494Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211218114909331.png" alt="image-20211218114909331" style="zoom: 43%;" /><p>搭建网易云闹钟需要查看crontab的运行情况，在此记录下如何实时监控log</p><a id="more"></a><p>实时查看crontab的log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure><p>但debian是默认不开启的，我们需要手动开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;rsyslog.conf </span><br></pre></td></tr></table></figure><p>找到👇，然后把<code>#</code>去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#cron.* &#x2F;var&#x2F;log&#x2F;cron.log</span><br></pre></td></tr></table></figure><p>重启日志服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;rsyslog restart</span><br></pre></td></tr></table></figure><p>重启crontab服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;crond restart</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211218114909331.png&quot; alt=&quot;image-20211218114909331&quot; style=&quot;zoom: 43%;&quot; /&gt;
&lt;p&gt;搭建网易云闹钟需要查看crontab的运行情况，在此记录下如何实时监控log&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>N1盒子部署我的网易云闹钟折腾记</title>
    <link href="https://blog.tangspoon.cn/2021/12/18/N1%E7%9B%92%E5%AD%90%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%BD%91%E6%98%93%E4%BA%91%E9%97%B9%E9%92%9F%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://blog.tangspoon.cn/2021/12/18/N1%E7%9B%92%E5%AD%90%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%BD%91%E6%98%93%E4%BA%91%E9%97%B9%E9%92%9F%E6%8A%98%E8%85%BE%E8%AE%B0/</id>
    <published>2021-12-18T01:50:32.000Z</published>
    <updated>2021-12-24T13:46:19.609Z</updated>
    
    <content type="html"><![CDATA[<p>前面N1盒子刷armbian的目的之一就是为了更好的安装我的网易云闹钟，早上更好的叫醒我。</p><p>但一路可谓是遇到了非常多坑。</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122647253.png" alt="image-20211218122647253" /></p><img src="https://picbed.tangspoon.cn/uPic/image-20211218121833554.png" alt="image-20211218121833554" style="zoom:43%;" /><a id="more"></a><h2 id="一-背景介绍"><a class="markdownIt-Anchor" href="#一-背景介绍"></a> 一、背景介绍</h2><p>一开始我刷了带桌面的ubuntu，把我坑得不要不要的！在桌面版终端命令执行python脚本或者鼠标点击mp4文件都有声音出来，但是一旦ssh或者在crontab中执行python脚本就没有声音！！！前前后后折腾了一个晚上毫无结果。</p><p>分析大概是桌面端的问题，也有可能是armbian和N1盒子不那么适配。所以还是换成了没有桌面端的debian。</p><h2 id="二-系统配置"><a class="markdownIt-Anchor" href="#二-系统配置"></a> 二、系统配置</h2><h3 id="1-更新apt"><a class="markdownIt-Anchor" href="#1-更新apt"></a> 1. 更新apt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="2-换python3"><a class="markdownIt-Anchor" href="#2-换python3"></a> 2. 换python3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除&#x2F;usr&#x2F;bin目录下的python link文件</span><br><span class="line">sudo rm -rf &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line"># 删除后再建立新的链接关系：</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3.5 &#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure><h3 id="3-安装pip3"><a class="markdownIt-Anchor" href="#3-安装pip3"></a> 3. 安装pip3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python3-pip</span><br></pre></td></tr></table></figure><h3 id="4-baidu-aip"><a class="markdownIt-Anchor" href="#4-baidu-aip"></a> 4. baidu-aip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install baidu-aip</span><br></pre></td></tr></table></figure><h3 id="5-mpg123或mplayer"><a class="markdownIt-Anchor" href="#5-mpg123或mplayer"></a> 5. mpg123或mplayer</h3><p>在树莓派上我是用mplayer的，但在N1盒子上使用mplayer播放音乐一卡一卡的。结果换成了mpg123就没问题了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mpg123</span><br><span class="line">apt-get install mpg123</span><br><span class="line"></span><br><span class="line"># mplayer</span><br><span class="line">apt-get install mplayer</span><br></pre></td></tr></table></figure><h2 id="三-配置声卡"><a class="markdownIt-Anchor" href="#三-配置声卡"></a> 三、配置声卡</h2><p>在pdd买了一个免驱的usb网卡，可以直接接3.5mm的音频。但使用mpg123播放音乐没有声音。根据前面树莓派的经验，应该是网卡配置有问题。因为armbian默认是card0的声卡，可能是一开始插了HDMI默认了是card0。我们要做的就是修改我们的usb设备为默认声卡就行。</p><h3 id="1-查看所有声卡信息"><a class="markdownIt-Anchor" href="#1-查看所有声卡信息"></a> 1. 查看所有声卡信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aplay -l </span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122844083.png" alt="image-20211218122844083" /></p><p>我们需要usb声卡的 card 数字<code>1</code> 和 device数字<code>0</code></p><h3 id="2-修改默认声卡文件"><a class="markdownIt-Anchor" href="#2-修改默认声卡文件"></a> 2. 修改默认声卡文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;asound.conf</span><br></pre></td></tr></table></figure><p>默认是没有asound.conf文件的，不要紧，直接新建添加就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defaults.pcm.card 1  </span><br><span class="line">defaults.pcm.device 0 </span><br><span class="line">defaults.ctl.card 1</span><br></pre></td></tr></table></figure><h3 id="3-测试声卡"><a class="markdownIt-Anchor" href="#3-测试声卡"></a> 3. 测试声卡</h3><p>upload一段mp3文件，然后使用mpg123播放查看有没有声音。如果没有，就reboot一下。大概率是OK的。</p><h2 id="四-部署网易云闹钟项目"><a class="markdownIt-Anchor" href="#四-部署网易云闹钟项目"></a> 四、部署网易云闹钟项目</h2><p>前面工具和相关依赖环境已经配置好了。直接git clone项目，然后修改相关配置就行。</p><p>详细请看GitHub项目：<a href="https://github.com/tangspoon66/NeteaseCloud-Clock#%E4%BA%94%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA">开始搭建</a></p><h2 id="五-相关文章"><a class="markdownIt-Anchor" href="#五-相关文章"></a> 五、相关文章</h2><p><a href="https://blog.csdn.net/hunanchenxingyu/article/details/48399585">alsa设置默认声卡</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面N1盒子刷armbian的目的之一就是为了更好的安装我的网易云闹钟，早上更好的叫醒我。&lt;/p&gt;
&lt;p&gt;但一路可谓是遇到了非常多坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211218122647253.png&quot; alt=&quot;image-20211218122647253&quot; /&gt;&lt;/p&gt;
&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211218121833554.png&quot; alt=&quot;image-20211218121833554&quot; style=&quot;zoom:43%;&quot; /&gt;</summary>
    
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/categories/linux/"/>
    
    
    <category term="linux" scheme="https://blog.tangspoon.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>N1盒子折腾记</title>
    <link href="https://blog.tangspoon.cn/2021/12/18/N1%E7%9B%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>https://blog.tangspoon.cn/2021/12/18/N1%E7%9B%92%E5%AD%90%E6%8A%98%E8%85%BE%E8%AE%B0/</id>
    <published>2021-12-18T00:42:36.000Z</published>
    <updated>2021-12-24T13:46:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间看到树莓派涨价太厉害，然后感觉我的树莓派3b+好像吃灰了一段时间，还有性能实在太过剩。之前有留意到斐讯的N1盒子性能也很强，也可以刷armbian，其实是可以用来替代树莓派的。在pdd 110💰入手了一台，包电源。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211218121833554.png" alt="image-20211218121833554" style="zoom:33%;" /><a id="more"></a><h2 id="一-刷机armbian"><a class="markdownIt-Anchor" href="#一-刷机armbian"></a> 一、刷机armbian</h2><p>在pdd手上拿回来的是<code>openwrt</code>，但我还是喜欢armbian多一点，因为可自定义程度可以非常高。所以本教程是在openwrt的基础上刷armbian。刷其他系统大同小异，都是先制作好系统U盘👉插入N1盒子👉开机👉执行sh脚本或者nand-sata-install写入emmc。</p><h3 id="1-前期准备"><a class="markdownIt-Anchor" href="#1-前期准备"></a> 1. 前期准备</h3><h4 id="11-物料"><a class="markdownIt-Anchor" href="#11-物料"></a> 1.1 物料</h4><p>HDMI线、16g U盘（不需要usb公对公）</p><h4 id="12-系统-577-debian"><a class="markdownIt-Anchor" href="#12-系统-577-debian"></a> 1.2 系统 5.77 Debian</h4><p><a href="https://pan.baidu.com/s/1kivlyMxyiZfGG3YTMI4NMw">https://pan.baidu.com/s/1kivlyMxyiZfGG3YTMI4NMw</a></p><p>提取码: e3cm</p><p><strong>强烈不建议选择Ubuntu的桌面版！强烈不建议选择Ubuntu的桌面版！因为到后面的python脚本和crontab会有问题。用 5.77 Debian 命令版5分钟就刷完，后期安装任何工具和依赖都非常快速。反倒Ubuntu桌面版有一大堆的问题。</strong></p><h4 id="13-其他工具下载"><a class="markdownIt-Anchor" href="#13-其他工具下载"></a> 1.3 其他工具下载</h4><p>U盘系统制作工具：<a href="https://www.balena.io/etcher/">balenaEtcher</a></p><p>dbt文件：在5.77 Debian下载链接里面有</p><h3 id="2-制作系统u盘"><a class="markdownIt-Anchor" href="#2-制作系统u盘"></a> 2. 制作系统U盘</h3><h4 id="21-烧录"><a class="markdownIt-Anchor" href="#21-烧录"></a> 2.1 烧录</h4><p>这一步直接使用balenaEtcher烧录就行，非常简单。</p><h4 id="22-拷贝dbt文件"><a class="markdownIt-Anchor" href="#22-拷贝dbt文件"></a> 2.2 拷贝dbt文件</h4><p>在烧录后的U盘里面，有个dbt文件夹。把下载下来的dbt文件👉复制到U盘的dbt文件夹内</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122227863.png" alt="image-20211218122227863" /></p><h4 id="23-修改uenv文件"><a class="markdownIt-Anchor" href="#23-修改uenv文件"></a> 2.3 修改uEnv文件</h4><p>在U盘系统目录里，有个uEnv.ini文件，把data_name=xxx修改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtb_name&#x3D;&#x2F;dtb&#x2F;meson-gxl-s905d-phicomm-n1-xiangsm.dtb</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20211218122320412.png" alt="image-20211218122320412" /></p><p><strong>至此，启动U盘制作完成。</strong></p><h2 id="二-写入emmc"><a class="markdownIt-Anchor" href="#二-写入emmc"></a> 二、写入emmc</h2><p>插入U盘就会自动加载，debian默认是root，密码1234。后面会要你更改。</p><p>然后执行下面命令就可以写入emmc了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nand-sata-install</span><br></pre></td></tr></table></figure><p>网上有的教程说执行/root/install.sh可以，但还是建议以我上面的方式写入。</p><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="三-其他配置"><a class="markdownIt-Anchor" href="#三-其他配置"></a> 三、其他配置</h2><p>Wi-Fi、时区、apt源等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">armbian-config</span><br></pre></td></tr></table></figure><p>到这里，N1盒子的armbian系统基本配置好啦～</p><h2 id="四-相关文章"><a class="markdownIt-Anchor" href="#四-相关文章"></a> 四、相关文章</h2><p><a href="https://yuerblog.cc/2019/10/23/%E6%96%90%E8%AE%AFn1-%E5%AE%8C%E7%BE%8E%E5%88%B7%E6%9C%BAarmbian%E6%95%99%E7%A8%8B/">斐讯N1 – 完美刷机Armbian教程</a>(建议阅读)</p><p><a href="https://www.twoeggz.com/info/745423.html">秒变万能家庭服务器！斐讯N1 armbian安装指南</a></p><p><a href="https://www.right.com.cn/forum/forum.php?mod=forumdisplay&amp;fid=158&amp;filter=typeid&amp;typeid=21">N1盒子Armbian-5.77 on N1, so far so good</a></p><p><a href="https://wh0.is/p/%E6%96%90%E8%AE%AFn1%E8%A3%85ubuntuarmbian-%E5%B0%B4%E5%B0%AC%E5%A4%8D%E6%B4%BB%E8%AE%B0%E5%BD%95/">斐讯N1装Ubuntu(Armbian)+尴尬复活记录</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这段时间看到树莓派涨价太厉害，然后感觉我的树莓派3b+好像吃灰了一段时间，还有性能实在太过剩。之前有留意到斐讯的N1盒子性能也很强，也可以刷armbian，其实是可以用来替代树莓派的。在pdd 110💰入手了一台，包电源。&lt;/p&gt;
&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211218121833554.png&quot; alt=&quot;image-20211218121833554&quot; style=&quot;zoom:33%;&quot; /&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://blog.tangspoon.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="硬件" scheme="https://blog.tangspoon.cn/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-03｜复习</title>
    <link href="https://blog.tangspoon.cn/2021/12/17/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-03%EF%BD%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.tangspoon.cn/2021/12/17/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-03%EF%BD%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-12-17T12:49:22.000Z</published>
    <updated>2021-12-28T13:06:55.260Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p><p>第三天：迭代、迭代器、list生成式</p><a id="more"></a><p><code>2021-12-18</code></p><h2 id="一-迭代"><a class="markdownIt-Anchor" href="#一-迭代"></a> 一、迭代</h2><p>python中<code>访问集合元素</code>的方式之一。说白了就是循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># 遍历 dict 的key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dict1.keys():</span><br><span class="line">    print(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 遍历 dict 的values</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dict1.values():</span><br><span class="line">    print(values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 字符串 集合里的元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二-迭代器"><a class="markdownIt-Anchor" href="#二-迭代器"></a> 二、迭代器</h2><h3 id="1-iter"><a class="markdownIt-Anchor" href="#1-iter"></a> 1. <code>iter()</code></h3><p>Python 的 <code>for</code> 循环就是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line">print(it)</span><br></pre></td></tr></table></figure><img src="https://picbed.tangspoon.cn/uPic/image-20211218164251631.png" alt="image-20211218164251631" style="zoom:50%;" /><p>可以看到并不是直接通过<code>iter()</code>就可以迭代的。还是要通过for或者while打印出list1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>iter()只是获得了一个迭代对象，还需要通过循环遍历。</p><h3 id="2-next"><a class="markdownIt-Anchor" href="#2-next"></a> 2. <code>next()</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line">print(next(it))</span><br></pre></td></tr></table></figure><img src="https://picbed.tangspoon.cn/uPic/image-20211218165518356.png" alt="image-20211218165518356" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it=iter(list1)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">    <span class="keyword">try</span> :</span><br><span class="line">        <span class="keyword">print</span> ( next ( iter3 ) )</span><br><span class="line">    <span class="keyword">except</span> StopIteration :</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># for i in (0,len(list1)):</span></span><br><span class="line"><span class="comment">#print(next(it))</span></span><br></pre></td></tr></table></figure><h2 id="三-list生成式"><a class="markdownIt-Anchor" href="#三-list生成式"></a> 三、list生成式</h2><p>只是一种更简洁的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[expression <span class="keyword">for</span> iterable_var <span class="keyword">in</span> iterable]</span><br><span class="line">[expression <span class="keyword">for</span> iterable_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expression]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1=[(x,y) <span class="keyword">for</span> x <span class="keyword">in</span> rang(<span class="number">5</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure><p>注意：<code>y</code>是嵌套在<code>x</code>里面的for循环</p><h2 id="四-生成器generator"><a class="markdownIt-Anchor" href="#四-生成器generator"></a> 四、生成器generator</h2><p><strong>一边循环一遍计算，不必创建完整的<code>list</code>。</strong></p><p>以<code>()</code>的生成式/有<code>yield</code>存在就叫生成器。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （）</span></span><br><span class="line">gen = (x*x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数形式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>()</span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="title">i</span> <span class="title">in</span> <span class="title">range</span>(<span class="params"><span class="number">5</span></span>):</span></span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line">print(test())</span><br><span class="line"><span class="comment"># 结果：&lt;generator object test at 0x105603660&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-为什么需要生成器"><a class="markdownIt-Anchor" href="#1-为什么需要生成器"></a> 1. 为什么需要生成器</h3><p>（1）生成一个非常大的<code>list</code>非常耗费储存空间</p><p>（2）如果我们只需要列表的前面一些值，就需要生成整个列表，后面部分的空间就被浪费了。</p><p>生成器表达式使用了一种叫lazy evaluation（惰性计算）的计算方法，调用方式是<code>call by need</code>。<strong>只有在被检索时才会被赋值</strong>。因此在列表比较长时使用内存会有效。</p><h3 id="2-遍历生成器的元素"><a class="markdownIt-Anchor" href="#2-遍历生成器的元素"></a> 2. 遍历生成器的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen=(x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><h3 id="3-以函数的形式实现生成器"><a class="markdownIt-Anchor" href="#3-以函数的形式实现生成器"></a> 3. 以函数的形式实现生成器</h3><p>在实际运用中，大多数的generator都是通过函数来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="keyword">yield</span> i </span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure><p>但上面的例子非常不适合使用generator，因为generator最好的应用是——不想同一时间 将大量的结果 都分配到内存里。特别是结果集里还包含循环。</p><p>另外注意：在用函数生成的生成器中，执行过程是——遇到<code>yield</code>就中断，返回值。所以在一个函数中有多个<code>yield</code>时，无论多少次调用这个函数，每调用一次<code>yield</code>，这个<code>yield</code>就被抛弃掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">print(<span class="string">&#x27;step 1&#x27;</span>)</span><br><span class="line"><span class="keyword">yield</span>(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">&#x27;step 2&#x27;</span>)</span><br><span class="line"><span class="keyword">yield</span>(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">&#x27;step 3&#x27;</span>)</span><br><span class="line"><span class="keyword">yield</span>(<span class="number">3</span>)</span><br><span class="line">t=test()</span><br><span class="line">print(next(t))</span><br><span class="line">print(next(t))</span><br><span class="line">print(next(t))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">step 1</span><br><span class="line">1</span><br><span class="line">step 2</span><br><span class="line">2</span><br><span class="line">step 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png&quot; alt=&quot;image-20211208153223437&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第三天：迭代、迭代器、list生成式&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-02｜复习</title>
    <link href="https://blog.tangspoon.cn/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-02%EF%BD%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.tangspoon.cn/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-02%EF%BD%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-12-08T07:38:27.000Z</published>
    <updated>2021-12-17T12:41:02.559Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png" alt="image-20211208153223437" /></p><p>第二天：函数的参数、传值、匿名函数</p><a id="more"></a><p><code>2021-12-17</code></p><p>01和这个02相隔有点久，这段时间在搞从老妈子从垃圾桶旁捡回来的主机，150块把它整复活了～然后把树莓派卖了，换了一台斐讯的N1盒子继续挂网易云闹钟。</p><h2 id="一-函数参数"><a class="markdownIt-Anchor" href="#一-函数参数"></a> 一、函数参数</h2><p>python的函数可以有多个返回值，实际上是先创建了一个元组然后再返回的。</p><h3 id="1-默认参数"><a class="markdownIt-Anchor" href="#1-默认参数"></a> 1. 默认参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b是默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h4 id="1要在末尾"><a class="markdownIt-Anchor" href="#1要在末尾"></a> （1）要在末尾</h4><h4 id="2不能使用list这种形式做默认参数默认值必须为不可更改的整数-字符串-true-false-none等"><a class="markdownIt-Anchor" href="#2不能使用list这种形式做默认参数默认值必须为不可更改的整数-字符串-true-false-none等"></a> （2）不能使用<code>list=[]</code>这种形式做默认参数，默认值必须为不可更改的：整数、字符串、True、False、None等。</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,b=None</span>)</span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">b</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># <span class="title">def</span> <span class="title">test</span>(<span class="params">a,b=[]</span>) 不会报错，但一旦对<span class="title">b</span>修改，返回结果会出错</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-位置参数关键字参数"><a class="markdownIt-Anchor" href="#2-位置参数关键字参数"></a> 2. 位置参数（关键字参数）</h3><p>python中可以根据<strong>参数名</strong>传参，所以不顺序传参也行（但最好顺序）。</p><h3 id="3-不定长参数可变参数"><a class="markdownIt-Anchor" href="#3-不定长参数可变参数"></a> 3. 不定长参数（可变参数）</h3><p>有时候在设计函数时，我们无法确定传入参数的多少，这时候就可以用<code>tuple元组</code>或<code>dist字典</code>来描述那些没有被定义的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a=<span class="number">1</span>,*b</span>):</span></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">re=test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(re) <span class="comment">#结果：(2,3,4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dist</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a=<span class="number">1</span>,**b</span>):</span></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">re=test(<span class="number">1</span>,b=(,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">print(re) <span class="comment">#结果：&#123;&#x27;b&#x27;:(2,3,4,5)&#125;</span></span><br></pre></td></tr></table></figure><p><code>*b</code>返回结果是元组</p><p><code>**b</code>其实是不定长参数里的关键字参数，是通过关键字<code>b</code>确定的。</p><h3 id="4-强制使用关键字参数"><a class="markdownIt-Anchor" href="#4-强制使用关键字参数"></a> 4. 强制使用关键字参数</h3><p>把需要强制使用keyword的参数放在<code>*</code>后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a,*,b</span>):</span></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">re=test(<span class="number">1</span>,b=<span class="number">2</span>)</span><br><span class="line">print(re)</span><br></pre></td></tr></table></figure><img src="https://picbed.tangspoon.cn/uPic/image-20211217172829525.png" alt="image-20211217172829525" style="zoom:50%;" /><h2 id="二-传值"><a class="markdownIt-Anchor" href="#二-传值"></a> 二、传值</h2><p>除了<code>list</code>和<code>dist</code>可变之外，其他像整形、浮点型、字符串、tuple等都不可变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a</span>):</span></span><br><span class="line">print(a) <span class="comment">#a的值是不会被改变的</span></span><br><span class="line">a=<span class="number">1000</span></span><br><span class="line">print(a) <span class="comment"># 这里的a只是test()外的a的复制体，改变的也只是复制体的值</span></span><br><span class="line"></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">test(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1000</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h2 id="三-匿名函数"><a class="markdownIt-Anchor" href="#三-匿名函数"></a> 三、匿名函数</h2><p>不用def整体命名整个函数，用最简单的形式写一个回调函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="keyword">lambda</span> num1,num2:num1+num2</span><br><span class="line">print(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>基本形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1,arg2 : expression</span><br></pre></td></tr></table></figure><p>有个地方需要注意：下面的结果都是10001。因为num2是一个自由参数，是按<code>执行顺序</code>绑定值，不是定义时就绑定。</p><blockquote><p>可看python的执行顺序：<a href="https://pythontutor.com/visualize.html#mode=display">https://pythontutor.com/visualize.html#mode=display</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">num2 = <span class="number">100</span></span><br><span class="line">sum1 = <span class="keyword">lambda</span> num1 : num1 + num2 ;</span><br><span class="line"></span><br><span class="line">num2 = <span class="number">10000</span></span><br><span class="line">sum2 = <span class="keyword">lambda</span> num1 : num1 + num2 ;</span><br><span class="line"></span><br><span class="line">print( sum1( <span class="number">1</span> ) )</span><br><span class="line">print( sum2( <span class="number">1</span> ) )</span><br></pre></td></tr></table></figure><p><img src="https://picbed.tangspoon.cn/uPic/image-20211217180821420.png" alt="image-20211217180821420" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211208153223437-20211208154222323.png&quot; alt=&quot;image-20211208153223437&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第二天：函数的参数、传值、匿名函数&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习日志-01｜复习</title>
    <link href="https://blog.tangspoon.cn/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-01%EF%BD%9C%E5%A4%8D%E4%B9%A0/"/>
    <id>https://blog.tangspoon.cn/2021/12/08/Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97-01%EF%BD%9C%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-12-08T07:33:43.000Z</published>
    <updated>2022-02-09T10:39:55.047Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211208153223437.png" alt="image-20211208153223437" /></p><p>自己写了好几个python项目之后发现，好多知识都遗忘了，有些没有理解透导致执行效率不高。趁这段时间有空，重新学习一下。</p><p>list、dict、tuple、set、string</p><a id="more"></a><p><code>2021-12-07</code></p><h2 id="一-list列表"><a class="markdownIt-Anchor" href="#一-list列表"></a> 一、List列表</h2><h3 id="1-在特定位置增加元素"><a class="markdownIt-Anchor" href="#1-在特定位置增加元素"></a> 1. 在特定位置增加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.insert(index,obj)</span><br></pre></td></tr></table></figure><h3 id="2-扩展"><a class="markdownIt-Anchor" href="#2-扩展"></a> 2. 扩展</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.extend(seq)</span><br></pre></td></tr></table></figure><p>是直接改变原来的list，不是生成一个新的list。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list1.extend(list2)</span><br><span class="line">print(list1)</span><br></pre></td></tr></table></figure><h3 id="3-删除"><a class="markdownIt-Anchor" href="#3-删除"></a> 3. 删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="keyword">del</span> list[index]</span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">list.pop(index) <span class="comment"># 默认最后一个元素，并返回该元素的值</span></span><br><span class="line"><span class="comment"># 方式三</span></span><br><span class="line">list.remove(obj) <span class="comment"># 参数是列表中元素，不返回任何值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;pop:&#x27;</span>, list1.pop(<span class="number">5</span>)) <span class="comment"># 输出x</span></span><br><span class="line">print(<span class="string">&#x27;remove:&#x27;</span>, lsit1.remove(<span class="string">&#x27;a&#x27;</span>)) <span class="comment"># 输出none</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-反向"><a class="markdownIt-Anchor" href="#4-反向"></a> 4. 反向</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.reverse()</span><br></pre></td></tr></table></figure><h3 id="5-排序"><a class="markdownIt-Anchor" href="#5-排序"></a> 5. 排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list.sort(reverse=<span class="literal">False</span>,key=<span class="literal">None</span>,cmp=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># reverse=false是默认方式：升序（小到大），True为降序</span></span><br><span class="line"><span class="comment"># key指定元素进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeSecond</span>(<span class="params">elem</span>):</span></span><br><span class="line">    <span class="keyword">return</span> elem[<span class="number">1</span>]</span><br><span class="line">random = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line">random.sort(key=takeSecond)</span><br><span class="line">print(random)</span><br><span class="line"><span class="comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span></span><br></pre></td></tr></table></figure><h2 id="二-tuple元组"><a class="markdownIt-Anchor" href="#二-tuple元组"></a> 二、tuple元组</h2><h3 id="1-单个元素要加逗号"><a class="markdownIt-Anchor" href="#1-单个元素要加逗号"></a> 1. 单个元素要加逗号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple=(<span class="number">123</span>) <span class="comment"># print结果：123</span></span><br><span class="line">tuple=(<span class="number">123</span>,) <span class="comment"># print结果：(123,)</span></span><br><span class="line"><span class="comment"># 因为()既可以是括号也可以是元组，会有歧义。加个逗号就代表是元组啦</span></span><br></pre></td></tr></table></figure><h3 id="2-tuple的修改"><a class="markdownIt-Anchor" href="#2-tuple的修改"></a> 2. tuple的修改</h3><p><code>tuple是不可修改的</code>指的是每个元素的指向，永远不变。但我们可以嵌入一个数组，间接修改tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tuple=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[lsit1])</span><br><span class="line">list1=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">list1[<span class="number">0</span>]=<span class="string">&#x27;x&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;tuple：&#x27;</span>,tuple)</span><br><span class="line"><span class="comment"># print结果 tuple： (1, 2, 3, 4, [&#x27;x&#x27;, &#x27;b&#x27;])</span></span><br></pre></td></tr></table></figure><h3 id="3-读取"><a class="markdownIt-Anchor" href="#3-读取"></a> 3. 读取</h3><p>换成<code>list</code>，再读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tuple=(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">list=[]</span><br><span class="line">list=tuple</span><br><span class="line">print(list[<span class="number">0</span>]) <span class="comment"># 获取元组第一个数据</span></span><br></pre></td></tr></table></figure><h2 id="三-dict字典"><a class="markdownIt-Anchor" href="#三-dict字典"></a> 三、dict字典</h2><p>因为list列表越长，查找起来就越慢。用字典dict可以解决问题。</p><p>字典中一个键值重复出现两次，那么以最后一次的值为准。</p><p><code>键</code>不可变，可以用字符串、数字、元祖。但就是不用数组（因为数组是可修改的，这与<code>键</code>是不可修改的冲突）</p><h3 id="1-增加"><a class="markdownIt-Anchor" href="#1-增加"></a> 1. 增加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="2-修改"><a class="markdownIt-Anchor" href="#2-修改"></a> 2. 修改</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict1[<span class="string">&#x27;a&#x27;</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="3-删除-2"><a class="markdownIt-Anchor" href="#3-删除-2"></a> 3. 删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</span><br><span class="line"># 通过键，删除值</span><br><span class="line">del dict1[&#39;a&#39;]</span><br><span class="line"># 删除所有元素</span><br><span class="line">dict1.clean</span><br><span class="line"># 删除字典</span><br><span class="line">del dict1</span><br></pre></td></tr></table></figure><h3 id="4-copy-浅拷贝"><a class="markdownIt-Anchor" href="#4-copy-浅拷贝"></a> 4. copy() 浅拷贝</h3><p>dict2=dict1这种方式是一引用，简单说就是给dict1起了另一条新名字而已。输出结果与dict1保持一致。</p><p>在介绍浅拷贝前，先认识一下深拷贝会更好。深拷贝是对象的完全拷贝，拷贝后的dist2是不受dist的变化影响的。也就是说，深拷贝后的dist2是独立的。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211207192758608.png" alt="image-20211207192758608" style="zoom:32%;" /><p>而浅拷贝则不是独立的。对浅拷贝的新dist2来说，操作对象是<code>值</code>，<code>键</code>是不会随dist1变的。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211207192102217.png" alt="image-20211207192102217" style="zoom:30%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象</span></span><br><span class="line"> </span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"> </span><br><span class="line">print( <span class="string">&#x27;a = &#x27;</span>, a )</span><br><span class="line">print( <span class="string">&#x27;b = &#x27;</span>, b )</span><br><span class="line">print( <span class="string">&#x27;c = &#x27;</span>, c )</span><br><span class="line">print( <span class="string">&#x27;d = &#x27;</span>, d )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">(<span class="string">&#x27;a = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;b = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;c = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line">(<span class="string">&#x27;d = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure><p>可以看到，深拷贝的d是完全不受a的变化而影响；而浅拷贝的c则被改变了<code>值</code>。</p><h2 id="四-set"><a class="markdownIt-Anchor" href="#四-set"></a> 四、set</h2><p>set是一个无序的、不重复的元素集。就像是一个不储存<code>值value</code>，只有<code>键key</code>的字典。</p><h3 id="1-创建"><a class="markdownIt-Anchor" href="#1-创建"></a> 1. 创建</h3><p>set的创建需要用<code>set()</code>方法，然后提供一个<code>list</code>作为输入集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1=set([])</span><br></pre></td></tr></table></figure><h3 id="2-删除"><a class="markdownIt-Anchor" href="#2-删除"></a> 2. 删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1=set([<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>])</span><br><span class="line">set1.remove(<span class="number">123</span>)</span><br><span class="line">print(set1) <span class="comment"># 结果：&#123;456,789&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-应用"><a class="markdownIt-Anchor" href="#3-应用"></a> 3. 应用</h3><h4 id="1-交集"><a class="markdownIt-Anchor" href="#1-交集"></a> 1. 交集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1=set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>])</span><br><span class="line">set2=set([<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">set3=set1&amp;set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-并集"><a class="markdownIt-Anchor" href="#2-并集"></a> 2. 并集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set3=set1|set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-差集"><a class="markdownIt-Anchor" href="#3-差集"></a> 3. 差集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set3=set1-set2</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;4&#125;</span></span><br><span class="line"></span><br><span class="line">set3=set2-set1</span><br><span class="line">print(set3) <span class="comment">#结果：&#123;5,6&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4-去除海量元素"><a class="markdownIt-Anchor" href="#4-去除海量元素"></a> 4. 去除海量元素</h4><p>这部分是最有意思的。刚好当天看到了有个腾讯三面题，40亿个qq号怎么去重。我在想，用<code>set</code>会怎么样？这里就涉及到<code>set</code>的一个属性——需要提供一个<code>list</code>集合作为数据输入。把40亿的数据变成的list显然不现实。所以这可以看做是用<code>set</code>去除海量元素的限制。</p><p>但是测试了一下1000w个7位数的整数去重，只花了2.3s！这个速度还是快到惊人的！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">444</span>,<span class="number">555</span>,<span class="number">666</span>]  </span><br><span class="line">set1=set(list1)</span><br><span class="line">print(set1)</span><br></pre></td></tr></table></figure><h2 id="五-string"><a class="markdownIt-Anchor" href="#五-string"></a> 五、string</h2><h3 id="1-find"><a class="markdownIt-Anchor" href="#1-find"></a> 1. find()</h3><p>检测字符串中是否包含子字符串。可指定范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;tang&#x27;</span></span><br><span class="line">print(str.find(<span class="string">&#x27;n&#x27;</span>)) <span class="comment">##返回index位置</span></span><br><span class="line">print(str.find(<span class="string">&#x27;s&#x27;</span>)) <span class="comment">##返回-1</span></span><br></pre></td></tr></table></figure><h3 id="2-index"><a class="markdownIt-Anchor" href="#2-index"></a> 2. index()</h3><p>用于查找位置。</p><h3 id="3-lower-upper"><a class="markdownIt-Anchor" href="#3-lower-upper"></a> 3. lower()、upper()</h3><p>大小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">str.upper()</span><br></pre></td></tr></table></figure><h4 id="4-split"><a class="markdownIt-Anchor" href="#4-split"></a> 4. split()</h4><p>分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">&#x27;tang#spoo#n&#x27;</span></span><br><span class="line">str.split(<span class="string">&#x27;#&#x27;</span>，<span class="number">1</span>)  <span class="comment">### [&#x27;tang&#x27;, &#x27;spoo#n&#x27;]</span></span><br><span class="line">str.split(<span class="string">&#x27;#&#x27;</span>)  <span class="comment">### [&#x27;tang&#x27;, &#x27;spoo&#x27;, &#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="5-strip"><a class="markdownIt-Anchor" href="#5-strip"></a> 5. strip()</h3><p>去除两端指定符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str&#x3D;&#39; tangspoon &#39;</span><br><span class="line">str.strip(&#39; &#39;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211208153223437.png&quot; alt=&quot;image-20211208153223437&quot; /&gt;&lt;/p&gt;
&lt;p&gt;自己写了好几个python项目之后发现，好多知识都遗忘了，有些没有理解透导致执行效率不高。趁这段时间有空，重新学习一下。&lt;/p&gt;
&lt;p&gt;list、dict、tuple、set、string&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>原创｜转发B站UP主动态到微信python脚本</title>
    <link href="https://blog.tangspoon.cn/2021/12/06/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%BD%AC%E5%8F%91B%E7%AB%99UP%E4%B8%BB%E5%8A%A8%E6%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1python%E8%84%9A%E6%9C%AC/"/>
    <id>https://blog.tangspoon.cn/2021/12/06/%E5%8E%9F%E5%88%9B%EF%BD%9C%E8%BD%AC%E5%8F%91B%E7%AB%99UP%E4%B8%BB%E5%8A%A8%E6%80%81%E5%88%B0%E5%BE%AE%E4%BF%A1python%E8%84%9A%E6%9C%AC/</id>
    <published>2021-12-06T13:32:12.000Z</published>
    <updated>2022-02-09T06:27:44.295Z</updated>
    
    <content type="html"><![CDATA[<img src="https://picbed.tangspoon.cn/uPic/image-20211206213430058.png" alt="image-20211206213430058" style="zoom:40%;" /><h2 id="一-需求"><a class="markdownIt-Anchor" href="#一-需求"></a> 一、需求</h2><p>B站关注了非常多up主，每天动态99+，但其实绝大部分的UP主我都不感兴趣。我每天都得手动寻找那些必看的UP。在寻找的过程中，大数据推荐让我忍不住看了一个又一个的视频，浪费时间不够专注。</p><p>所以，需要开发一个<strong>每天定时把我每天必看的UP主的动态转发到微信</strong>，这样避免了手动寻找和被大数据推荐的干扰，专注力大大提高。</p><a id="more"></a><h2 id="二-思路"><a class="markdownIt-Anchor" href="#二-思路"></a> 二、思路</h2><p>如果动态的发出日和系统当天日期相等，就把动态链接发送到微信。所以我们第一步是要获取到动态的发出日。第二步要完成的是而把信息转发到微信的功能，可以借助**<a href="https://sct.ftqq.com/upgrade?fr=sc">server酱</a>**完成。</p><h2 id="三-获取动态的发出日期"><a class="markdownIt-Anchor" href="#三-获取动态的发出日期"></a> 三、获取动态的发出日期</h2><h3 id="1-抓取动态api"><a class="markdownIt-Anchor" href="#1-抓取动态api"></a> 1. 抓取动态API</h3><p>上网找了一下，好像没有直接提供有关于动态的api，那我们F12看看。想要定位到UP主，api的参数肯定是带有uid，所以我们可以直接筛选出相关的api。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211206191118663.png" alt="image-20211206191118663" style="zoom:50%;" /><p>然后我们在两个api的response数据里面搜索<code>dynamic</code>，可以分析出第二条是应该就是我们可以用到的api了。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211206191429552.png" alt="image-20211206191429552" style="zoom:50%;" /><p><strong>Request URL:</strong></p><p><a href="https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history?visitor_uid=XXXXX&amp;host_uid=XXXXX&amp;offset_dynamic_id=0&amp;need_top=1&amp;platform=web">https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history?visitor_uid=XXXXX&amp;host_uid=XXXXX&amp;offset_dynamic_id=0&amp;need_top=1&amp;platform=web</a></p><p>从上面可以看出，参数有好几个。进一步在postman上测试出只有 <code>host_uid</code>是必须的参数。所以我们得出了Bilibili的动态api与必须参数：</p><blockquote><p><code>api</code>：<a href="https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history">https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/space_history</a></p><p><code>data</code>：host_uid（string，必填）</p></blockquote><h3 id="2-数据分析"><a class="markdownIt-Anchor" href="#2-数据分析"></a> 2. 数据分析</h3><p>在response里面搜索time，找到有个叫<code>timestamp</code>的字段。这很明显是时间戳。</p><img src="https://picbed.tangspoon.cn/uPic/image-20211206194517975.png" alt="image-20211206194517975" style="zoom:30%;" /><p>我们在<a href="https://tool.lu/timestamp/">时间戳在线转换网</a>里查看时间。经过对比，第一个<code>timestamp</code>就是我们需要的数据！</p><img src="https://picbed.tangspoon.cn/uPic/image-20211206200625092.png" alt="image-20211206200625092" style="zoom:33%;" /><img src="https://picbed.tangspoon.cn/uPic/image-20211206200652112.png" alt="image-20211206200652112" style="zoom:34%;" /><h2 id="四-server酱的使用"><a class="markdownIt-Anchor" href="#四-server酱的使用"></a> 四、server酱的使用</h2><p><code>server酱</code>的应用场景：<a href="https://sct.ftqq.com/apps">https://sct.ftqq.com/apps</a></p><p>使用<code>server酱</code>的使用也非常简单，官方有介绍（图中的<code>*</code>，是你们注册后的到的sendkey）</p><img src="https://picbed.tangspoon.cn/uPic/image-20211206201723794.png" alt="image-20211206201723794" style="zoom: 33%;" /><p>我们只需要制造好<code>title</code>和 <code>desp</code>参数的内容即可完成功能。</p><h2 id="五-uid列表的读取与写入"><a class="markdownIt-Anchor" href="#五-uid列表的读取与写入"></a> 五、uid列表的读取与写入</h2><p>因为是个人使用，所以没有写数据库，直接从<code>uid.txt</code>中读取数据。</p><p>但如果想要添加自己喜欢的up主要怎么更快捷的操作？答案可以从我的另一篇文章<a href="https://blog.tangspoon.cn/2020/12/31/%E6%99%BA%E8%83%BD%E9%97%B9%E9%92%9F%EF%BC%88%E4%BA%94%EF%BC%89%EF%BD%9C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E9%97%B9%E9%92%9F%EF%BC%9F/">《智能闹钟（五）｜如何优雅地关闭闹钟？》</a>中找到答案——IOS的快捷指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> xxxx &gt;&gt; uid.txt</span><br></pre></td></tr></table></figure><p>注意，图中的<code>每次均询问</code>是快捷指令的其中一个功能，在编辑脚本的时候可选。</p><img src="https://picbed.tangspoon.cn/uPic/IMG_3759.jpg" alt="IMG_3759" style="zoom: 33%;" /><img src="https://picbed.tangspoon.cn/uPic/IMG_3760.jpg" alt="IMG_3760" style="zoom:25%;" /><h2 id="六-部署到vps"><a class="markdownIt-Anchor" href="#六-部署到vps"></a> 六、部署到vps</h2><h3 id="1-建立uidtxt"><a class="markdownIt-Anchor" href="#1-建立uidtxt"></a> 1. 建立uid.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch &#x2F;home&#x2F;uid.txt</span><br><span class="line"># 添加uid</span><br><span class="line">vi &#x2F;home&#x2F;uid.txt</span><br></pre></td></tr></table></figure><h3 id="2-安装requests模块"><a class="markdownIt-Anchor" href="#2-安装requests模块"></a> 2. 安装requests模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># debian9</span><br><span class="line">apt-get install python-requests -y</span><br><span class="line"># centos</span><br><span class="line">yum install python-requests -y</span><br></pre></td></tr></table></figure><h3 id="2-换成python3"><a class="markdownIt-Anchor" href="#2-换成python3"></a> 2. 换成python3</h3><p>部署到vps可能会出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xc0 in position 7: ordi”</span><br></pre></td></tr></table></figure><p>这是因为出现系统中默认使用python2，换成python3就可以解决问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除/usr/bin目录下的python link文件</span></span><br><span class="line">sudo rm -rf /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除后再建立新的链接关系：</span></span><br><span class="line">sudo ln -s /usr/bin/python3<span class="number">.5</span> /usr/bin/python</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果想切换回python2.7</span></span><br><span class="line">sudo rm -rf /usr/bin/python</span><br><span class="line">sudo ln -s /usr/bin/ptyhon2<span class="number">.7</span> /usr/bin/python</span><br></pre></td></tr></table></figure><h3 id="3-设置crontab定时任务"><a class="markdownIt-Anchor" href="#3-设置crontab定时任务"></a> 3. 设置crontab定时任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00 22 * * * python BDynamicToWechat.py</span><br><span class="line"># 每天晚上10点执行任务</span><br></pre></td></tr></table></figure><h3 id="4-重启crontab"><a class="markdownIt-Anchor" href="#4-重启crontab"></a> 4. 重启crontab</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service cron restart</span><br></pre></td></tr></table></figure><h2 id="七-效果"><a class="markdownIt-Anchor" href="#七-效果"></a> 七、效果</h2><img src="https://picbed.tangspoon.cn/uPic/IMG_3761.jpg" alt="IMG_3761" style="zoom:33%;" /><img src="https://picbed.tangspoon.cn/uPic/IMG_3762.jpg" alt="IMG_3762" style="zoom:33%;" /><h2 id="八-代码"><a class="markdownIt-Anchor" href="#八-代码"></a> 八、代码</h2><p><strong>欢迎star</strong></p><blockquote><p>github地址：<a href="https://github.com/tangspoon66/BDynamicToWechat">https://github.com/tangspoon66/BDynamicToWechat</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211206213430058.png&quot; alt=&quot;image-20211206213430058&quot; style=&quot;zoom:40%;&quot; /&gt;
&lt;h2 id=&quot;一-需求&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-需求&quot;&gt;&lt;/a&gt; 一、需求&lt;/h2&gt;
&lt;p&gt;B站关注了非常多up主，每天动态99+，但其实绝大部分的UP主我都不感兴趣。我每天都得手动寻找那些必看的UP。在寻找的过程中，大数据推荐让我忍不住看了一个又一个的视频，浪费时间不够专注。&lt;/p&gt;
&lt;p&gt;所以，需要开发一个&lt;strong&gt;每天定时把我每天必看的UP主的动态转发到微信&lt;/strong&gt;，这样避免了手动寻找和被大数据推荐的干扰，专注力大大提高。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/categories/Python/"/>
    
    
    <category term="Python" scheme="https://blog.tangspoon.cn/tags/Python/"/>
    
    <category term="脚本" scheme="https://blog.tangspoon.cn/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>中国移动电视盒子刷机｜当贝市场</title>
    <link href="https://blog.tangspoon.cn/2021/12/05/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E5%88%B7%E6%9C%BA%EF%BD%9C%E5%BD%93%E8%B4%9D%E5%B8%82%E5%9C%BA%E9%9A%8F%E4%BE%BF%E8%A3%85APP/"/>
    <id>https://blog.tangspoon.cn/2021/12/05/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E5%88%B7%E6%9C%BA%EF%BD%9C%E5%BD%93%E8%B4%9D%E5%B8%82%E5%9C%BA%E9%9A%8F%E4%BE%BF%E8%A3%85APP/</id>
    <published>2021-12-05T03:08:01.000Z</published>
    <updated>2021-12-05T04:14:31.153Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picbed.tangspoon.cn/uPic/image-20211205120819625.png" alt="image-20211205120819625" /></p><a id="more"></a><h2 id="一-下载固件"><a class="markdownIt-Anchor" href="#一-下载固件"></a> 一、下载固件</h2><blockquote><p>这一步非常重要，搞不好会变砖。</p></blockquote><h3 id="1-确定机型"><a class="markdownIt-Anchor" href="#1-确定机型"></a> 1. 确定机型</h3><p>我的是：魔百盒CM201-2</p><p><img src="https://picbed.tangspoon.cn/uPic/IMG_3714.JPG" alt="IMG_3714" /></p><h3 id="2-确定芯片型号可跳过但有风险"><a class="markdownIt-Anchor" href="#2-确定芯片型号可跳过但有风险"></a> 2. 确定芯片型号（可跳过，但有风险）</h3><blockquote><p>为什么可跳过呢？因为会有一些型号通刷包，就像我这个CM201-2就有，但可能会有变砖风险。</p></blockquote><p>这一步需要拆开外壳，拧开两个隐藏在脚垫的螺丝就行。我的板子型号：M8273。</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211205121237365.png" alt="image-20211205121237365" /></p><h3 id="3-寻找-下载固件"><a class="markdownIt-Anchor" href="#3-寻找-下载固件"></a> 3. 寻找、下载固件</h3><p>带着机型、板子型号到搜索引擎搜索固件。在这里给两个比较靠谱的论坛：</p><p>小白刷机网「免费」：<a href="http://xiaobaishuaji.com/">http://xiaobaishuaji.com/</a></p><p>智能电视网「大多付费，但信息多」：<a href="https://www.znds.com/">https://www.znds.com/</a></p><p>麒麟刷机网「内容非常详尽」：<a href="https://www.szjytx.com/">https://www.szjytx.com/</a></p><h3 id="4-后路"><a class="markdownIt-Anchor" href="#4-后路"></a> 4. 后路</h3><p>是在找不到固件的话，可以加入上面三个论坛的交流群，会有很多大佬直接甩个链接给你下载。</p><p>我进了一个「魔百盒（IPTV盒子）技」，群号：517426928，氛围很好。（无广告哈）</p><img src="https://picbed.tangspoon.cn/uPic/image-20211205113956266.png" alt="image-20211205113956266" style="zoom:50%;" /><blockquote><p>CM201-2 ZG M8273版本的固件</p><p>百度云下载链接：<a href="https://pan.baidu.com/s/15Rv34NR4XMg-x2wVgCOPY">https://pan.baidu.com/s/15Rv34NR4XMg-x2wVgCOPY</a> 提取码：5nir</p><p>115：<a href="https://115.com/s/sw3vijh3z1i#">https://115.com/s/sw3vijh3z1i#</a>    访问码：ra18</p><p>腾讯微云：<a href="https://share.weiyun.com/yXW7Czpr">https://share.weiyun.com/yXW7Czpr</a> 密码：o9tkro</p></blockquote><h2 id="二-备份原版固件可跳过"><a class="markdownIt-Anchor" href="#二-备份原版固件可跳过"></a> 二、备份原版固件（可跳过）</h2><p>这一步我是跳过了的，因为需要ttl备份，花的时间太多，而且看了一下闲鱼这种破解好的机顶盒才几十一个。变砖了也不心疼。</p><p>相关备份有很多教程，每个型号都不一样，请自行搜索。</p><h2 id="三-开始刷机"><a class="markdownIt-Anchor" href="#三-开始刷机"></a> 三、开始刷机</h2><blockquote><ol><li>准备一个8G或以下的U盘</li><li>不要看刷机包里面的教程！！有问题！！</li></ol></blockquote><h3 id="1-文件处理"><a class="markdownIt-Anchor" href="#1-文件处理"></a> 1. 文件处理</h3><p>解压文件包后，如下。（第一个文件夹只有两个文件）</p><p><img src="https://picbed.tangspoon.cn/uPic/image-20211205114147760.png" alt="image-20211205114147760" /></p><blockquote><p>这里一定要按照我的步骤操作，<strong>不要</strong>看压缩包里面的“免拆刷机步骤.txt”</p></blockquote><p>在U盘中新建一个LOST.DIR的文件夹，然后把上图中第一个文件夹里面的“full-CM201-2-002.460.006-20180324120441.zip”复制到U盘里刚刚新建的LOST.DIR里面，然后把update.zip直接复制在U盘根目录。（如下）</p><p><img src="https://picbed.tangspoon.cn/uPic/Xnip2021-12-03_23-07-04-20211205110830145.jpg" alt="Xnip2021-12-03_23-07-04" /></p><p><img src="https://picbed.tangspoon.cn/uPic/Xnip2021-12-03_23-07-14.jpg" alt="Xnip2021-12-03_23-07-14" /></p><h3 id="2-机顶盒操作刷机"><a class="markdownIt-Anchor" href="#2-机顶盒操作刷机"></a> 2. 机顶盒操作刷机</h3><p>盒子开机，连续顺序点按遥控菜单键和音量减键，进入Recovery刷机模式。</p><p>选择从u盘刷入full-CM201-2-002.460.006-20180324120441.zip。</p><p>刷完机后重新启动机器，按遥控器的<strong>设置按钮</strong>。</p><p>无线/有线连接网络，查看网络信息，记下盒子的IP地址。（这一步可以直接路由器中查看盒子的ip）</p><p>运行免拆目录里的-双击执行-文件，按要求输入盒子IP地址。（这一步尽量用Windows系统电脑，因为macOS电脑好像会有问题）</p><p>批处理执行完毕后，盒子重启自动刷机直至完毕。</p><p><img src="https://picbed.tangspoon.cn/uPic/IMG_3715.JPG" alt="IMG_3715" /></p><h2 id="四-唠叨几句"><a class="markdownIt-Anchor" href="#四-唠叨几句"></a> 四、唠叨几句</h2><p>刷机有风险，看自己承受能力折腾。</p><p>魔百盒有很多代工厂，每个配件可能都会不一样，都会导致刷机的失败。所以，尽量找那种和所有硬件信息（cpu、wifi模块、闪存类型……）都匹配的固件。</p><p>刷机过程可能不会和教程一模一样，就自己理解整个流程，灵活变通一下吧。而且反正几十块一个而已，变砖了大不了重新买一个，大胆搞，学多点东西。</p><p>（我要看人生一串去了）</p><p><img src="https://picbed.tangspoon.cn/uPic/IMG_3716.JPG" alt="IMG_3716" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://picbed.tangspoon.cn/uPic/image-20211205120819625.png&quot; alt=&quot;image-20211205120819625&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="硬件" scheme="https://blog.tangspoon.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
    <category term="硬件" scheme="https://blog.tangspoon.cn/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
